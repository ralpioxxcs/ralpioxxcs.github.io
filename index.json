[{"content":"1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면\nAscending Stack VS Descending Stack으로 나눌 수 있다.\n스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.\n 2. 코드 구현 2-1. define structure typedef struct _stacknode Snode; struct _stacknode { DataType data; Snode *next; }; typedef struct _stack { Snode *head; Snode *tail; Snode *cur; }Stack; 스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.\n2-2. Init Stack void initStack(Stack *sPtr) { sPtr-\u0026gt;head = (Snode *)malloc(sizeof(Snode)); //헤드 노드 생성  assert(sPtr-\u0026gt;head!=NULL); sPtr-\u0026gt;tail = (Snode *)malloc(sizeof(Snode)); //테일 노드 생성  assert(sPtr-\u0026gt;tail!=NULL); /*헤드노드가 테일노드를, 테일노드가 헤드노드를 가리키게 함*/ sPtr-\u0026gt;head-\u0026gt;next=sPtr-\u0026gt;tail; sPtr-\u0026gt;tail-\u0026gt;next=sPtr-\u0026gt;tail; sPtr-\u0026gt;cur = NULL; return ; } 헤드노드와 테일노드를 메모리 할당해주고 서로 가리키게 해준다\n2-3. Push /* stack에 데이터 저장하기 */ int push(Stack *sPtr, DataType inData) { sPtr-\u0026gt;cur = (Snode *)malloc(sizeof(Snode)); //새로운 노드 생성  // 메모리 할당 실패하면 push실패  if(sPtr-\u0026gt;cur==NULL) { return FALSE; } //노드를 헤드노드 바로 뒤에 노드 추가  sPtr-\u0026gt;cur-\u0026gt;next=sPtr-\u0026gt;head-\u0026gt;next; sPtr-\u0026gt;head-\u0026gt;next=sPtr-\u0026gt;cur; sPtr-\u0026gt;cur-\u0026gt;data = inData; //데이터 복사  return TRUE; } 전달인자로 스택구조체의 주소와 삽입할 데이터를 받는다.\n새 노드를 할당하기위해 메모리를 할당하고 위로 쌓이는 것이므로 (처음 삽입하는경우) 헤드노드 바로 뒤에 노드를 추가해주는데, 두 번째 삽입부터는 노드가 이미 하나있기때문에 그 노드의 뒤로 삽입을 해야한다. 따라서, 새로 할당받은 노드의 다음주소에 그 이전 노드를 가리키게 하고 이전 노드는 새로 할당받은 노드를 가리키게 한다.\n2-4. Pop int pop(Stack *sPtr, DataType *popData) { // stack이 비어있으면 pop실패  if(sPtr-\u0026gt;head-\u0026gt;next == sPtr-\u0026gt;tail) { return FALSE; } *popData = sPtr-\u0026gt;head-\u0026gt;next-\u0026gt;data; sPtr-\u0026gt;cur = sPtr-\u0026gt;head-\u0026gt;next; sPtr-\u0026gt;head-\u0026gt;next = sPtr-\u0026gt;head-\u0026gt;next-\u0026gt;next; free(sPtr-\u0026gt;cur); return TRUE; } 제일 위에있는게 먼저 나가야하므로 popData에 가장 위에있는 노드의 data를 넣어주고, 제일 위에 있는 노드에 이어져 있는 선을 끊어주고 다음 노드와 이어주게 한다. 그리고 메모리를 해제\n","permalink":"https://ralpioxxcs.github.io/cs/stack/","summary":"1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면\nAscending Stack VS Descending Stack으로 나눌 수 있다.\n스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.\n 2. 코드 구현 2-1. define structure typedef struct _stacknode Snode; struct _stacknode { DataType data; Snode *next; }; typedef struct _stack { Snode *head; Snode *tail; Snode *cur; }Stack; 스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.","title":"Stack"},{"content":"1. 개요 선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다.\n큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.\n 2. 선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.( Front == Rear )\n데이터를 5개 모두 넣었다면 Rear값은 5가 되어있을것이고 큐가 모두 찼으므로 이 상태는 큐가 포화상태라는 것을 뜻 한다. ( 큐 Size == Rear )\n이렇게만 보면 선형 큐가 문제가 없어보이지만 바로 여기서 선형 큐의 맹점이 드러난다. 현재 큐가 꽉 차있는 상태에서 데이터를 하나 삭제하게되면 Front값이 1로 증가할것이고 빈 방 1개가 나올것이다, 그런데 Front는 1 이고 Rear는 5이므로 큐의 공백조건을 만족하지 못하므로 빈 방이 있음에도 불구하고 큐의 데이터삽입이 불가능하게 된다. 이러한 맹점을 보완한것이 바로 **원형 큐 (Circular Queue)**이다.\n 3. 원형 큐 (Circula Queue) **원형 큐 (Circular Queue)**는 선입선출(先入先出, First In First Out; FIFO)를 그대로 유지하면서 큐의 입구와 출구를 연결하여 원형으로 만들어 사용하는 구조이다.이때, Front와 Rear사이에 완충지대를 두어 원형 큐의 비어있는 상태와 포화상태를 구분한다. 완충지대의 위치는 항상 Front의 하나 앞방이다. (유동성)\n완충지대 때문에 예를들어 7개의 데이터를 넣는 큐를 만드려면 큐의 사이즈를 8으로 지정하여야한다. 초기에는 Front와 Rear는 0으로 설정한다. 자동으로 완충지대는 [7]번방이 된다.\n원형 큐 에서는 Rear값 및 Front값을 증가시킬때 선형 큐처럼 단순히 +1을 하게되면 원형 큐가 되지 않으므로 \u0026ldquo;%\u0026rdquo; 기능을 활용하여 Rear값을 바꿔준다.\nRear가 0번방에서 1번방으로 가야하므로 +1을 해준뒤 큐 사이즈만큼 나눠주고 나머지 값을 Rear값으로 하면 된다. ( Rear = (Rear+1) % QueueSize )\n계속 데이터를 삽입하여 7번방까지 데이터를 삽입하였다면 Rear가 완충지대를 가리키고 있을것이고 이 상태는 포화상태를 의미한다. 즉, Rear가 완충지대를 가리키고있다면 큐는 포화상태라는 뜻이다. 공백상태는 선형 큐와 같다. Rear와 Front가 같으면 공백상태를 뜻한다.\n그러면 여기서, 아까 선형 큐가 해결하지 못했던 문제를 해결할 수 있다. 데이터가 꽉 차있는 상태에서 Dequeue를 하여 Front값을 1로 바꿔준다 ( Front = (Front +1) % QueueSize )\n그러면 자동으로 완충지대는 Front가 이동하였으므로 원래위치 7번방에서 (Front의 이전 방) 0번방으로 옮겨갈 것이다.\n따라서, Rear는 완충지대를 가리키고 있지 않으므로 큐의 포화조건에서 탈출하게 되고 데이터의 삽입이 가능해진다. Rear가 7번방이었으므로 위와같이 ( Rear = (Rear+1) % QueueSize ) 를 이용하면 Rear는 0번방을 가리키며 0번방에 데이터를 삽입하게 된다.\n 4. 코드 구현 4-1. define structure typedef struct _queue { DataType *queue; int qSize; int front, rear; }Queue; 큐를 관리하는 구조체\n데이터를 저장할 데이터필드 영역과 큐의 크기를 저장하는 변수, Front와 Rear를 지정하는 변수로 이루어져있다.\n4-2. Create Queue void initQueue(Queue * qPtr, int size) { qPtr-\u0026gt;qSize = size; qPtr-\u0026gt;front = 0; qPtr-\u0026gt;rear = 0; qPtr-\u0026gt;queue = (DataType *)calloc(qPtr-\u0026gt;qSize, sizeof(DataType)); } 큐를 초기화 및 생성하는 함수\n전달인자로 큐의 사이즈를 받아서 큐의 사이즈를 넣어주고, Front와 Rear의 값을 모두 0으로 초기화한뒤 calloc함수를 통해 size만큼 메모리를 할당받는다.\n4-3. Enqueue int enqueue(Queue * qPtr, DataType inData) { // rear가 완충지대에 있으면 put불가  if((qPtr-\u0026gt;rear+1)%qPtr-\u0026gt;qSize == qPtr-\u0026gt;front){ return FALSE; } qPtr-\u0026gt;queue[qPtr-\u0026gt;rear] = inData; qPtr-\u0026gt;rear++; qPtr-\u0026gt;rear = (qPtr-\u0026gt;rear)%qPtr-\u0026gt;qSize; return TRUE; } 큐에 데이터를 삽입하는 함수\n처음 조건문을 걸어서 큐가 비어있는지 확인한다. Rear가 완충지대에 있으면 큐가 포화상태인것이므로 True시 False를 리턴한다. False일시, 아래 코드로 내려와서 현재 Rear값에 데이터를 넣어주고, Rear값 증가한다.\n( Rear = (Rear+1) % QueueSize )\n4-4. Dequeue int dequeue(Queue * qPtr, DataType * getData) { // 큐가 비어있으면 dequeue 불가  if( isQueueEmpty(qPtr) ) { return FALSE; } *getData = qPtr-\u0026gt;queue[qPtr-\u0026gt;front]; qPtr-\u0026gt;front++; qPtr-\u0026gt;front = (qPtr-\u0026gt;front)%qPtr-\u0026gt;qSize; return TRUE; } 큐에서 데이터를 빼와 출력하는 함수\n전달인자로 출력할 데이터의 주소값을 받아오고 초기 조건문으로 큐가 비어있는지 함수를 통해 확인, 비어있지않을시, Front방의 값을 불러오고 front를 하나 증가시킨다.\n( Front = (Front +1) % QueueSize )\n4-5. Check int isQueueEmpty(const Queue *qPtr) { if(qPtr-\u0026gt; front == qPtr-\u0026gt;rear) return TRUE; else return FALSE; } 큐가 비었는지 확인하는 함수로 Front와 Rear가 같을때 큐가 빈것으로 판별\n","permalink":"https://ralpioxxcs.github.io/cs/circulaqueue/","summary":"1. 개요 선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다.\n큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.\n 2. 선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.","title":"CirculaQueue"},{"content":"Logrus? golang에서 사용하는 대표적인 logging 패키지인 logrus는 stdout, stderr등 다양한 output 및 커스터마이징이 가능한 formatter등 구조화된 로깅을 지원한다.\n구조화된(structured) 로깅? 로그를 단순한 텍스트의 연속이 아닌 특정 데이터 세트(날짜, 사용자, 각종 필드)로 처리할 수 있도록 특정한 메시지 포맷을 구현하는 방식이다.\n기본 사용법 간단하게 콘솔창에 로그를 찍는 예제는 다음과 같다\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; log \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log.SetOutput(os.Stdout) log.SetFormatter(\u0026amp;log.TextFormatter{ FullTimestamp: true, TimestampFormat: time.RFC822, }) log.SetLevel(log.InfoLevel) log.Info(\u0026#34;Info message\u0026#34;) log.WithFields(log.Fields{ \u0026#34;name\u0026#34;: \u0026#34;Neymar\u0026#34;, \u0026#34;age\u0026#34;: 32, \u0026#34;club\u0026#34;: \u0026#34;PSG\u0026#34;, }).Info(\u0026#34;Info message with fields\u0026#34;) log.Debug(\u0026#34;Debug message\u0026#34;) log.SetLevel(log.DebugLevel) log.Info(\u0026#34;Info message\u0026#34;) log.Debug(\u0026#34;Debug message\u0026#34;) } INFO[07 Jun 22 23:08 KST] Info message INFO[07 Jun 22 23:54 KST] Info message with fields age=32 club=PSG name=Neymar INFO[07 Jun 22 23:08 KST] Info message DEBU[07 Jun 22 23:08 KST] Debug message 이외에 다양한 사용방법에 대해서는 logrus 공식레포에서 확인하도록 하자\n Multisink 로깅 개발을 하다보면 단순히 콘솔창뿐만 아니라 파일에 로그를 남겨야 할 경우가 있다. 당연하게도 logrus 패키지에서는 io.Writer를 파라미터로 받는 logrus.SetOutput를 사용하여 콘솔, 파일 둘 다 동시에 로깅을 할 수 있다.\nfile, err := os.OpenFile(\u0026#34;test.log\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0755) if err != nil { panic(err) } log.SetOutput(io.MultiWriter(os.Stdout, file)) 위 코드를 실행하게 되면 아래와 같은 출력과 로그파일을 볼수있다.\ntime=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=info msg=\u0026#34;Info message\u0026#34; time=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=info msg=\u0026#34;Info message\u0026#34; time=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=debug msg=\u0026#34;Debug message\u0026#34; 로깅 형식이 바뀐 이유 단순히 output을 바꿔주기만 했을뿐인데 로깅 포맷이 바뀌었다. 그 이유가 너무 궁금해서 패키지 내부 코드를 살펴보았다\nfunc (entry *Entry) write() { serialized, err := entry.Logger.Formatter.Format(entry) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Failed to obtain reader, %v\\n\u0026#34;, err) return } entry.Logger.mu.Lock() defer entry.Logger.mu.Unlock() if _, err := entry.Logger.Out.Write(serialized); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Failed to write to log, %v\\n\u0026#34;, err) } } logrus 내부에서 실질적으로 로깅을 하는 부분을 봤더니 formatting된 byte slice를 받아서 logger에 등록된 io.Writer을 통해 write를 하는부분을 볼수 있었다.\nf.terminalInitOnce.Do(func() { f.init(entry) }) timestampFormat := f.TimestampFormat if timestampFormat == \u0026#34;\u0026#34; { timestampFormat = defaultTimestampFormat } if f.isColored() { f.printColored(b, entry, keys, data, timestampFormat) } else { // ... 출력 형식이 바뀐 이유가 된 핵심 부분이다. logrus내부에서 각 formatter에 맞게 형식을 변환시키는데 기본 TextFormatter의 경우, isTerminal이라는 변수로 터미널 여부를 판단한다. f.isColored 의 조건에 맞으면 원했던 로깅 포맷을 출력하게 되어있다.\nisColored := f.ForceColors || (f.isTerminal \u0026amp;\u0026amp; (runtime.GOOS != \u0026#34;windows\u0026#34;)) isColored의 조건은 위와 같다. 따라서 Formatter의 옵션중 하나인 ForceColors를 true로 설정해주면 이 문제는 해결된다.\n아래에서 서술할 내용이지만, 터미널 출력이 아닐경우 color code값이 로그파일에 남게되어 지저분해지니까 위와 같은 처리를 한 것같다.\nForceColor 옵션의 문제점 \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message with fields \u001b[36mage\u001b[0m=32 \u001b[36mclub\u001b[0m=PSG \u001b[36mname\u001b[0m=Neymar \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message \u001b[37mDEBU\u001b[0m[08 Jun 22 00:35 KST] Debug message ForceColors옵션을 주어 강제로 색상을 주고 로그파일을 보면 위와같이 콘솔에서 색상을 출력해주기위한 color code값이 그대로 적혀있다.\n로깅 자체에는 문제가 없지만 파일을 열어서 봤을때 보기도 힘들고 아무래도 뭔가 찝찝하다\u0026hellip; 그렇다고 DisableColors값을 false로 주어 위 color code값을 없애자니 콘솔창에서 색상 highlight가 되지 않는다.\n사실 로그파일을 읽을때 grep 으로 level keyword를 highlight를 하는 등의 특정 키워드를 highlight하는 방법은 여러가지가 있다.\n그래도 이렇게 마무리하면 아쉬울 것 같아서\n 같은 로깅 포맷을 사용 콘솔에서는 highlight를 그대로 사용 파일 로깅시에는 color code값을 제거  위를 모두 만족하는 방법은 없을까 해서 열심히 구글링을 해보다가. 비슷한 문제로 issue가 올라온걸 보았다.\n답변을 요약하면 SetOutput(os.Stdout)은 그대로 적용해 coloring을 하고, 별도의 formatter를 갖는 Hook을 추가하는 방법으로 문제를 해결하는 방법을 말하고 있다.\nFile Hooking logrus는 hook기능을 제공하는데 hook을 이용해 지정된 곳에 한번에 로그를 남길 수 있다.\n우선 color code가 없는 형태의 custom formatter 인터페이스를 구현한다\ntype PlainFormatter struct { log.TextFormatter TimestampFormat string LevelDesc []string } func NewPlainFormatter() *PlainFormatter { return \u0026amp;PlainFormatter{ TimestampFormat: time.RFC3339, LevelDesc: []string{\u0026#34;PANC\u0026#34;, \u0026#34;FATL\u0026#34;, \u0026#34;ERRO\u0026#34;, \u0026#34;WARN\u0026#34;, \u0026#34;INFO\u0026#34;, \u0026#34;DEBG\u0026#34;}, } } func (f *PlainFormatter) Format(entry *log.Entry) ([]byte, error) { timestamp := fmt.Sprintf(\u0026#34;%v\u0026#34;, entry.Time.Format(f.TimestampFormat)) return []byte(fmt.Sprintf(\u0026#34;[%s] [%s] %s\\n\u0026#34;, f.LevelDesc[entry.Level], timestamp, entry.Message)), nil } 다음으로 file을 생성하는 Hook 인터페이스를 구현한다\ntype FileHook struct { Formatter logrus.Formatter Level []logrus.Level Writer io.Writer } func NewFileHook() log.Hook { file, err := os.OpenFile(\u0026#34;test.log\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0755) if err != nil { panic(err) } return \u0026amp;FileHook{ Formatter: NewPlainFormatter(), Level: []log.Level{ log.InfoLevel, }, Writer: file, } } func (h *FileHook) Fire(entry *log.Entry) error { bytes, err := h.Formatter.Format(entry) if err != nil { return err } h.Writer.Write(bytes) return nil } func (h *FileHook) Levels() []logrus.Level { return h.Level } 중요한 부분은 FileHook 구조체에 별도의 Formatter와 Writer를 설정하는것이다.\nbuilt-in formatter인 TextFormatter를 사용하지 않는 이유는 color code값을 제거하기 위해서다.\n위 설정을 모두 추가한 후, 실제 사용부분에서 log.AddHook(NewFileHook) 만 추가해주면 완성이다.\n실제 쓰여진 파일로그를 보면, WithFields를 사용한 로그는 적용되지 않는데, 그 부분은 PlainFormatter의 interface method인 Format()에서 별도로 처리해야 한다.\n Reference  https://github.com/sirupsen/logrus/issues/784  ","permalink":"https://ralpioxxcs.github.io/post/logging/","summary":"Logrus? golang에서 사용하는 대표적인 logging 패키지인 logrus는 stdout, stderr등 다양한 output 및 커스터마이징이 가능한 formatter등 구조화된 로깅을 지원한다.\n구조화된(structured) 로깅? 로그를 단순한 텍스트의 연속이 아닌 특정 데이터 세트(날짜, 사용자, 각종 필드)로 처리할 수 있도록 특정한 메시지 포맷을 구현하는 방식이다.\n기본 사용법 간단하게 콘솔창에 로그를 찍는 예제는 다음과 같다\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; log \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log.SetOutput(os.Stdout) log.SetFormatter(\u0026amp;log.TextFormatter{ FullTimestamp: true, TimestampFormat: time.RFC822, }) log.SetLevel(log.InfoLevel) log.Info(\u0026#34;Info message\u0026#34;) log.","title":"Golang Logrus Hook을 이용한 mutisink 로깅"},{"content":"좌표 정규화   투영\n  카메라 parameter를 알고 있다고 가정하고, normalized 좌표는 다음 계산식을 통해 영상 좌표로 변환된다.\n\\[ x_{img} = x_{norm}*f_x + c_x \\\\ y_{img} = y_{norm}*f_y + c_y \\]\n반대로, 식을 바꿔 image plane 좌표 또한 normalized 좌표로 변환될 수 있다.\n\\[ x_{norm} = (x_{img}-c_x)/f_x \\\\ y_{norm} = (y_{img}-c_y)/f_y \\]\nfx, fy는 focal length, 초점거리, cx,cy는 principal point 즉, 주점이라고 부른다. 이 요소들을 3x3 행렬로 만든것을 camera matrix 혹은 intrinsic paramter라고 한다.\n\\[ \\begin{bmatrix} f_x \u0026 0 \u0026 c_x \\\\ 0 \u0026 f_y \u0026 c_y \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\]\n3D-2D Projection   위에서 설명한 좌표계를 바탕으로 3차원의 월드 좌표가 2차원의 이미지 평면으로 projection 되는것을 아래와 같이 표현할 수 있다.\n\\[ s {\\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix}} = \\begin{bmatrix} f_x \u0026 0 \u0026 c_x \\\\ 0 \u0026 f_y \u0026 c_y \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix}\\begin{bmatrix} r_{11} \u0026 r_{12} \u0026 r_{13} \u0026 t_{1}\\\\ r_{21} \u0026 r_{22} \u0026 r_{23} \u0026 t_{2}\\\\ r_{31} \u0026 r_{32} \u0026 r_{33} \u0026 t_{3}\\ \\end{bmatrix}\\begin{bmatrix} X \\\\ Y \\\\ Z \\\\ 1 \\end{bmatrix} \\\\ (s = scale factor) \\]\n위의 식을 간단히 표현하면 아래와 같다\n\\[ s {\\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix}} = K[R | t]\\begin{bmatrix} X \\\\ Y \\\\ Z \\\\ 1 \\end{bmatrix} \\]\n여기서 K 행렬을 카메라 내부 파라미터인 intrinsic parameter 라고 부르고,\n[R|t]를 행렬 카메라 외부 파라미터인 extrinsic parameter라고 칭한다.\n내부 파라미터 (intrinsic)   내부 파라미터는 카메라 focal length 를 나타내는 fx,fy principal point를 나타내는 cx,cy 로 구성된다. 초점 거리는 렌즈의 중심과 이미지 센서 (CMOS)의 중심간의 거리를 뜻한다. 카메라 캘리브레이션에서 사용하는 초점 거리의 단위(unit)는 pixel 단위로 표현된다.\n\\[ Fx = f_x * W/w \\\\ Fy = f_y * H/h \\\\ \\]\n(F : mm단위, f : pixel 단위, W,H : 이미지 센서 너비,높이 , w,h : 이미지 센서 픽셀 너비,높이)\n위의 관계식을 통해 실제 초점거리를 구할 수 있다.\nExample focal length 가 4.2mm 이고 image sensor의 크기가 1/2.9' 일때, pixel 단위는?\n1/2.9\u0026#39; 이미지 센서 - W: 4.96mm, H: 3.72mm - w: 728pix, h: 544pix f_x = (4.2mm * 728pix) / 4.96mm -\u0026gt; 약, 616pix f_y = (4.2mm * 544pix) / 3.72mm -\u0026gt; 약, 614pix 주점을 나타내는 cx, cy 는 렌즈의 중심점이 이미지 센서로 투영된 점을 뜻한다. 언뜻 영상의 중심점으로 해석될 수 있으나, 카메라 조립 과정중 이미지 센서와 렌즈가 수평을 이루지 못하면, 영상 중심점과 주점은 서로 다른 값을 가질 수 있다. 이 외에 비대칭 계수(skew coefficients)가 있지만, 무시할 만큼 작은 값이고 현대의 카메라에서는 skew가 없기 때문에 고려하지 않는다.\n외부 파라미터 (extrinsic) 카메라 좌표계와 월드 좌표계 사이의 변환 관계를 나타내는 파라미터로 두 가지 행렬로 구성된다.\n Rotation matrix, 회전 Translation matrix, 평행이동  intrinsic parameter와는 달리 카메라의 position, posture의 변화에 따라 달라지는 값이므로, 고유한 값을 갖지 않는다.\n","permalink":"https://ralpioxxcs.github.io/post/etc/camera_calibration_2/","summary":"좌표 정규화   투영\n  카메라 parameter를 알고 있다고 가정하고, normalized 좌표는 다음 계산식을 통해 영상 좌표로 변환된다.\n\\[ x_{img} = x_{norm}*f_x + c_x \\\\ y_{img} = y_{norm}*f_y + c_y \\]\n반대로, 식을 바꿔 image plane 좌표 또한 normalized 좌표로 변환될 수 있다.\n\\[ x_{norm} = (x_{img}-c_x)/f_x \\\\ y_{norm} = (y_{img}-c_y)/f_y \\]\nfx, fy는 focal length, 초점거리, cx,cy는 principal point 즉, 주점이라고 부른다. 이 요소들을 3x3 행렬로 만든것을 camera matrix 혹은 intrinsic paramter라고 한다.","title":"카메라 캘리브레이션 - 좌표변환"},{"content":"카메라 캘리브레이션 3차원의 장면이 카메라를 통해 2차원의 평면으로 구현될 때, 각각의 3차원 상의 점들은 카메라의 위치, 방향 같은 기하학적인 요소와 이미지 센서의 초점 거리, 렌즈의 왜곡 등 여러 내부적인 요소(parameters) 들에 의해 결정된다. 이 내부 요소들을 통해 렌즈의 왜곡, 3D상의 물체에 대한 크기 및 면적, 카메라의 위치등을 계산할 수 있으며, 이 값들을 구하는 과정을 카메라 캘리브레이션 이라고 부른다.\n좌표계   좌표계\n  카메라 캘리브레이션에서는 주로 4가지의 좌표계가 사용된다\n 월드 좌표계 (3D) 픽셀 좌표계 정규 좌표계 카메라 좌표계  월드 좌표계 사물의 위치를 나타내는 좌표계로 3차원(X,Y,Z)을 사용하는 좌표계이다. 목표로 하는 사물의 위치를 기준으로 잡아 사용할 수 있으며, X축 Y축 또한 기준 원점을 어디로 삼느냐에 따라 달라질 수 있다.\n$$ P = (X,Y,Z) $$\n카메라 좌표계 월드 좌표계와 비슷하지만 어떤 공간상의 한 지점이 아닌 카메라의 광학축을 기준으로 한 3차원 좌표계이다. 카메라 렌즈의 정면 방향을 Z축, 카메라 렌즈의 아래쪽이 Y축, 렌즈의 오른쪽 방향을 X축으로 잡는다. 월드 좌표계와 동일한 단위(unit)을 사용해야 한다.\n$$ P_c = (X_c,Y_c,Z_c) $$\n영상 좌표계 (Image coordinate) 영상에서 사용하는 좌표계로, 이미지의 좌상단을 원점으로 오른쪽 방향이 x축, 아래쪽이 y축인 2차원 좌표계이다. 월드 좌표계의 한 점 P 는 영상 좌표계 평면의 한 점 p 로 투영된다.\n$$ p_i = (x,y) $$\n정규 좌표계 (Normalized Image coordinate) 카메라 parameter의 영향을 받지 않는 정규화된 이미지 좌표계로, 카메라의 초점거리가(f) 1인 가상의 이미지 좌표계를 뜻한다. 이상적인 카메라 모델인 핀홀 카메라 모델 이 정의하는 좌표계와 같다. 각 카메라간의 서로 다른 parameter들의 종속성을 없애기 위해, 불필요한 요소가 제거된 정규화된 이미지 평면 좌표계를 사용한다.\n$$ p_n = (u,v) $$\n","permalink":"https://ralpioxxcs.github.io/post/etc/camera_calibration_1/","summary":"카메라 캘리브레이션 3차원의 장면이 카메라를 통해 2차원의 평면으로 구현될 때, 각각의 3차원 상의 점들은 카메라의 위치, 방향 같은 기하학적인 요소와 이미지 센서의 초점 거리, 렌즈의 왜곡 등 여러 내부적인 요소(parameters) 들에 의해 결정된다. 이 내부 요소들을 통해 렌즈의 왜곡, 3D상의 물체에 대한 크기 및 면적, 카메라의 위치등을 계산할 수 있으며, 이 값들을 구하는 과정을 카메라 캘리브레이션 이라고 부른다.\n좌표계   좌표계\n  카메라 캘리브레이션에서는 주로 4가지의 좌표계가 사용된다","title":"카메라 캘리브레이션 - 좌표계"},{"content":"CGo CGo는 Go에서 C언어를 사용할 수 있게해주는 Go의 feature중 하나이다. 이 기능을 이용해 C언어와 Go언어사이의 콜백함수를 만들어 볼 것이다. 주의할 점은 CGo에서 읽을 수 있는것은 C스타일의 심볼을 갖는 함수 뿐이다. 순수 C언어로만 작성된 라이브러리라면 문제가 없겠지만 C++ 베이스의 함수를 이용하고 싶기 때문에 해당 함수를 한번 wrapping해주는 형태로 만들어 볼 것이다\n기본 사용법 함수를 wrapping 해보기 전, 기본적인 사용법을 다시 보자\npackage main /* #include \u0026lt;stdio.h\u0026gt; void CFoo() { printf(\u0026#34;Hello from C\\n\u0026#34;); } */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello from Go\u0026#34;) C.CFoo() } 출력결과는 다음과 같을 것이다\nHello from Go Hello from C C++ 함수 래핑 Cpp함수를 래핑하여 Go에서 호출하는 방법이다\n// foo.h #include \u0026lt;string\u0026gt;void Foo(std::string str); // ------------------------------------------------  // foo.cpp #include \u0026#34;foo.h\u0026#34;#include \u0026lt;iostream\u0026gt;void Foo(std::string str) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } 위의 함수를 가지는libfoo.so 라이브러리가 있다고 했을 때, Go에서 위 함수를 사용하기 위해선 CGo에서 wrapper함수를 만들어 호출하는 방식을 사용하면 된다. CGo에서는 C스타일의 심볼만 읽을 수 있기 때문에 래퍼함수의 헤더파일은 반드시 C 스타일로 작성하여야 한다.\n// fooWrapper.h #ifdef __cplusplus #define extern \u0026#34;C\u0026#34; { #endif  void FooCGo(char* str); #ifdef __cplusplus } #endif // fooWrapper.cpp #include \u0026#34;fooWrapper.h\u0026#34; #include \u0026#34;foo.h\u0026#34;void FooCGo(char* str) { Foo(str); } // fooWrapper.go package fooWrapper /* #cgo CFLAGS: -I/path/to/cpp_lib #cgo CXXFLAGS: -I/path/to/cpp_lib #cgo LDFLAGS: -L/path/to/cpp_lib -lfoo #include \u0026#34;fooWrapper.h\u0026#34; */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func Foo() { fmt.Println(\u0026#34;Hello from Go\u0026#34;) C.FooCGo(C.CString(\u0026#34;Hello from CGo\u0026#34;)) } 출력결과 Hello from Go Hello from CGo 소스 파일에서 foo.h를 인클루드하고, libfoo.so의 함수Foo()를 호출해주면 된다. 중요한 점은 CGo에서 컴파일 될 수 있도록 extern \u0026quot;C\u0026quot;키워드를 사용하는 것이다.\nGo콜백함수 부르기 그렇다면, Go함수에서 콜백함수를 정의하고 그 함수를 C언어에서 콜백함수를 등록하는 방법이 있을까? CGo에서는 export를 사용하여 Go로 작성된 함수를 C언어 심볼로 export할 수 있다.\n// foo.h #include \u0026lt;functional\u0026gt;using callbackFn = std::function\u0026lt;void(int a)\u0026gt;; void DoSomething(callbackFn fn) // ------------------------------------------------  // foo.cpp #include \u0026#34;foo.h\u0026#34;#include \u0026lt;iostream\u0026gt;void DoSomething(callbackFn fn) { std::cout \u0026lt;\u0026lt; \u0026#34;foo::DoSomething()\u0026#34; \u0026lt;\u0026lt; std::endl; fn(7); } 위 형태의 콜백함수를 인자로 갖는 호출하는 함수가 있다고 해보자, 우리는 위에서 CPP함수를 래핑하는 방법을 통해서 CPP함수를 호출할 수 있었다. 그리고 Go에서 작성된 콜백함수를 DoSomething()함수의 함수포인터로 보내고 싶다고 하자\n// fooWrapper.h #ifdef __cplusplus #define extern \u0026#34;C\u0026#34; { #endif typedef void(*callbackFnCGO)(int a); void DoSomethingCGO(callbackFnCGO fn) #ifdef __cplusplus } #endif 아까 했던 방법과 같은 방식으로 DoSomething()래퍼 함수를 만들고, C스타일 자료형 지정자 typedef 키워드로 콜백함수 형식을 만든다.\n// fooWrapper.go package wrapper /* #cgo CFLAGS: -I/path/to/cpp_lib #cgo CXXFLAGS: -I/path/to/cpp_lib #cgo LDFLAGS: -L/path/to/cpp_lib -lfoo #include \u0026#34;fooWrapper.h\u0026#34; void myCallback(int a); */ import \u0026#34;C\u0026#34; func DoSomething() { C.DoSomethingCGO(C.callbackFnCGO(C.myCallback)) } //export myCallback func myCallback(a C.int) { fmt.Printf(\u0026#34;callback from go context (%v)\\n\u0026#34;, int(a)) } (예제 코드 보기)\nGo에서 콜백함수를 작성하고 주석으로 //export [함수이름]의 형태로 작성한다. CGo에서 이 부분을 보고 C함수심볼로 만들어주고 그것을 코드내에서 C.[export한 함수이름]로 사용할 수 있다. 그 함수를 래핑함수의 파라미터로 넘겨주면 된다. 주의할 점은 //와 export사이에 공백이 있으면 안된다. 이 점을 유의하여 삽질하지 않도록 주의하자..\n출력결과 foo::DoSomething() callback from go context (7) c/c++ 베이스로 작성된 라이브러리가 있고, 해당 라이브러리를 사용하는 REST API, GraphQL등의 서버 어플리케이션을 만들어야 할 때 자주 사용하는 방법인데 함수를 래핑하는 방법이 약간 노가다성이 있기도 하지만.. 생산성 및 효율성 등을 고려하면 사용하는 방법만 알아두면 유용하게 쓰일 수 있을 것 같다.\n","permalink":"https://ralpioxxcs.github.io/post/etc/cgo_callback/","summary":"CGo CGo는 Go에서 C언어를 사용할 수 있게해주는 Go의 feature중 하나이다. 이 기능을 이용해 C언어와 Go언어사이의 콜백함수를 만들어 볼 것이다. 주의할 점은 CGo에서 읽을 수 있는것은 C스타일의 심볼을 갖는 함수 뿐이다. 순수 C언어로만 작성된 라이브러리라면 문제가 없겠지만 C++ 베이스의 함수를 이용하고 싶기 때문에 해당 함수를 한번 wrapping해주는 형태로 만들어 볼 것이다\n기본 사용법 함수를 wrapping 해보기 전, 기본적인 사용법을 다시 보자\npackage main /* #include \u0026lt;stdio.h\u0026gt; void CFoo() { printf(\u0026#34;Hello from C\\n\u0026#34;); } */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func main() { fmt.","title":"C/C++ \u003c-\u003e Go 콜백함수 구현하기"},{"content":"배경 최근에 간단한 쉘 스크립트 하나를 짜면서 겪은 문제가 하나 있다. ssh로 연결된 특정 보드의 이더넷 네트워크 인터페이스의 설정을 변경해주는 작업이었다. 적용할 보드가 한두개가 아니라서 해당 작업을 간편하게 하기위해서 HOST(노트북)에서 해당 작업을 수행하는 스크립트를 실행시키면 ssh를 통해 보드내 설정을 바꿔주도록 했다. 딱히 어려울것 없는 작업이라 sshpass, scp, ssh, sed 명령어 조합을 사용하였다.\n로컬 터미널에서 위의 명령어들을 쓰면서 잘 바뀌는것을 확인했고 그 로직을 그대로 쉘 스크립트를 작성하였다\u0026hellip; 하지만 문제는 로컬 터미널에서만 테스트 한 점이었다.\n# copy scp -o StrictHostKeyChecking=no config.yaml user@1.1.1.1:~ # change ssh -o StrictHostKeyChecking=no user@1.1.1.1 \\  \u0026#34;`export mac_addr=`cat /sys/class/net/eth0/address`` \u0026amp;\u0026amp; sed -i \u0026#39;s/mac_addr/\u0026#39;\u0026#34;${mac_addr}\u0026#34;\u0026#39;/g\u0026#39; ~/config.yaml\u0026#34; 내용은 대략 이러했다.\n 템플릿 config 파일을 보드로 복사 해당 보드의 Mac address를 환경변수로 저장 sed 명령어로 템플릿 config 파일의 특정 문자열을 치환  하지만 저 상태로 스크립트를 실행하면 ${mac_addr} 부분이 스크립트를 실행한 로컬 터미널의 환경변수를 참조하게 되므로 공백값이 들어가게된다. quote 문자를 제대로 쓰지못해서 일어난것임을 깨닫고 bash에서의 double, single quote의 차이점을 알아봤다.\n(`,\u0026quot;,\u0026lsquo;의 쓰임새를 제대로 알지 못하고 중구난방으로 쓴것을 볼 수 있다..)\nbash에서의 \u0026ldquo;, ' 기능 그렇다면 Bash에서 double quote(\u0026quot;)와 single quote(')의 차이점은 무엇일까??\n아주 간단한 예시가 있다.\n$ echo \u0026#34;$(echo \u0026#34;hi\u0026#34;)\u0026#34; -\u0026gt; hi $ echo \u0026#39;$(echo \u0026#34;hi\u0026#34;)\u0026#39; -\u0026gt; $(echo \u0026#34;hi\u0026#34;) 보이는것처럼 double quote로 감싸진 문장은 $(echo \u0026quot;hi\u0026quot;)가 명령어로 확장된다. 하지만 single quote로 감싸진 문장은 명령어로 확장되지않고, 문자열(literal value) 그 자체를 보존한다.\n정확히는 double quote(\u0026quot;)는 명령어의 결과를 변수로 저장할 때 보통 많이 쓰는 $,`, \\ 문자를 제외한 모든 문자를 보존한다.\n수정 따라서 위의 스크립트가 본래 목적을 수행하도록 특정 부분을 수정했다.\n $(cat /sys/class/...) 부분이 명령어로 치환되지않고 문자열 그대로 전달되도록 sed -i 's/.../${MAC_ADDR}/g' 부분의 환경변수가 치환되지않고 그대로 전달되도록  결론 방법은 여러가지가 있다. 수행할 명령어들을 모두 로컬변수로 담아서 문자열 그대로 전달할수도 있고, '로 시작해서 \u0026amp;\u0026amp;를 이용해 여러 명령어를 붙여 한 명령어의 문자열로 모두 담아서 보내버릴수도 있다. 하지만 괜히 이상하게 오기가 생겨서 원래 하려던 방법으로 나름의 챌린징(삽질)을 했다..\n","permalink":"https://ralpioxxcs.github.io/post/etc/double_vs_single_quote/","summary":"배경 최근에 간단한 쉘 스크립트 하나를 짜면서 겪은 문제가 하나 있다. ssh로 연결된 특정 보드의 이더넷 네트워크 인터페이스의 설정을 변경해주는 작업이었다. 적용할 보드가 한두개가 아니라서 해당 작업을 간편하게 하기위해서 HOST(노트북)에서 해당 작업을 수행하는 스크립트를 실행시키면 ssh를 통해 보드내 설정을 바꿔주도록 했다. 딱히 어려울것 없는 작업이라 sshpass, scp, ssh, sed 명령어 조합을 사용하였다.\n로컬 터미널에서 위의 명령어들을 쓰면서 잘 바뀌는것을 확인했고 그 로직을 그대로 쉘 스크립트를 작성하였다\u0026hellip; 하지만 문제는 로컬 터미널에서만 테스트 한 점이었다.","title":"쉘 스크립트 삽질"},{"content":"push_back 과 emplace_back 둘 다 실질적으로 수행하는 일은 \u0026ldquo;컨테이너의 끝에 요소를 추가하는것\u0026rdquo; 로 동일하다. 하지만 두 함수를 memory allocation 관점에서 보면 emplace_back 이 훨씬 효율적으로 작동한다.\npush_back 이 호출될 때 객체 관점에서 순서는 다음과 같다.\n Stack 영역에 생성자를 호출 하면서 임시객체(temporary object)가 할당 된다. 복사 생성자(copy constructor) 혹은 이동 생성자 통해 함수 안에서 또 하나의 temporay object를 생성한다. 생성된 temporary object를 벡터 컨테이너의 끝에 추가한다. 1번의 임시객체가 소멸된다.  이렇게, push_back 함수는 \u0026ldquo;객체\u0026rdquo; 자체를 집어넣는 방식으로, R-value의 임시객체가 필요하다. 단순히 하나의 객체를 추가하는 단순한 연산임에도 불구하고, 객체의 생성과 파괴가 한번 이루어진다.\n그에 반해서, emplace_back 는 direct하게 함수 내에서 임시객체를 생성과 이동을 통해 element를 생성한다. 다시말해, 불필요한 임시객체의 생성과 파괴 과정없이 효율적으로 벡터 element를 추가한다.\nExample #include \u0026lt;chrono\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt; class Foo { public: Foo() = default; Foo(const std::string name, const int age) : m_name(name), m_age(age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo()\u0026#34; \u0026lt;\u0026lt; std::endl; } // declare copy constructor explicitly  Foo(const Foo\u0026amp; rhs) : m_name(rhs.m_name), m_age(rhs.m_age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo() copy\u0026#34; \u0026lt;\u0026lt; std::endl; } // declare move constructor explicitly  Foo(const Foo\u0026amp;\u0026amp; rhs) : m_name(rhs.m_name), m_age(rhs.m_age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo() move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Foo() { std::cout \u0026lt;\u0026lt; \u0026#34;~Foo()\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string m_name; int m_age; }; int main(int argc, char* argv[]) { std::vector\u0026lt;Foo\u0026gt; foovec; foovec.reserve(2); std::cout \u0026lt;\u0026lt; \u0026#34;emplace back\u0026#34; \u0026lt;\u0026lt; std::endl; foovec.emplace_back(\u0026#34;tom\u0026#34;, 63); std::cout \u0026lt;\u0026lt; \u0026#34;------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;push back\u0026#34; \u0026lt;\u0026lt; std::endl; foovec.push_back(Foo(\u0026#34;chris\u0026#34;, 44)); std::cout \u0026lt;\u0026lt; \u0026#34;------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } Result   예상했던것처럼, push_back 함수는 객체의 생성, 이동, 소멸이 되었지만, emplace_back 의 경우 객체가 생성만 된것을 확인할 수 있다.\nBenchmark #include \u0026lt;iostream\u0026gt;#include \u0026lt;chrono\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt; int main(int argc, char* argv[]) { std::vector\u0026lt;Foo\u0026gt; foovec; std::size_t count = std::atoi(argv[2]); foovec.reserve(count); if (argv[1] == std::string(\u0026#34;push_back\u0026#34;)) { auto t1 = std::chrono::high_resolution_clock::now(); for (std::size_t idx = 0; idx \u0026lt; count; idx++) { foovec.push_back(Foo(\u0026#34;blank\u0026#34;, 1)); } auto t2 = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; fp_ms = t2 - t1; std::cout \u0026lt;\u0026lt; \u0026#34;duration : \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; std::endl; } else if (argv[1] == std::string(\u0026#34;emplace_back\u0026#34;)) { auto t1 = std::chrono::high_resolution_clock::now(); for (std::size_t idx = 0; idx \u0026lt; count; idx++) { foovec.emplace_back(\u0026#34;blank\u0026#34;, 1); } auto t2 = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; fp_ms = t2 - t1; std::cout \u0026lt;\u0026lt; \u0026#34;duration : \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; std::endl; } return 0; }   1000만개의 elements를 추가하는 간단한 벤치마킹 코드를 돌려봤을때, emplace_back이 push_back보다 약 7ms정도 미세하게 빠르다는것을 확인할 수 있었다.\n   push_back 을 언제 사용해야하는가 그렇다면, 모든 push_back 을 emplace_back으로 바꾸면 되는것일까? 라고 생각이 들 수 있다. 하지만 아래의 또 다른 예제를 보면 그렇지 않다는것을 알 수 있다.\nv.push_back(10000); v.emplace_back(10000); 위의 코드만 봤을때, push_back의 경우 명확하다. 숫자 10000을 vector에 추가한다는것을 나타내지만, emplace_back의 경우 확실히 알 수 없다.\n만약 vector가 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; 의 형태인 경우, 10000개의 요소를 메모리에 할당하게 된다. push_back을 사용했을 경우 compile error를 통해 compile 시점에 개발자가 인지하고 고칠 수 있지만, emplace_back의 경우 개발자가 의도하지 않은 결과를 초래하게 될 수도 있다.\n 결론 위의 벤치마크 코드에서도 확인하였듯이 추가해야 할 element 객체의 크기가 엄청 큰 경우 혹은 performance critical한 경우가 아니라면, 명시적인 타입의 push_back을 사용하여 explicit하고, safety한 코드를 작성하는것도 하나의 방법이라고 생각한다.\n   Reference  https://abseil.io/tips/112 https://en.cppreference.com/w/cpp/container/vector  ","permalink":"https://ralpioxxcs.github.io/post/cpp/stdvector/","summary":"push_back 과 emplace_back 둘 다 실질적으로 수행하는 일은 \u0026ldquo;컨테이너의 끝에 요소를 추가하는것\u0026rdquo; 로 동일하다. 하지만 두 함수를 memory allocation 관점에서 보면 emplace_back 이 훨씬 효율적으로 작동한다.\npush_back 이 호출될 때 객체 관점에서 순서는 다음과 같다.\n Stack 영역에 생성자를 호출 하면서 임시객체(temporary object)가 할당 된다. 복사 생성자(copy constructor) 혹은 이동 생성자 통해 함수 안에서 또 하나의 temporay object를 생성한다. 생성된 temporary object를 벡터 컨테이너의 끝에 추가한다. 1번의 임시객체가 소멸된다.  이렇게, push_back 함수는 \u0026ldquo;객체\u0026rdquo; 자체를 집어넣는 방식으로, R-value의 임시객체가 필요하다.","title":"push_back vs. emplace_back"},{"content":"이번에는 neovim에서 coc.nvim를 이용하여 C/C++ 개발환경을 세팅하는 방법에 대해서 알아보겠다.\ncoc.nvim은 Language Server Protocol인 LSP를 지원하는 코드 auto-completion 패키지인데 이전에는 ycm을 사용하다가 너무 무겁기도 하고 개인적으로 환경설정 부분에 불편함 점이 있어 coc.nvim을 사용하게 되었다.\ncoc.nvim 설치 vim-plug 설정부분에 아래를 추가해준뒤, :PlugInstall을 해준다.\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;tag\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;do\u0026#39;: \u0026#39;./install.sh\u0026#39;} 참고로, node.js 10.12 버전 이상이 설치되어있어야 한다. node.js가 설치되어있지 않다면 여기를 참고하여 다운로드 및 설치를 진행해주자.\n cpp language server 설치 이곳을 보면 C/C++ language server에 맞는 configuration example을 제공한다.\nclangd, coc-clangd, ccls, cquery등이 여러 language server 패키지가 있지만, 이 포스팅에서는 ccls를 설정하는 방법을 다룰것이다.\nccls를 사용하려면 직접 빌드를 해주어야하는데, ccls는 다음의 패키지를 필요로 한다.\n CMake 3.8 버전 이상 C++17을 지원하는 컴파일러  clang \u0026gt;=5 gcc \u0026gt;=7.2 clang+llvm \u0026gt;=7 의 include와 lib    clagn+llvm 의 include와 lib를 저장하고있는 폴더가 없거나 경로지정이 애매하다면, 여기에서 pre-built binaries를 다운로드 한뒤, 특정 폴더에다 해제를 한다.\n위의 조건을 모두 만족한다면 빌드 준비가 모두 완료된것이므로, ccls repository를 clone후 아래 명령어를 따라 빌드한다.\ngit clone --depth=1 --recursive https://github.com/MaskRay/ccls cd ccls cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-xxx # clang pre-built binaries 폴더 cmake --build Release wget 커맨드를 이용하는 방법도 있다.\nwget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release 빌드가 끝났다면, 아래 명령어로 설치를 완료한다.\n만약 설치경로를 변경하고 싶다면 CMakeCache.txt파일을 수정하여 CMAKE_INSTALL_PREFIX에 원하는 경로를 입력한다.\ncmake --build Release --target install  coc config 빌드 및 설치가 완료되었다면, coc.nvim에서 ccls를 사용할 수 있도록 config파일을 수정할 차례이다.\nconfig파일을 수정하는 방법은 두가지 방법이 있다.\n $HOME/.config/nvim 경로에 coc-setting.json을 파일을 만들어 작성 vim을 실행한뒤 :CoCConfig명령어를 입력  두 방법 모두 결국엔 같은 파일을 수정하는것이긴 하다.\nExample { \u0026#34;languageserver\u0026#34;: { \u0026#34;ccls\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;ccls\u0026#34;, \u0026#34;filetypes\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;cpp\u0026#34;], \u0026#34;rootPatterns\u0026#34;: [\u0026#34;.ccls\u0026#34;, \u0026#34;compile_commands.json\u0026#34;], \u0026#34;initializationOptions\u0026#34;: { \u0026#34;cache\u0026#34;: { \u0026#34;directory\u0026#34;: \u0026#34;.ccls-cache\u0026#34; }, \u0026#34;client\u0026#34;: { \u0026#34;snippetSupport\u0026#34; : true }, \u0026#34;compilationDatabaseDirectory\u0026#34;: \u0026#34;./build/\u0026#34; } } } } ccls는 rootPatterns에 명시된 파일의 패턴을 기준으로 project전체를 indexing하여 정보를 제공한다. 이 패턴 파일을 생성하는 방법은 2가지가 있다.\n compile_commands.json 파일을 사용하는 방법 .ccls파일을 직접 만들어 사용하는 방법  보통 CMake같은 build system generator를 통해 compile_commands.json파일을 자동적으로 생성할 수 있으므로, 1번 방법을 사용하는편이 간단하다.\n아래와 같이 cmake configuration arguments로 파일을 만들고, project root폴더에서 해당 파일을 심볼릭링크를 해준다.\nmkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .. cd .. ln -s build/compile_commands.json . 추가로 compilationDatabaseDirectory 옵션을 통해 compile_commands.json 파일의 경로를 설정해주면 심볼릭 링킹을 일일이 해주지 않아도 된다.\nReference  https://github.com/MaskRay/ccls/wiki/coc.nvim  ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_3/","summary":"이번에는 neovim에서 coc.nvim를 이용하여 C/C++ 개발환경을 세팅하는 방법에 대해서 알아보겠다.\ncoc.nvim은 Language Server Protocol인 LSP를 지원하는 코드 auto-completion 패키지인데 이전에는 ycm을 사용하다가 너무 무겁기도 하고 개인적으로 환경설정 부분에 불편함 점이 있어 coc.nvim을 사용하게 되었다.\ncoc.nvim 설치 vim-plug 설정부분에 아래를 추가해준뒤, :PlugInstall을 해준다.\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;tag\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;do\u0026#39;: \u0026#39;./install.sh\u0026#39;} 참고로, node.js 10.12 버전 이상이 설치되어있어야 한다. node.js가 설치되어있지 않다면 여기를 참고하여 다운로드 및 설치를 진행해주자.\n cpp language server 설치 이곳을 보면 C/C++ language server에 맞는 configuration example을 제공한다.","title":"Vim 사용하기 #3 - C/C++ 개발환경 세팅"},{"content":"보통 로그파일 실시간으로 보고싶을때 tail 명령어를 사용한다. 하지만 여러 로그를 보고싶을때는 tmux등 화면 분할을 해서 봐야하는데 이 방법은 귀찮다. 이럴때 multitail을 사용하면 간단하게 여러 로그를 모니터링할수 있다.\n설치 apt install multitail을 입력하여 간단하게 설치한다. 맥 유저라면 brew install multitai을 쓴다.\n사용법   1개의 파일 모니터링\nmultitail [filename]\n  2개의 파일 모니터링 (가로로 분할)\nmultitail [filename] [filename]     2개의 파일 모니터링 (세로로 분할)\nmultitail -s 2 [filename] [filename]     colorscheme 설정 multitail은 자체 config파일을 통해 로그파일 highlighting을 지원한다.\n/usr/local/etc/ 경로에 기본 파일이 있고, 기본적으로 syslog, apache등의 여러가지 colorscheme들이 있다.\n기본 명령어에 -cS 옵션을 추가하여 사용하면 된다.\nmultitail -cS [colorscheme] [logfile] 공식문서에 따르면 /etc/multitail.conf에 파일이 있다면 적용이 된다고 하는데, 계속 -cS 옵션을 줘도 colorscheme을 찾을수 없다고 하면서 오류가 났다\n구글링을 해보니까 .multitailrc 라는 파일을 홈 경로에 만들어주면 된다고 해서 해봤더니 바로 적용이 되었다. 대신 multitail.conf을 참고하여 사용할 colorscheme만 복사해서 사용해야 한다.\n mutitailrc 예시  colorscheme:syslog:kernel and unsorted messages # segfaults cs_re_s:red,,bold:kernel: ([^:]*): segfault at [^ ]* rip [^ ]* rsp [^ ]* error cs_re:yellow:kernel: .*: segfault at [^ ]* rip [^ ]* rsp [^ ]* error # misc cs_re:red,,inverse/underline:kernel cs_re:green:Detected.*$ cs_re:green:\\[ cs_re:green:\\] cs_re:cyan:: cs_re:blue|blue,,bold:^... .. ..:..:.. cs_re_s:,,bold:^... .. ..:..:.. [^ ]* ([A-z0-9]*) cs_re:red:scanlogd.* cs_re:yellow:Did.not 또한 정규표현식을 지원하므로 자신만의 custom colorscheme을 만들수도 있다.\n예를들어 info, debug, warning등 로그에 사용되는 특정필터들에 색깔을 입혀보고 싶다면, 다음과 같이 설명하면 된다.\n# test colorscheme:test # date cs_re:magenta,,bold: *[a-z]*[0-9]+[a-z]* # filter cs_re:cyan,,bold:\u0026lt;trace\u0026gt; cs_re:green,,bold:\u0026lt;info\u0026gt; cs_re:magenta,,bold:\u0026lt;debug\u0026gt; cs_re:yellow,,bold:\u0026lt;warning\u0026gt; cs_re:red:\\[ cs_re:red:\\] multitial -cS test file.log -l \u0026quot;ping 8.8.8.8\u0026quot;를 입력한 결과   ","permalink":"https://ralpioxxcs.github.io/post/etc/log_monitoring/","summary":"보통 로그파일 실시간으로 보고싶을때 tail 명령어를 사용한다. 하지만 여러 로그를 보고싶을때는 tmux등 화면 분할을 해서 봐야하는데 이 방법은 귀찮다. 이럴때 multitail을 사용하면 간단하게 여러 로그를 모니터링할수 있다.\n설치 apt install multitail을 입력하여 간단하게 설치한다. 맥 유저라면 brew install multitai을 쓴다.\n사용법   1개의 파일 모니터링\nmultitail [filename]\n  2개의 파일 모니터링 (가로로 분할)\nmultitail [filename] [filename]     2개의 파일 모니터링 (세로로 분할)\nmultitail -s 2 [filename] [filename]     colorscheme 설정 multitail은 자체 config파일을 통해 로그파일 highlighting을 지원한다.","title":"multitail을 이용한 로그 모니터링"},{"content":"  입력 : 세로 크기 N, 가로 크기 M ( 2 \u0026lt;= M,N \u0026lt;= 1,000 )\n 1 = 익은 토마토 0 = 익지 않은 토마토 -1 = 토마토가 들어있지 않은 칸    출력 : 토마토가 모두 익을 때까지의 최소 날짜 출력\n 저장될 때부터 모든 토마토가 익었다면 0 모두 익지 못하는 상황이면 -1     문제 해결   입력을 받으면서 익은토마토의 위치를 큐에 PUSH하고 (BFS를사용), 안 익은 토마토의 갯수를 저장한다.\n 안익은 토마토가 없다면 모두 익은것이므로 0을 출력하고 끝낸다. 아니라면 큐를 이용하여 BFS를 시작한다.    day를 기록하기위해 큐에 들어간 사이즈만큼 탐색을 해야한다.\n  BFS의 조건 ( 토마토가 들어있지않은곳, 맵 밖 벗어난곳 ) 을 생각하여 큐에 넣는다.\n  큐 사이즈만큼 POP이 끝났으면 하루가 지난것이므로 day를 증가\n  큐가 비어있을때까지 반복한다.\n   Code #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; typedef struct coordinate { int x; int y; }; int dx[4] = { 0,0,1,-1 }; int dy[4] = { 1,-1,0,0 }; int m, n; // 가로m 세로n int map[1000][1000]; int visit[1000][1000]; int tomato_count; queue\u0026lt;coordinate\u0026gt; qu; int day = -1; void input() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt;n; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) { cin \u0026gt;\u0026gt; map[i][j]; if (map[i][j] == 1) qu.push({ i,j }); // 익은 토마토의 자리는 큐에 넣어준다.  else if (map[i][j] == 0) tomato_count++; // 안익은 토마토의 갯수를 카운트한다.  } } void bfs() { // tomato_count 가 모두 소진됐다면 토마토가 모두 익은것  // tomato_count 가 남아있다면 ( 0 이상 ) 토마토가 익지 못하는 상황 -\u0026gt; -1 출력  while (!qu.empty()) // 큐가 공백이 될때까지 반복한다  { int queue_size = qu.size(); // 큐 사이즈 변수.. 큐 사이즈만큼 pop을 돌리고 day를 카운트  for (int i = 0; i \u0026lt; queue_size; i++) { coordinate temp = qu.front(); // 큐의 최하단 원소 빼내어 변수에 저장  qu.pop(); // 이미 bfs를 통해 방문했던 곳이라면 패스, 아니면 visit 배열에 체크  if (visit[temp.x][temp.y]) continue; else visit[temp.x][temp.y] = 1; // 맵 경계선, 토마토가 들어있지않은곳 검사하여 사방좌표를 큐에 넣어준다.  for (int j = 0; j \u0026lt; 4; j++) { int x = temp.x + dx[j]; int y = temp.y + dy[j]; if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m) continue; else if (map[x][y] == -1) continue; else if (map[x][y] == 0) { qu.push({ x,y }); map[x][y] = 1; tomato_count--; } } } // 큐 사이즈만큼 돌렸으면 day 하나 증가시킨다.  day++; } // 안익은 토마토가 남아있다면,,  if (tomato_count \u0026gt; 0) day = -1; } int main() { input(); // 안익은 토마토가 없다면 모두 익은것이므로 0 출력  if (tomato_count == 0) day = 0; else bfs(); cout \u0026lt;\u0026lt; day; return 0; } ","permalink":"https://ralpioxxcs.github.io/ps/bj_7576/","summary":"입력 : 세로 크기 N, 가로 크기 M ( 2 \u0026lt;= M,N \u0026lt;= 1,000 )\n 1 = 익은 토마토 0 = 익지 않은 토마토 -1 = 토마토가 들어있지 않은 칸    출력 : 토마토가 모두 익을 때까지의 최소 날짜 출력\n 저장될 때부터 모든 토마토가 익었다면 0 모두 익지 못하는 상황이면 -1     문제 해결   입력을 받으면서 익은토마토의 위치를 큐에 PUSH하고 (BFS를사용), 안 익은 토마토의 갯수를 저장한다.","title":"백준 7576 토마토"},{"content":"Graph   그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.\n(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)\nImplementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다. ( 0번방 -\u0026gt; A , 1번방 -\u0026gt; B\u0026hellip; 이런 식) 구조체에는 인접행렬을 표기할 배열 graph 2차원 배열, 정점의 갯수와 간선의 갯수를 저장해줄 int형 변수들을 선언해준다.\nInit graph void initGraph(GraphMatrix *gm, char *fileName) { FILE *pFile = fopen(fileName, \u0026#34;r\u0026#34;); char str[3]; if (pFile == NULL) printf(\u0026#34;불러오기 실패\\n\u0026#34;); else { fscanf(pFile, \u0026#34;%d\u0026#34;, \u0026amp;gm-\u0026gt;vertexcnt); // 정점갯수 가져옴  fscanf(pFile, \u0026#34;%d\u0026#34;, \u0026amp;gm-\u0026gt;edgeCnt); // 간선갯수 가져옴  for (int i = 0; i \u0026lt; gm-\u0026gt;vertexcnt; i++) // 배열 방 \u0026#39;0\u0026#39; 으로 초기화  for (int j = 0; j \u0026lt; gm-\u0026gt;vertexcnt; j++) gm-\u0026gt;graph[i][j] = 0; for (int k = 0; k \u0026lt; gm-\u0026gt;edgeCnt; k++) { fscanf(pFile, \u0026#34;%s\u0026#34;, str); str[0] = str[0] - 65; str[1] = str[1] - 65; // ex) str[3] = { 0 , 1 }  gm-\u0026gt;graph[str[0]][str[1]] = 1; gm-\u0026gt;graph[str[1]][str[0]] = 1; } } } 이 글에서는 행렬 텍스트 파일을 파일입출력을 통해 불러와 반복문을 통해 배열에 입력하는 방식으로 구현했다. FILE 함수를 통해 파일을 읽어들인 후, 간선, 정점의 갯수를 모두 읽는다.\n우선, 인접행렬영역을 0 (방문X)로 초기화를 해주고, 무방향 그래프에서의 대칭성을 고려하여 간선의 갯수만큼 반복문을 이용해 행렬에 입력한다.\nPrint graph void outputGraph(GraphMatrix *gm) { printf(\u0026#34; \u0026#34;); for (int k = 0; k \u0026lt; gm-\u0026gt;vertexcnt; k++) printf(\u0026#34; [%c]\u0026#34;, 65 + k); NEWL; for (int i = 0; i \u0026lt; gm-\u0026gt;vertexcnt; i++) { printf(\u0026#34;[%c]\u0026#34;, 65 + i); for (int j = 0; j \u0026lt; gm-\u0026gt;vertexcnt; j++) printf(\u0026#34;%5d\u0026#34;, gm-\u0026gt;graph[i][j]); NEWL; } }    DFS   그래프내의 각 정점들을 간선을 타고 중복없이 한 번씩 방문하는 방법으로 깊이 우선 탐색 ( Depth First Search ) 법과 너비 우선 탐색 ( Breadth First Search)법이 있다. 무방향 그래프는 특성상 방향이 없기때문에 순회 순서가 유일하지 않다는 특징이 있다. 2가지 중 하나인 \u0026ldquo;깊이 우선 탐색(DFS)\u0026rdquo; 는 탐색을 시작할 정점에 연결된 정점 중 하나를 선택하여 들어가고 그 하나와 연결된 정점들 중 또 하나를 선택해서 들어가고 깊이 들어가는 방식으로 탐색하는 기법이다. DFS의 과정은 스택을 사용하므로 재귀와 비재귀로 구현 할 수 있다\nRecursive dfs void DFS_recursive(GraphMatrix *gm, int vNum) { int i; check[vNum] = 1; /* 방문한 정점 표시를 위해 1 저장 */ visit(vNum); /* 방문에 따른 처리 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { if(gm-\u0026gt;graph[vNum][i] != 0) /* 연결된 정점이 있으면 */ if(check[i] == 0) /* 또한 방문한 적이 없는 정점이면 */ DFS_recursive(gm, i); /* 재귀 호출을 통해 정점 방문을 한다 */ } } 전달인자로 받은 정점번호를 방문처리 해준 뒤, ( 1로 바꿈 ) 그 정점을 visit함수 ( 출력 ) 한다. 다음으로, 정점갯수만큼 반복문을 설정.. 해당 정점에 연결된 정점이 있고 그 정점이 방문배열에서 방문한 적이 없는 정점 이라면 재귀호출을 통해 정점 방문 처리를 해준다.\nNon-Recursive dfs void nrDFS_Matrix(GraphMatrix *gm) { int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026amp;stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { push(\u0026amp;stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026amp;stack) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { pop(\u0026amp;stack, \u0026amp;popData); visit(popData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) if(gm-\u0026gt;graph[popData][j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { push(\u0026amp;stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyStack(\u0026amp;stack); return; } 재귀기법을 사용하지 않으면 스택자료구조를 이용해야한다. 스택 초기화 및 생성을 하고 재귀방법과 똑같이 체크배열은 0으로 시켜준다. 순차적으로 정점을 방문한다. 그 정점이 방문한경우가 아니라면 스택에 그 정점을 푸쉬하고 방문상태를 바꿔준다 ( 1로 ) 그리고 스택이 모두 비면 한 연결 요소에 대해 순회가 끝난것을 의미하므로 스택이 빌 때까지 반복문을 걸어준다. pop을 하여 정점을 꺼내고 해당 정점에 연결된 정점이 있고 방문처리 되지 않은 경우 그 인접정점을 스택에 넣고 방문처리를 해준다. 이런 과정을 모두 하고나면 모든 정점에 대해 순회가 완료된다.\nBFS   너비우선탐색 (BFS) 는 시작한 정점과 연결된 모든 정점을 탐색하고 다시 시작 정점의 다른 연결된 정점을 찾는 순으로, 깊이 들어가기전에 옆으로 넓게 퍼지며 탐색하는 기법이다. DFS와 달리 너비우선탐색 (BFS) 는 스택을 사용하지않고 큐 자료구조를 이용해야 한다. 따라서 재귀호출기법으로는 구현할 수 없다.\nvoid BFS_Matrix(GraphMatrix *gm) { int i, j; int getData; /* dequeue(get)한 데이터 저장 */ Queue queue; initQueue(\u0026amp;queue, MAX_VERTEX); /* 큐 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { enqueue(\u0026amp;queue, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isQueueEmpty(\u0026amp;queue) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { dequeue(\u0026amp;queue, \u0026amp;getData); visit(getData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) if(gm-\u0026gt;graph[getData]j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { enqueue(\u0026amp;queue, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyQueue(\u0026amp;queue); return; } 과정은 DFS랑 매우 비슷하다. 자료구조만 스택에서 큐로 바꾸면 바로 너비우선탐색법이 된다.\n큐를 선언 및 초기화 후 체크배열을 초기화한다. 그리고 시작 정점을 기준으로 하여 큐에 넣고 큐가 빌때까지 반복문, 인접정점, 방문 유무를 판단한다. [그림 3] 을 예로들어서 설명하면 \u0026ldquo;1\u0026quot;을 시작으로 Enqueue한뒤, \u0026ldquo;1\u0026quot;의 인접정점 8 , 5, 2 를 순서대로 모두 Enqueue한다. 그리고 Dequeue를 하면 큐 특성상 첫번째로 넣은 값이 나오게 되므로 8을 방문처리하고 8의 인접정점 6 ,4 ,3 을 모두 Enqueue 그 다음 5를 Dequeue\u0026hellip; 5는 인접정점이 없으므로 다음 Dequeue 2를 방문\u0026hellip;이런 식으로 옆으로 넓게 퍼지며 탐색을 한다.\nprint graph int countGraphComponents(GraphMatrix *gm) { int componetsCount=0; /* 그래프 내의 연결 요소 카운트 변수 */ int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026amp;stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { ++componetsCount; /* 방문하지 않은 정점을 발견되면 연결 요소 카운트를 증가 시킴 */ printf(\u0026#34;\\n연결 요소 %d : \u0026#34;, componetsCount); push(\u0026amp;stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026amp;stack) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { pop(\u0026amp;stack, \u0026amp;popData); visit(popData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) if(gm-\u0026gt;graph[popData][j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { push(\u0026amp;stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyStack(\u0026amp;stack); return componetsCount; } print graph ","permalink":"https://ralpioxxcs.github.io/cs/graph_matrix/","summary":"Graph   그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.\n(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)\nImplementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다.","title":"Graph (matrix)"},{"content":"SSH  시큐어 셸(Secure SHell, SSH)은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 기존의 rsh, rlogin, 텔넷 등을 대체하기 위해 설계되었으며, 강력한 인증 방법 및 안전하지 못한 네트워크에서 안전하게 통신을 할 수 있는 기능을 제공한다. -Wiki\n 리눅스 개발환경을 구성하다보면 거의 필수적으로 사용하게 되는 ssh(secure shell) 을 구성하는 방법을 알아보자.\n  SSH 서버 설치 ubuntu 및 osx 에는 기본적으로 ssh client는 설치돼있다. 아래 명령어를 이용해 ssh server를 설치한다.\nsudo apt install openssh-server sudo /etc/ini.d/sshd start # ssh service 시작 SSH 서버 구성 ssh server는 /etc/ssh/sshd_config 경로의 파일을 수정해 서버 설정을 할수있다.\n ssh client 는~/.ssh/config  포트 변경 #Port 22 Port 8282 기본 ssh port(22) 말고 다른 포트를 사용하고 싶을때 수정한다.\n포트번호 수정후엔 ufw allow [Port] 해주는것을 잊지말자\n인증방식 원격지에서 ssh 서버로 접근할 때의 인증방식은 기본적으로 패스워드 인증방식을 사용한다.\n#PubkeyAuthentication yes # 공개키 인증방식 사용 PasswordAuthentication yes # id, passwd 인증방식 사용 (default)  HostbasedAuthentication no # 호스트 기반 인증 방식 사용 여부 기타 설정 X11Forwarding no # 원격지에서 X11 포워딩 허용 여부 ListenAddress 0.0.0.0 # server에서 listen할 특정 주소 설정   공개키 인증방식을 사용해 SSH 서버 접속하기 공개키 인증방식을 사용하여 비밀번호 입력없이 ssh 세션으로 로그을 해보자\n Client : Windows Server : Ubuntu  ","permalink":"https://ralpioxxcs.github.io/post/etc/sshd_config/","summary":"SSH  시큐어 셸(Secure SHell, SSH)은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 기존의 rsh, rlogin, 텔넷 등을 대체하기 위해 설계되었으며, 강력한 인증 방법 및 안전하지 못한 네트워크에서 안전하게 통신을 할 수 있는 기능을 제공한다. -Wiki\n 리눅스 개발환경을 구성하다보면 거의 필수적으로 사용하게 되는 ssh(secure shell) 을 구성하는 방법을 알아보자.\n  SSH 서버 설치 ubuntu 및 osx 에는 기본적으로 ssh client는 설치돼있다.","title":"SSH 서버 설정"},{"content":"Vim Plugins vim을 쓰는 가장 큰 이유중 하나는 바로 이 Plugin에 있지않나 싶다. 설치도 비교적 간편하며, 확장성이 뛰어나서 플러그인을 사용하면서 불편한 부분들을 설정파일을 통해 입맛에 맞게 바꿀 수 있다는 점이 매력적이다.\n지금도 유용하게 사용하는 vim 플러그인들에 대한 소개와 설치방법 및 사용법에 대해 간단히 알아보겠다.\n 플러그인 매니저 설치 vim에서 Plugin들을 설치, 관리해주는 도구들이 여러개 있는데 (Vundle, Pathogen) 그 중에서 나는 junegunn님이 만드신 vim-plug를 사용중이다.\n현재 neovim을 사용중이므로 설치 방법은 아래와 같다.\nsh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; 그 외의 설치방법은 여기를 참고하면 된다.\nNerdTree nerdtree는 vim에서 파일트리를 보여주는 도구로, 여러 파일을 왔다갔다 할때 유용하게 사용된다.\n  선택된 파일에서 단축키 m을 입력하면 위 사진처럼 현재 경로의 파일들을 트리형식으로 나타내준다.\n   a : 파일 및 디렉터리를 추가생성한다. m : mv와 같은명령으로 파일 및 디렉터리를 옮긴다. r : 탐색기로 선택된 파일을 연다 ( nautilus, finder ..) o : 메모장이나 gedit 같은 시스템 편집기로 선택된 파일 연다.  vim 설정은 아래와 같이 설정해두었다.\n\u0026#34; vim을 열때마다 자동으로 nerdtree를 실행한다. \u0026#34; https://github.com/preservim/nerdtree#how-can-i-open-nerdtree-automatically-when-vim-starts-up-on-opening-a-directory autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 1 \u0026amp;\u0026amp; isdirectory(argv()[0]) \u0026amp;\u0026amp; !exists(\u0026#34;s:std_in\u0026#34;) | exe \u0026#39;NERDTree\u0026#39; argv()[0] | wincmd p | ene | exe \u0026#39;cd \u0026#39;.argv()[0] | endif \u0026#34; \u0026lt;F9\u0026gt; NerdTree 열고 닫기 매크로 설정 noremap \u0026lt;F9\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; Tagbar Tagbar는 현재 파일의 Class ,Structure 정보 및 ctags가 생성한 tags를 트리 형식으로 보여주는 플러그인이다. 이 플러그인을 사용하려면 우선적으로 ctags가 설치돼있어야 한다.\n\u0026#34;Ubuntu\u0026#34; sudo apt-get install exuberant-ctags \u0026#34;OS X\u0026#34; brew install ctags 아래의 vim 설정을 통해 F8을 Tagbar단축키로 설정해두었다.\n\u0026#34; ctags 경로 설정 let g:tagbar_ctags_bin=\u0026#39;/usr/local/bin/ctags\u0026#39; let g:tagbar_autoclose=0 let g:tabar_autofocus=1 \u0026#34; \u0026lt;F8\u0026gt; Tagbar 열고 닫기 매크로 설정 noremap \u0026lt;F8\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt; FZF 강력한 터미널 파일탐색 도구인 fzf를 vim 플러그인으로 사용할 수 있다.\n기존에는 ctrlp를 사용하다가 fzf를 알고나서부터는 이것만 주욱 써오고 있다. 아직은 fzf를 완벽하게 사용하지는 못하고 있지만, 파일 탐색, 버퍼, 문자열 찾기 기능등으로 쓰고 있다.\nvim-plug를 이용해 설치한다.\nPlug \u0026#39;junegunn/fzf\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; fzf#install() } }Plug \u0026#39;junegunn/fzf.vim\u0026#39;  fzf-vim의 기능 중 Ag와 Rg의 기능을 사용하기 위해 다음의 프로그램중 하나를 필요로 한다.\n The Silver Searcher Ripgrep  만약 검색결과에 대해 Syntax Highlighting을 원한다면 bat을 설치해주자.\nCustomization fzf-vim은 기본적으로 편집창 아래에 검색결과를 나타내주는데, 이것또한 변경이 가능하다.\n1. fzf layout \u0026#34; fzf layout let g:fzf_layout = {\u0026#39;up\u0026#39;:\u0026#39;~90%\u0026#39;, \u0026#39;window\u0026#39;: { \u0026#39;width\u0026#39;: 0.8, \u0026#39;height\u0026#39;: 0.8,\u0026#39;yoffset\u0026#39;:0.5,\u0026#39;xoffset\u0026#39;: 0.5, \u0026#39;highlight\u0026#39;: \u0026#39;Todo\u0026#39;, \u0026#39;border\u0026#39;: \u0026#39;sharp\u0026#39; } } let $FZF_DEFAULT_OPTS = \u0026#39;--layout=reverse --inline-info\u0026#39; let $FZF_DEFAULT_COMMAND=\u0026#34;rg --files --hidden --glob \u0026#39;!.git/**\u0026#39;\u0026#34; \u0026#34; Customize fzf colors to match your color scheme \u0026#34; - fzf#wrap translates this to a set of `--color` options let g:fzf_colors = \\ { \u0026#39;fg\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;bg\u0026#39;: [\u0026#39;bg\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;hl\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Comment\u0026#39;], \\ \u0026#39;fg+\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;CursorLine\u0026#39;, \u0026#39;CursorColumn\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;bg+\u0026#39;: [\u0026#39;bg\u0026#39;, \u0026#39;CursorLine\u0026#39;, \u0026#39;CursorColumn\u0026#39;], \\ \u0026#39;hl+\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Statement\u0026#39;], \\ \u0026#39;info\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;PreProc\u0026#39;], \\ \u0026#39;border\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Ignore\u0026#39;], \\ \u0026#39;prompt\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Conditional\u0026#39;], \\ \u0026#39;pointer\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Exception\u0026#39;], \\ \u0026#39;marker\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Keyword\u0026#39;], \\ \u0026#39;spinner\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Label\u0026#39;], \\ \u0026#39;header\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Comment\u0026#39;] } 2. Files \u0026#34;Get Files command! -bang -nargs=? -complete=dir Files \\ call fzf#vim#files(\u0026lt;q-args\u0026gt;, fzf#vim#with_preview({\u0026#39;options\u0026#39;: [\u0026#39;--layout=reverse\u0026#39;, \u0026#39;--inline-info\u0026#39;]}), \u0026lt;bang\u0026gt;0) 3. Rg \u0026#34; Get text in files with Rg \u0026#34; command! -bang -nargs=* Rg \u0026#34; \\ call fzf#vim#grep( \u0026#34; \\ \u0026#34;rg --column --line-number --no-heading --color=always --smart-case --glob \u0026#39;!.git/**\u0026#39; \u0026#34;.shellescape(\u0026lt;q-args\u0026gt;), 1, \u0026#34; Make Ripgrep ONLY search file contents and not filenames command! -bang -nargs=* Rg \\ call fzf#vim#grep( \\ \u0026#39;rg --column --line-number --hidden --smart-case --no-heading --color=always \u0026#39;.shellescape(\u0026lt;q-args\u0026gt;), 1, \\ \u0026lt;bang\u0026gt;0 ? fzf#vim#with_preview({\u0026#39;options\u0026#39;: \u0026#39;--delimiter : --nth 4..\u0026#39;}, \u0026#39;up:60%\u0026#39;) \\ : fzf#vim#with_preview({\u0026#39;options\u0026#39;: \u0026#39;--delimiter : --nth 4.. -e\u0026#39;}, \u0026#39;right:50%\u0026#39;, \u0026#39;?\u0026#39;), \\ \u0026lt;bang\u0026gt;0) \u0026#34; Ripgrep advanced function! RipgrepFzf(query, fullscreen) let command_fmt = \u0026#39;rg --column --line-number --no-heading --color=always --smart-case %s || true\u0026#39; let initial_command = printf(command_fmt, shellescape(a:query)) let reload_command = printf(command_fmt, \u0026#39;{q}\u0026#39;) let spec = {\u0026#39;options\u0026#39;: [\u0026#39;--phony\u0026#39;, \u0026#39;--query\u0026#39;, a:query, \u0026#39;--bind\u0026#39;, \u0026#39;change:reload:\u0026#39;.reload_command]} call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen) endfunction command! -nargs=* -bang RG call RipgrepFzf(\u0026lt;q-args\u0026gt;, \u0026lt;bang\u0026gt;0) ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_2/","summary":"Vim Plugins vim을 쓰는 가장 큰 이유중 하나는 바로 이 Plugin에 있지않나 싶다. 설치도 비교적 간편하며, 확장성이 뛰어나서 플러그인을 사용하면서 불편한 부분들을 설정파일을 통해 입맛에 맞게 바꿀 수 있다는 점이 매력적이다.\n지금도 유용하게 사용하는 vim 플러그인들에 대한 소개와 설치방법 및 사용법에 대해 간단히 알아보겠다.\n 플러그인 매니저 설치 vim에서 Plugin들을 설치, 관리해주는 도구들이 여러개 있는데 (Vundle, Pathogen) 그 중에서 나는 junegunn님이 만드신 vim-plug를 사용중이다.\n현재 neovim을 사용중이므로 설치 방법은 아래와 같다.","title":"Vim 사용하기 #2 - Plugin"},{"content":"이 링크 로 들어가면 아래 사진과 같은 화면이 나오며 각 Release 버전에 맞는 llvm 패키지들을 다운로드 받을 수 있다.   llvm, clang, lld, lldb등 각 패키지에 대한 설명은 여기에 잘 나와있다.\n아무튼 위의 사진에 나온것처럼 설치방법으로는 크게 4가지로 나눌 수 있다.\n 소스코드 다운로드 후 직접 빌드 미리 빌드된 바이너리 설치 Automatic Installation Script apt install 커맨드 사용하여 설치  이 포스팅에서는 3번째인 Automatic installation script를 이용하여 설치하는 방법을 다루려고 한다.\nAutomatic installation script llvm에서는 llvm 저장소와 apt insatll 커맨드를 간편하게 하나의 스크립트로 설치 해주는 Automactic installation script를 제공하여 간편하게 llvm package들을 다운로드 받을 수 있다.\n대신 이 방식으로 설치를 하면 LLVM, Clang, compiler-rt, polly, LLDB, LLD, libFuzzer, libc++, libc++abi, openmp 의 모든 패키지들을모두 포함하여 설치를 하게된다. 만약 원하는것만 설치하고 싶다면 소스코드를 직접 다운로드하거나, apt 커맨드를 이용한 설치방법을 이용하여야 한다.\nLatest stable version 설치 bash -c \u0026#34;$(wget -O - https://apt.llvm.org/llvm.sh)\u0026#34; 현재 날짜(2020-07-04)기준 latest version은 10이다.\n만약 최신버전을 받고 싶다면 위의 명령어만 입력하면 llvm script가 다운로드되고 알아서 설치를 진행한다.\nThis script must be run as root 메시지가 나오면서 설치가 진행되지 않으면 sudo를 앞에 추가 후 다시 진행하면 된다.\nSpecific version 설치 wget https://apt.llvm.org/llvm.sh chmod +x llvm.sh sudo ./llvm.sh \u0026lt;version number\u0026gt; 만약 llvm9 버전을 받고 싶다면 sudo ./llvm.sh 9로만 입력해주면 된다.\n 설치 확인 설치가 완료되었다면 /usr/lib/llvm-9/ 디렉터리로 가서 잘 설치가 되었는지 확인한다.    Reference\nhttps://apt.llvm.org/  ","permalink":"https://ralpioxxcs.github.io/post/etc/llvm_install/","summary":"이 링크 로 들어가면 아래 사진과 같은 화면이 나오며 각 Release 버전에 맞는 llvm 패키지들을 다운로드 받을 수 있다.   llvm, clang, lld, lldb등 각 패키지에 대한 설명은 여기에 잘 나와있다.\n아무튼 위의 사진에 나온것처럼 설치방법으로는 크게 4가지로 나눌 수 있다.\n 소스코드 다운로드 후 직접 빌드 미리 빌드된 바이너리 설치 Automatic Installation Script apt install 커맨드 사용하여 설치  이 포스팅에서는 3번째인 Automatic installation script를 이용하여 설치하는 방법을 다루려고 한다.","title":"Ubuntu LLVM Package 설치"},{"content":"ubuntu 환경에서 c,cxx 기본 컴파일러는 /usr/bin/cc , /usr/bin/c++에 심볼릭 링크로 지정되어있는데 기본적으로는 gcc와 **g++**로 설정되어있다.\n빌드시에 컴파일러 경로를 직접 입력해주는 방법도 있지만, /usr/bin/c++의 심볼릭 링크를 변경해줌으로써 고정을 시킬수도 있다.\n이 과정전에 반드시 clang이 설치되어야 한다. clang을 설치하는 방법은 여기에 포스팅해 두었다.\n환경변수 변경 export CC=/usr/bin/clang export CXX=/usr/bin/clang++ 위의 명령어로 환경변수를 바꿔주는 방법으로 컴파일러를 바꿔줄 수 있다. 영구적으로 지정시키고 싶다면 ~/.bashrc에 추가하는 방법으로 환경변수를 설정해주하면 된다. 지정 커맨드 이용 # c++ compiler sudo update-alternatives --config c++ # c compiler sudo update-alternatives --config cc 위의 커맨드를 입력하고 아래처럼 결과 창이 나오면 원하는 번호를 입력하여 c와 c++에 지정된 컴파일러 경로를 바꿔준다.   ","permalink":"https://ralpioxxcs.github.io/post/etc/change_compiler/","summary":"ubuntu 환경에서 c,cxx 기본 컴파일러는 /usr/bin/cc , /usr/bin/c++에 심볼릭 링크로 지정되어있는데 기본적으로는 gcc와 **g++**로 설정되어있다.\n빌드시에 컴파일러 경로를 직접 입력해주는 방법도 있지만, /usr/bin/c++의 심볼릭 링크를 변경해줌으로써 고정을 시킬수도 있다.\n이 과정전에 반드시 clang이 설치되어야 한다. clang을 설치하는 방법은 여기에 포스팅해 두었다.\n환경변수 변경 export CC=/usr/bin/clang export CXX=/usr/bin/clang++ 위의 명령어로 환경변수를 바꿔주는 방법으로 컴파일러를 바꿔줄 수 있다. 영구적으로 지정시키고 싶다면 ~/.bashrc에 추가하는 방법으로 환경변수를 설정해주하면 된다. 지정 커맨드 이용 # c++ compiler sudo update-alternatives --config c++ # c compiler sudo update-alternatives --config cc 위의 커맨드를 입력하고 아래처럼 결과 창이 나오면 원하는 번호를 입력하여 c와 c++에 지정된 컴파일러 경로를 바꿔준다.","title":"Ubuntu Clang 컴파일러 설정"},{"content":"  나에게 vim이란 라즈베리파이 같은 리소스나 메모리등 작업 환경이 열악하거나 불가피한 사유로 인터넷을 사용하지 못하는 상황에서 가끔 쓰던 편집기였다.\nhjkl로 움직이고, visual mode, normal mode 등등 처음에는 진입장벽이 높게 느껴져서 손이 안가다가, 마우스를 쓰는게 너무 귀찮아서 일주일만 마음먹고 연습(?)을 했더니 이제는 vim이 없으면 코딩을 할 맛이 안나게 될 정도로 익숙해져버렸다.\nvim으로 갈아타게 된 결정적인 계기는 VSCode에서 지원하는 c/cpp extension이 메모리를 너무 잡아먹어서이다.. (물론 vim도 이것저것 많이 깔면 느려지겠지만)\n아무튼 내가 생각하는 vim의 장점은 이렇다\n 프로그램이 light하고 seamless 하다 vim script 작성으로 기능 커스터마이징이 자유롭다 처음 learning curve만 극복하면 작업효율이 엄청 상승한다 간지난다   neovim 설치하기 neovim은 terminal buffer를 지원하는 좀 더 기능이 확장된 형태의 vim이다. terminal buffer말고도, 24bit true color 지원 등 더 다양하고 좋은 기능들을 탑재한 vim이라, neovim을 설치하였다.\n내가 사용하는 os:q 는 ubuntu이므로 Debian install 가이드를 따라 설치를 진행하였다.\nsudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update sudo apt-get install neovim sudo apt-get install python-dev python-pip sudo apt-get install python3-dev python3-pip 설치가 완료되면 터미널에 nvim을 치면아래의 그림처럼 neovim이 실행된다.   기본 설정 neovim도vim과 똑같이 vimrc같은 설정파일을 수정하여 기본적인 설정을 할 수 있다.\n설정 파일의 경로는 ~/.config/nvim이며 이 경로에 파일을 직접 생성해야 한다.\n$ mkdir ~/.config/nvim $ cd ~/.config/nvim $ touch init.vim 아래는 현재 사용중인 init.vim의 설정이다.\nset iskeyword+=- set formatoptions-=cro syntax on set hidden \u0026#34; 버퍼를 수정한 직후 버퍼를 감춰지도록 함 set wrap \u0026#34; 자동 줄 바꿈 set encoding=UTF-8 \u0026#34; UTF-8 인코딩 set t_Co=256 \u0026#34; 256 칼라 지원 set number \u0026#34; 라인 수 표시 set ruler \u0026#34; 커서 표시 set cursorline \u0026#34; 현재 커서 하이라이팅 set pumheight=10 \u0026#34; 팝업 메뉴 크기 조정 set showcmd \u0026#34; 명령어를 상태라인에 보여준다 set mouse=a \u0026#34; 마우스 사용 가능 set tabstop=2 \u0026#34;\u0026#34; set shiftwidth=2 \u0026#34;\u0026#34; set smarttab \u0026#34;\u0026#34; set smartindent \u0026#34; 새로운 라인 시작 시, auto indentation 수행 set autoindent \u0026#34; 자동 들여쓰기 set expandtab \u0026#34; tab을 space로 확장 set showmatch \u0026#34; 매칭되는 괄호 표시 set background=light set showtabline=2 set noshowmode set nobackup \u0026#34; 백업파일을 생성하지 않는다 set signcolumn=yes set updatetime=300 set timeoutlen=100 set clipboard=unnamedplus \u0026#34; 클립보드 복사\u0026amp;붙여넣기 허용 set incsearch \u0026#34; 점진적으로 찾기 set hlsearch \u0026#34; 검색어 하이라이팅 set nowrapscan \u0026#34; 찾기 파일 맨 끝 도달시, 계속하여 찾지 않음 set guifont=Hack\\ Nerd\\ Font \u0026#34; 폰트 설정 set ignorecase \u0026#34; 검색시 대소문자 구별 X let $TERM=\u0026#34;xterm-256color\u0026#34; \u0026#34; true color \u0026#34; 파일 열기 마지막 부분 저장 if has(\u0026#34;autocmd\u0026#34;) \u0026#34; When editing a file, always jump to the last cursor position autocmd BufReadPost * \\ if line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026gt; 0 \u0026amp;\u0026amp; line (\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026lt;= line(\u0026#34;$\u0026#34;) | \\ exe \u0026#34;normal g\u0026#39;\\\u0026#34;\u0026#34; | \\ endif endif ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_1/","summary":"나에게 vim이란 라즈베리파이 같은 리소스나 메모리등 작업 환경이 열악하거나 불가피한 사유로 인터넷을 사용하지 못하는 상황에서 가끔 쓰던 편집기였다.\nhjkl로 움직이고, visual mode, normal mode 등등 처음에는 진입장벽이 높게 느껴져서 손이 안가다가, 마우스를 쓰는게 너무 귀찮아서 일주일만 마음먹고 연습(?)을 했더니 이제는 vim이 없으면 코딩을 할 맛이 안나게 될 정도로 익숙해져버렸다.\nvim으로 갈아타게 된 결정적인 계기는 VSCode에서 지원하는 c/cpp extension이 메모리를 너무 잡아먹어서이다.. (물론 vim도 이것저것 많이 깔면 느려지겠지만)\n아무튼 내가 생각하는 vim의 장점은 이렇다","title":"Vim 사용하기 #1 - Install"},{"content":"   OpenCV 라이브러리를 사용해본 사람이라면 한번쯤 ImageWatch 플러그인을 사용해봤을 것이다.\n디버거에서 확인하기 힘든 Mat 데이터내 index value등 간편한 인터페이스를 통해 직관적으로 확인이 가능한 유용한 툴이다. 하지만, Visual Studio에서만 사용이 가능한 플러그인이라, 리눅스 환경에서 개발을 하는 나에게는 아쉬움이 많았다.\n그러다가 github에서 imagewatch와 비슷하게 간편한 인터페이스로 index값을 확인할 수 있는 프로그램을 발견하게 되었고, 지금까지 아주 유용하게 사용하고 있다.\n   설치조건 gdb imagewatch는 아래의 프로그램들의 설치를 필요로 한다.\n OpenGL 2.1++ C+11 컴파일러 gdb 7.10 버전 이상 Qt 5.6 버전 이상 (HighDPI 필요) Python 3+  $ gdb --version 으로 현재 gdb의 버전이 7.10 이상인지 확인한다.\n 설치 및 빌드 위의 설치조건에 모두 부합하다면, git을 이용하여 프로그램을 다운로드 한다. (git url)\n$ git clone https://github.com/csantosbh/gdb-imagewatch $ cd gdb-imagewatch $ git submodule init $ git submodule update 다운로드 및 submodule 설정을 해주고, 아래의 명령어들을 이용해 build 한다\n$ mkdir build \u0026amp;\u0026amp; cd build $ qmake .. BUILD_MODE=release PREFIX=/path/to/installation/folder $ make -j4 $ make install build mode의 prefix 부분은 설치의 경로를 지정해주면 된다. 기본적으로 /usr/local이 지정되어있다.\n빌드가 성공적으로 되었다면 설치경로에서 python3 gdb-imagewatch.py --test 명령어를 통해 정상적으로 설치가 되었는지 확인한다.\n   사용법 gdb에서 imageWatch를 자동으로 실행시켜주기 위해 ~/.gdbinit 파일을 열어서 마지막 라인에 아래의 줄을 추가한다\nsource /path/to/gdb-imagewatch/gdb-imagewatch.py  아래 사진처럼 gdb가 breakpoint에서 걸리면 자동으로 창이 생성되면 보고자 하는 symbol명을 입력하면 된다.\n  code example   50x50행렬, 8 bit 3 channel을 모두 1로 초기화한 행렬을 imageWatch를 통해 확인한다.\n  image watch   ","permalink":"https://ralpioxxcs.github.io/post/etc/gdb_imagewatch_1/","summary":"OpenCV 라이브러리를 사용해본 사람이라면 한번쯤 ImageWatch 플러그인을 사용해봤을 것이다.\n디버거에서 확인하기 힘든 Mat 데이터내 index value등 간편한 인터페이스를 통해 직관적으로 확인이 가능한 유용한 툴이다. 하지만, Visual Studio에서만 사용이 가능한 플러그인이라, 리눅스 환경에서 개발을 하는 나에게는 아쉬움이 많았다.\n그러다가 github에서 imagewatch와 비슷하게 간편한 인터페이스로 index값을 확인할 수 있는 프로그램을 발견하게 되었고, 지금까지 아주 유용하게 사용하고 있다.\n   설치조건 gdb imagewatch는 아래의 프로그램들의 설치를 필요로 한다.\n OpenGL 2.","title":"gdb에서 imagewatch 사용하기"},{"content":"set 변수를 사용해 Shell에 출력되는 문자들의 색상을 지정할 수 있다.\nif(NOT WIN32) string(ASCII 27 Esc) set(ColourReset \u0026#34;${Esc}[m\u0026#34;) set(ColourBold \u0026#34;${Esc}[1m\u0026#34;) set(Red \u0026#34;${Esc}[31m\u0026#34;) set(Green \u0026#34;${Esc}[32m\u0026#34;) set(Yellow \u0026#34;${Esc}]33m\u0026#34;) set(Blue \u0026#34;${Esc}]34\u0026#34;) set(Magenta \u0026#34;${Esc}]35m\u0026#34;) set(Cyan \u0026#34;${Esc}]36m\u0026#34;) set(White \u0026#34;${Esc}[37m\u0026#34;) set(BoldRed \u0026#34;${Esc}[1;31m\u0026#34;) set(BoldGreen \u0026#34;${Esc}[1;32m\u0026#34;) set(BoldYellow \u0026#34;${Esc}[1;33m\u0026#34;) set(BoldBlue \u0026#34;${Esc}[1;34m\u0026#34;) set(BoldMagenta \u0026#34;${Esc}[1;35m\u0026#34;) set(BoldCyan \u0026#34;${Esc}[1;36m\u0026#34;) set(BoldWhite \u0026#34;${Esc}[1;37m\u0026#34;)endif()위의 내용을 .cmkae파일로 만들어 include하거나 CmakeLists.txt 의 상단에 삽입한다.\nExample message(\u0026#34; \u0026#34;)message( \u0026#34;${BoldGreen}\\t\\t\\t[ BUILD SUMMARY ] ${White}\u0026#34; )message( \u0026#34;${BoldWhite}------------------------------------------------------------------------${ColourReset}\u0026#34; ","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_4/","summary":"set 변수를 사용해 Shell에 출력되는 문자들의 색상을 지정할 수 있다.\nif(NOT WIN32) string(ASCII 27 Esc) set(ColourReset \u0026#34;${Esc}[m\u0026#34;) set(ColourBold \u0026#34;${Esc}[1m\u0026#34;) set(Red \u0026#34;${Esc}[31m\u0026#34;) set(Green \u0026#34;${Esc}[32m\u0026#34;) set(Yellow \u0026#34;${Esc}]33m\u0026#34;) set(Blue \u0026#34;${Esc}]34\u0026#34;) set(Magenta \u0026#34;${Esc}]35m\u0026#34;) set(Cyan \u0026#34;${Esc}]36m\u0026#34;) set(White \u0026#34;${Esc}[37m\u0026#34;) set(BoldRed \u0026#34;${Esc}[1;31m\u0026#34;) set(BoldGreen \u0026#34;${Esc}[1;32m\u0026#34;) set(BoldYellow \u0026#34;${Esc}[1;33m\u0026#34;) set(BoldBlue \u0026#34;${Esc}[1;34m\u0026#34;) set(BoldMagenta \u0026#34;${Esc}[1;35m\u0026#34;) set(BoldCyan \u0026#34;${Esc}[1;36m\u0026#34;) set(BoldWhite \u0026#34;${Esc}[1;37m\u0026#34;)endif()위의 내용을 .cmkae파일로 만들어 include하거나 CmakeLists.txt 의 상단에 삽입한다.\nExample message(\u0026#34; \u0026#34;)message( \u0026#34;${BoldGreen}\\t\\t\\t[ BUILD SUMMARY ] ${White}\u0026#34; )message( \u0026#34;${BoldWhite}------------------------------------------------------------------------${ColourReset}\u0026#34; ","title":"CMake Part4 - 색상 지정"},{"content":"어떤 프로젝트를 cmake를 이용하여 관리 및 빌드하고자 할때, CMakeLists.txt를작성 시 자주 사용되는 cmake 기본 명령어들이 있다.\n(Root) |- CMakeLists.txt |- README.md |- [src] | |- CMakeListst.txt | |- foo.cpp | |- poo.cpp | |- main.cpp |- [include] | |- foo.h | |- poo.h |- [cmake] | |- options.cmake 이런 구조를 가지는 프로젝트 폴더가 있다고 할 때, CMakeLists.txt는 아래와 같다.\n# [/CMakeListst.txt] cmake_minimum_required(VERSION 3.3)project(foo CXX)# -\u0026gt; \u0026#39;foo\u0026#39;라는 project를 정의한다. # cmake files list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)include(options)# -\u0026gt; project 설정관련 전반 .cmake 파일들을 include한다 # build configure set(CMAKE_BUILD_TYPE Debug)set(CMAKE_VERBOSE_MAKEFILE true)# -\u0026gt; build 타입및 compile 관련 설정 # -\u0026gt; header파일들을 include paht에 포함시키고 src 폴더내의 CMakeLists.txt를 수행 include_directories(${CMAKE_CURRENT_LIST_DIR}/include)add_subdirectory(src)src폴더 내, CMakeLists.txt파일은\n# [src/CMakeListst.txt] # src files.. set(SRC_PATH ${CMAKE_CURRENT_LIST_DIR}/main.cpp ${CMAKE_CURRENT_LIST_DIR}/foo.cpp ${CMAKE_CURRENT_LIST_DIR}/poo.cpp)set(OUTPUT_EFL test.out)# -\u0026gt; build할 파일들을 SRC_PATH 변수에 담는다 # generate executable file add_executable(${OUTPUT_ELF} ${SRC_PATH}) # -\u0026gt; executable 파일을 생성 taget_link_libraries(${OUTPUT_ELF} libs) # -\u0026gt; 라이브러리 링크 file(MAKE_DIRECTORY ${CMAKE_SOURCE_DIR}/install) # -\u0026gt; install 폴더 생성 # install 명령 수행 install(TARGETS ${OUTPUT_ELF} DESTINATION ${CMAKE_SOURCE_DIR}/install)","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_3/","summary":"어떤 프로젝트를 cmake를 이용하여 관리 및 빌드하고자 할때, CMakeLists.txt를작성 시 자주 사용되는 cmake 기본 명령어들이 있다.\n(Root) |- CMakeLists.txt |- README.md |- [src] | |- CMakeListst.txt | |- foo.cpp | |- poo.cpp | |- main.cpp |- [include] | |- foo.h | |- poo.h |- [cmake] | |- options.cmake 이런 구조를 가지는 프로젝트 폴더가 있다고 할 때, CMakeLists.txt는 아래와 같다.\n# [/CMakeListst.txt] cmake_minimum_required(VERSION 3.3)project(foo CXX)# -\u0026gt; \u0026#39;foo\u0026#39;라는 project를 정의한다. # cmake files list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)include(options)# -\u0026gt; project 설정관련 전반 .","title":"CMake Part3 - 프로젝트 구성"},{"content":"Hi! 😀 My name is JaeHong Kim.\nI work as a Software Engineer on an IT Compnay from Korea.\nI focus on Image processing Development.\nProgramming as a craftsmanship is my main hobby, learning something new keeps me motivated.\nAlso, I love to build keyboards.\nI made this blog to improve my development skills and career.\n","permalink":"https://ralpioxxcs.github.io/about/","summary":"Hi! 😀 My name is JaeHong Kim.\nI work as a Software Engineer on an IT Compnay from Korea.\nI focus on Image processing Development.\nProgramming as a craftsmanship is my main hobby, learning something new keeps me motivated.\nAlso, I love to build keyboards.\nI made this blog to improve my development skills and career.","title":"About"},{"content":"1. project 초기 설정 CMAKE_MINIMUM_REQUIRED [용법]\ncmake_minimum_required(VERSION major.minor[.patch[.tweak]][FATAL_ERROR])만약 어떤 오픈소스 라이브러리가 cmake 3.0 버전 이상으로 작성 되었고, 현재 나의 빌드환경은 cmake 2.8버전 미만이라면 빌드 시, 다음의 에러가 출력된다 -\u0026gt;\nCMake 3.0 or higher is required. You are running version 2.8.12.2\n이 커맨드는 반드시 CMakeListst.txt 작성시 맨 처음에 선언 해 놓아야 정상적인 버전 호환 에러를 출력할 수 있다.\n# Bad example project(foo)cmake_minimum_required(VERSION 3.0)message(\u0026#34;Using CMake version ${CMAKE_VERSION}\u0026#34;)\nPROJECT [용법]\nproject(\u0026lt;PROJECT-NAME\u0026gt; [LANGUAGES] [\u0026lt;language-name\u0026gt;...])project(\u0026lt;PROJECT-NAME\u0026gt; [VERSION \u0026lt;major\u0026gt;[.\u0026lt;minor\u0026gt;[.\u0026lt;patch\u0026gt;[.\u0026lt;tweak\u0026gt;]]]] [LANGUAGES \u0026lt;language-name\u0026gt;...])이름 및 버전, 언어등 전체 프로젝트에 대한 정의를 한다.\n아래와 같이 1.0 버전의 c/c++로 작성된 foo라는 프로젝트를 명시할 수 있다. Visual Studio로 예를 들자면 솔루션 탐색기의 최상단에 위치하는 프로젝트의 이름이 된다.\nproject(foo C CXX VERSION 1.0)SET [용법]\n# Normal Variable set(\u0026lt;variable\u0026gt; \u0026lt;value\u0026gt;... [PARENT_SCOPE])# Cache Entry set(\u0026lt;variable\u0026gt; \u0026lt;value\u0026gt;... CACHE \u0026lt;type\u0026gt; \u0026lt;docstring\u0026gt; [FORCE])각종 변수를 정의하는데 사용되는 명령어이다.\nset( var1 10 )일때 var1은 10의 값을 가지고 현재 디렉토리내에서만 유효하다. 하지만 만약 마지막에 PARENT_SCOPE 옵션을 사용한다면 var1의 scope는 부모 디렉터리까지 유효하게 된다. 또한, ENV옵션을 사용해 다음처럼 환경변수를 정의할 수도 있다.\nset(ENV{LOG_LEVEL} TRACE)\nINCLUDE [용법]\ninclude(\u0026lt;file|module\u0026gt; [OPTIONAL] [RESULT_VARIABLE \u0026lt;VAR\u0026gt;] [NO_POLICY_SCOPE]) .cmake 로 작성된 파일들을 사용할수 있도록 프로젝트에 포함시킨다. CMAKE_MODULE_PATH라는 예약변수에 의해 경로가 설정되며, 해당 경로를 통해 .cmake 파일을 탐색한다.\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # cmake폴더 path 추가 include(options) # options.cmake 파일 Load \nINCLUDE_DIRECTORIES [용법]\ninclude_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 컴파일러에게 각 소스파일에 있는 #include로 포함된 헤더파일들을 포함시킬 수 있도록 하는 명령이다. 아래 예시를 들면 include폴더에 있는 모든 헤더파일을 찾을 수 있도록 한다.\n# EXAMPLE # 현재 CMakeLists.txt가 실행되는 파일 위치의 경로에서 include라는 폴더를 포함함 include_directories( ${CMAKE_CURRENT_LIST_DIR}/include )\nADD_SUBDIRECTORY [용법]\nadd_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) cmake 빌드에 필요한 디렉토리를 추가하는 명령이다. 만약 모듈별, 폴더별로 CMakeLists.txt가 나누어져 있다고 하면, 이 명령어를 통해서 CMakeListst.txt가 있는 폴더의 위치를 명시해줌으로써, 하위 모듈의 CMakeLists.txt파일들을 source_dir에 추가시킬 수 있도록 한다.\n# EXAMPLE # src 폴더내의 CMakeLists.txt를 포함해 실행될수 있도록 함 add_subdirectory( ${CMAKE_CURRENT_LIST_DIR}/src )\n 2. compile 설정 관련 ADD_COMPILE_OPTIONS [용법]\nadd_compile_options(\u0026lt;option\u0026gt; ...) 소스를 컴파일해 오브젝트 파일(.obj)을 만들때, 컴파일러에게 옵션(flag)를 지정해주는 명령어.\nadd_compile_options(-Wall) 은 gcc -Wall과 대치된다.\nADD_DEFINITIONS [용법]\nadd_definitions(-DFOO -DBAR ...) preprocesor에서 처리할 변수를 선언한다. gcc flag중 -D option에 대치된다.\nadd_definitions( -D__linux__ )는 #define __linux와 같다.\nCMAKE_BUILD_TYPE project의 build type을 결정한다.\n Debug : 디버깅 정보를 포함하는 빌드 Relase : 릴리즈 전용 빌드 RelWithDebInfo : 디버깅 정보를 포함하는 릴리즈 빌드 MinSizeRel : 최소크기를 가지는 릴리즈 빌드  # EXAMPLE # 릴리즈로 빌드 set(CMAKE_BUILD_TYPE Release)\nCMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다.\n# EXAMPLE set(CMAKE_VERBOSE_MAKEFILE true)true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.\nCMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다.\nset(CMAKE_VERBOSE_MAKEFILE true)true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.\n 3. build 설정 관련 ADD_EXECUTABLE [용법]\nadd_executable(\u0026lt;name\u0026gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) \u0026lt;name\u0026gt;으로 설정된 project 타겟에 대하여 source list로부터 실행가능한 executable 파일을 생성한다. 기본적으로 생성된 파일의 위치는 명령어가 발생한 곳의 위치에 생성되며, RUNTIME_OUTPUT_DIRECTORY 변수를 통해 위치를 변경할 수 있다.\n# EXAMPLE set(src main.cpp foo.cpp boo.cpp)# test.out의 실행파일을 생성 add_executable(test.out ${src})\nLINK_LIBRARIES [용법]\nlink_libraries([item1 [item2 [...]]] [[debug|optimized|general] \u0026lt;item\u0026gt;] ...) 모든 타겟에 대해 사용될 라이브러리를 링크하는 명령. gcc 옵션중 -l에 대치되는 명령이며 링크옵션 또한 사용가능하다.\n# EXAMPLE  # libbluetooth 라이브러리를 링크 link_libraries(bluetooth)\nINSTALL [용법]\ninstall(TARGETS targets... [EXPORT \u0026lt;export-name\u0026gt;] [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE| PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE] [DESTINATION \u0026lt;dir\u0026gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT \u0026lt;component\u0026gt;] [OPTIONAL] [EXCLUDE_FROM_ALL] [NAMELINK_ONLY|NAMELINK_SKIP] ] [...] [INCLUDES DESTINATION [\u0026lt;dir\u0026gt; ...]] ) make install 명령어 입력시 진행되는 과정을 정의하는 명령. 주로 cmake 빌드 과정을 통해 나오는 결과물 ( 실행파일, 라이브러리, 리소스) 등을 특정한 위치로 복사하는 동작을 한다.\n# EXAMPLE # output.out 바이너리 파일을 /usr/local/bin의 위치로 설치함 install(TARGETS output.out DESTINATION usr/local/bin)\n 4. 기타 FIND_FILE [용법]\nfind_file ( \u0026lt;VAR\u0026gt; name | NAMES name1 [name2 ...] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \u0026quot;cache documentation string\u0026quot;] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 찾을 파일의 이름의 전체경로를 찾아주는 명령. \u0026lt;VAR\u0026gt;변수에 결과가 저장되도록 한다. 만약 경로를 찾지 못하였을경우 \u0026lt;VAR\u0026gt;-NOTFOUND로 최종적으로 저장이된다.\n# EXAMPLE # test.cpp 파일의 전체 경로를 ${CPP_FILE_PATH}변수에 저장 find_file(CPP_FILE_PATH test.cpp PATHS /home/test)\nFIND_PACKAGE [용법]\nfind_package(\u0026lt;package\u0026gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE]) 시스템에 설치된 Package들을 찾는 명령. Package를 찾았을 경우 \u0026lt;package\u0026gt;_FOUND 변수에 결과가 저장된다.\n version : package의 버전을 요청 EXACT : 버전이 정확히 일치하도록 요청 QUIET : package를 찾을 수 없는경우 메시지 비활성화 MODULE : 모듈모드로 package 찾음\n결론적으로, target link libraries 명령을 사용할 때 사용되는 정보들을 받아 linking하는데 관련된 정보를 사용할 수 있도록 하는 명령어이다. 기타 세부설명은 다음 링크에서 확인한다. [click] (https://cmake.org/cmake/help/v3.10/command/find_package.html)  # EXAMPLE find_package(pak 1.0)if(pak_FOUND) # ... endif()# pak 이라는 패키지를 찾았으면 if실행 ------------------------------------------ find_package(pak 1.0 REQUIRED)# pak 이라는 패키지를 찾지 못할경우 오류 메시지 출력 (\u0026#39;REQUIRED\u0026#39;에 의해)  \nFIND_LIBRARY [용법]\nfind_library ( \u0026lt;VAR\u0026gt; name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \u0026quot;cache documentation string\u0026quot;] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) shared library(.so) , static library(.a) 파일등을 찾는 cmake 명령어이다. 찾고자하는 파일을 발견하면, \u0026lt;VAR\u0026gt;변수에 결과가 저장되며, 라이브러리 파일을 찾지 못하였을 경우 \u0026lt;VAR\u0026gt;-NOTFOUND를 저장한다.\n# EXAMPLE find_library ( FOO_LIBS NAMES foo PATHS /usr/lib )# /usr/lib의 경로에서 libfoo.so 라이브러리를 찾았으면 if실행 if( FOO_LIBS ) set(FOO_LIBS_FOUND true) include_directories(...) message(STATUS \u0026#34;success to find library\u0026#34;)else() message(STATUS \u0026#34;failed to find libarary\u0026#34;)endif()","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_2/","summary":"1. project 초기 설정 CMAKE_MINIMUM_REQUIRED [용법]\ncmake_minimum_required(VERSION major.minor[.patch[.tweak]][FATAL_ERROR])만약 어떤 오픈소스 라이브러리가 cmake 3.0 버전 이상으로 작성 되었고, 현재 나의 빌드환경은 cmake 2.8버전 미만이라면 빌드 시, 다음의 에러가 출력된다 -\u0026gt;\nCMake 3.0 or higher is required. You are running version 2.8.12.2\n이 커맨드는 반드시 CMakeListst.txt 작성시 맨 처음에 선언 해 놓아야 정상적인 버전 호환 에러를 출력할 수 있다.\n# Bad example project(foo)cmake_minimum_required(VERSION 3.0)message(\u0026#34;Using CMake version ${CMAKE_VERSION}\u0026#34;)\nPROJECT [용법]\nproject(\u0026lt;PROJECT-NAME\u0026gt; [LANGUAGES] [\u0026lt;language-name\u0026gt;...])project(\u0026lt;PROJECT-NAME\u0026gt; [VERSION \u0026lt;major\u0026gt;[.","title":"CMake Part2 - Commands \u0026 Vars"},{"content":"CMake? cmake란 cross platform 기반의 프로젝트 전체 빌드 프로세스를 관리해주는 유용한 툴이다. 직접 빌드를 수행하지는 않지만 지정된 OS에 맞는 Make파일 혹은 **솔루션(sln)**파일의 생성을 도와주어 소스코드 빌드를 편리하게 해준다.\nCmake의 장점  (root) |- foo.cpp |- CMakeLists.txt foo.cpp 라는 소스코드가 하나 있다고 가정하자. 이 소스코드를 각각의 다른 OS에서 빌드할 때, 윈도우즈라면 Visual Studio를, OSX라면 Xcode, Linux라면 Makefile을 이용할것이다. Cmake는 이런 귀찮은 과정을 CMakeLists.txt라는 프로젝트를 정의하는 파일을 하나 만듦으로써, 각 OS에 맞는 Build tool을 파악해 build command만 입력하면 될수 있도록 해준다.\nInstall $ sudo apt install cmake 의 명령어를 입력해 간단하게 설치할 수 있다.\n$ cmake --version 명령어를 입력해 cmake가 제대로 install 되었는지 확인한다.\n Example 1. Configure main.cpp 라는 파일이 있다고 하면, 같은 폴더 내 \u0026lsquo;CMakeLists.txt\u0026rsquo; 라는 파일을 새로 생성 후 아래와 같이 작성한다.\n# CMakeListst.txt cmake_minimum_required(VERSION 3.3)project (test)add_executable(test main.cpp)2. Generate 이제 작성된 CMakeLists.txt를 기반으로 CMake가 native build tool을 생성할 것이다.\n커맨드창에 $ cmake .를 입력하면 마지막 줄에 아래처럼 나오며 Makefile이 생성된다.\n-- Configure done -- Generating done -- Build files have been written to: ... 3. Build $ make 커맨드를 입력하면 작성된 Makefile에 의하여 foo.cpp -\u0026gt; foo.cpp.o -\u0026gt; foo 의 과정을 통해 executable 파일이 생성된다.\n","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_1/","summary":"CMake? cmake란 cross platform 기반의 프로젝트 전체 빌드 프로세스를 관리해주는 유용한 툴이다. 직접 빌드를 수행하지는 않지만 지정된 OS에 맞는 Make파일 혹은 **솔루션(sln)**파일의 생성을 도와주어 소스코드 빌드를 편리하게 해준다.\nCmake의 장점  (root) |- foo.cpp |- CMakeLists.txt foo.cpp 라는 소스코드가 하나 있다고 가정하자. 이 소스코드를 각각의 다른 OS에서 빌드할 때, 윈도우즈라면 Visual Studio를, OSX라면 Xcode, Linux라면 Makefile을 이용할것이다. Cmake는 이런 귀찮은 과정을 CMakeLists.txt라는 프로젝트를 정의하는 파일을 하나 만듦으로써, 각 OS에 맞는 Build tool을 파악해 build command만 입력하면 될수 있도록 해준다.","title":"CMake Part1 - Overview"},{"content":"Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.\n 　Shotcode 사용하기 shortcode는 { {\u0026lt; shortcodename parameters \u0026gt;} } 의 용법으로 간단하게 사용할 수 있다.\n shortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..) parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐   Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다.\n code example  { {\u0026lt; figure src=\u0026quot;/images/ar87.jpg\u0026quot; title=\u0026quot;GMK Oblivion\u0026quot; caption=\u0026quot;caption\u0026quot;\u0026gt;} }  use example   GMK Oblivioncaption\n    highlight 주로 code들을 highlight를 지원하는 언어들은 여기에서 확인할수 있다. 대부분의 언어를 지원한다.\n  code example { {\u0026lt; highlight cpp \u0026gt;} } #include\u0026lt;stdio.h\u0026gt; printf(\u0026#34;hello world!\\n\u0026#34;) { {\u0026lt; /highlight \u0026gt;} }\n  use example #include\u0026lt;stdio.h\u0026gt;printf(\u0026#34;hello world!\\n\u0026#34;)\n    　이외에도 instagram, gist, tweet등 다양한 shortcode를 제공한다.\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_4_shortcodes/","summary":"Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.\n 　Shotcode 사용하기 shortcode는 { {\u0026lt; shortcodename parameters \u0026gt;} } 의 용법으로 간단하게 사용할 수 있다.\n shortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..) parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐   Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다.","title":"Hugo Content Management [4] - Shortcodes"},{"content":"Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. \n Formats Hugo는 다음 3가지의 마크업 언어를 지원한다.\n TOML : +++ YAML : --- JSON : {, }\n을 이용해 front matter의 시작과 끝을 지정한다.  예를들어, a.md라는 새로운 파일을 만들었다면 --- title: \u0026#34;this is title!\u0026#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,\n위처럼 front matter에 설정한대로, title과 date가 입력이된것을 볼수있다.\nVariables Hugo에서 미리 정의되고 바로 사용할수 있는 front matter 변수들은 다음과 같다.\ntitle content의 제목을 결정한다.\ndescription content의 설명\ndraft draft를 true를 설정하면, --buildDrafts 혹은 -D 플래그를 설정하지 않는 이상 이 파일은 hugo로 빌드?되어지지 않는다.\nweight content의 순서를 결정한다, 숫자가 낮을수록 상단에 위치하게 된다.\nAccss to front matter ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_3_frontmatter/","summary":"Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. \n Formats Hugo는 다음 3가지의 마크업 언어를 지원한다.\n TOML : +++ YAML : --- JSON : {, }\n을 이용해 front matter의 시작과 끝을 지정한다.  예를들어, a.md라는 새로운 파일을 만들었다면 --- title: \u0026#34;this is title!\u0026#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,","title":"Hugo Content Management [3] - Front Matter"},{"content":"Hugo에서는 Page Bundles이라는 개념을 사용해 컨텐츠를 관리한다. Page Bundles에는 2가지 종류가 있다.\n Leaf Bundle Branch Bundle   Left Bundle left bundle은 단독 페이지를 구성하는데 사용되고, index.md 파일을 포함하는 폴더로 구성된다.\n3 of Leaf Bundle Example content/ ├── project │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md │ └── study │ ├── first.md │ └── second.md │ └── index.md project 1개의 index.md파일만을 갖는 leaf bundle page\nmy-post 2개의 Markdown 컨텐츠와 index.md파일을 갖는 leaf bundle page\nstudy 2개의 Markdown 컨텐츠를 갖는 leaf bundle page\n* Headless Bundle headless bundle은 다음의 특징을 갖는다.\n Permalink를 갖지 않음 .Site.RegularPage의 부분에 속하지 않음\n다시말해, headless bundle은 어디에도 게시되지않는 무형의 페이지이다.   오직 leaf bundle만이 headless bundle로 만들어 질 수 있다.\n (추가예정)\n Branch Bundle branch bundle은 여러 페이지들을 구성하는데 사용되고, leaf bundle과는 다르게 _index.md 파일을 포함하는 폴더로 구성된다.\ncontent/ 디렉터리 안에 _index.md파일을 작성할 수도 있다.\n2 of Leaf Bundle Example content/ ├── branch_bundle_1 │ ├── branch_contents1.md │ ├── branch_contents2.md │ ├── branch_image1.png │ ├── branch_image2.png │ ├── _index_.md │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md ├── branch_bundle_2 │ ├── branch2_contents1.md │ ├── branch2_contents2.md │ ├── _index.md branch_bundle_1 2개의 Markdown 콘텐츠, 2개의 image, 1개의 leaf bundle, _index.md를 포함하는 branch bundle page\nmy-branch_bundle_2 2개의 Markdown 컨텐츠와 index.md파일을 갖는 branch bundle page \n index.md와 _index.md의 차이점     Left Bundle Branch Bundle     파일이름 index.md _index.md   사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing   사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing    ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_2_page/","summary":"Hugo에서는 Page Bundles이라는 개념을 사용해 컨텐츠를 관리한다. Page Bundles에는 2가지 종류가 있다.\n Leaf Bundle Branch Bundle   Left Bundle left bundle은 단독 페이지를 구성하는데 사용되고, index.md 파일을 포함하는 폴더로 구성된다.\n3 of Leaf Bundle Example content/ ├── project │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md │ └── study │ ├── first.md │ └── second.","title":"Hugo Content Management [2] - Page Bundle"},{"content":"Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.\n컨텐츠 구성 (root) └── content └── project | └── index.md // \u0026lt;- https://example.com/project/ ├── posts | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ └── study ├── first.md // \u0026lt;- https://example.com/study/first/ └── second.md // \u0026lt;- https://example.com/study/second/ 위 처럼 각각 project, posts, study 총 3개의 카테고리가 있다고 가정할 때, Hugo는 section, slug, path, url의 변수들을 이용해 컨텐츠를 관리한다.\n section : default 컨텐츠 타입, content폴더의 어느위치에 있느냐에 따라 달라진다. slug : slug 변수는 각 컨텐츠 파일의 이름 (e.g., firstpost.md) 가 될수 있고, frontmatter에 의해 설정될 수 있다. path : section에서 slug 직전 까지의 경로 url : 컨텐츠의 상대적인 url, section부터 slug가 포함된 경로와 같다.  . url . ⊢--^-⊣ . path slug . ⊢--^-⊣⊢---^---⊣ . filepath . ⊢------^------⊣ content/posts/firstpost.md  컨텐츠 경로 재정의 Hugo가 생성한 defualt 컨텐츠 경로를 frontmatter를 이용해 재정의(override)할 수 있다.\n  slug\nslug를 재정의 하는 방법은 frontmatter에 slug를 추가한다.\n(e.g., content/posts/old-post.md) +++ title =\u0026#34;New Post\u0026#34; slug =\u0026#34;new-post\u0026#34; +++\n  결과 : example.com/posts/new-post/\n  url\nURL또한 재정의(override)될 수 있다. url은 baseURL 다음으로 올 경로를 넣으면 된다. (참고로 --uglyURLs 옵션을 무시한다) (e.g., content/posts/old-url.md) +++ title =\u0026#34;old url\u0026#34; slug =\u0026#34;/blog/new-url\u0026#34; +++\n  baseURL이 ttps://example.com로 설정된 경우, 기존 url인 posts/old-url.md를 다음처럼 바꾼다.\n 결과 : https://example.com/blog/new-url/  ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_1_contents_path/","summary":"Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.\n컨텐츠 구성 (root) └── content └── project | └── index.md // \u0026lt;- https://example.com/project/ ├── posts | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ └── study ├── first.md // \u0026lt;- https://example.com/study/first/ └── second.md // \u0026lt;- https://example.com/study/second/ 위 처럼 각각 project, posts, study 총 3개의 카테고리가 있다고 가정할 때, Hugo는 section, slug, path, url의 변수들을 이용해 컨텐츠를 관리한다.","title":"Hugo Content Management [1] - Contents Path"},{"content":"나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.\n Step 1. github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다.\n blog 폴더 자체를 저장할 repository hugo로 빌드된 결과파일들을 저장할 repository\n두번째 repository의 이름은 [github계정명].github.io의 형식으로 만들어야 한다.   remote repository 연동  c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성한다. $ git remote add origin [첫번째 repository url]를 입력한다. $ git submodule add -b master [두번째 repository url] public을 입력하여 hugo로 빌드될 public폴더를 서브모듈로 연결한다. $ hugo -t [테마 폴더명]를 입력하면 hugo가 빌드를 시작하고 public 폴더가 생성이 된다.    Step 2. 컨텐츠 배포 Commit  c://hugo/blog/public 경로에서 git add . $ git commit -m \u0026quot;first commit\u0026quot; $ git push origin master c://hugo/blog 경로에서 위의 3과정 반복   Check 이제 https://github.com/계정명.github.io로 접속하여 블로그의 컨텐츠들이 업로드 되었는지 확인한다..\n ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_4_remote_repo_link/","summary":"나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.\n Step 1. github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다.\n blog 폴더 자체를 저장할 repository hugo로 빌드된 결과파일들을 저장할 repository\n두번째 repository의 이름은 [github계정명].github.io의 형식으로 만들어야 한다.   remote repository 연동  c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성한다. $ git remote add origin [첫번째 repository url]를 입력한다.","title":"Getting Started Hugo [4] - 레포지토리 연동 및 웹 호스팅"},{"content":"명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.\n( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.\n content 모든 게시글들 (contents)파일들은 content 디렉토리내에 쓰여지고 저장된다. 예를들면 사이트내에 3개의 주요 카테고리 (eg. blog, articles, tutorials) 가 있다고하면 content폴더내의 디렉토리 구조는 content/blog, content/articels, content/tutorials의 구조를 갖게된다.\n data Hugo에서 site를 생성할 떄, 구성파일들을 저장하는데 사용되는 폴더이다. yaml, toml, json 형태로 쓸 수 있다.\n layouts static site를 구성하는 모든 ~.html 확장자를 갖는 파일들을 저장한다. list pages, homepage, single page 등 더 많은 템플릿을 포함하고, hugo theme를 이용하는 사용자의 측면에서 가장 중요한 폴더이며, 이 부분을 수정하여 입맛에 맞게 수정하여 사용할 수도 있다.\n static CSS, JavaScript, image등의 정적인 파일들이 저장된 폴더이다. Hugo에 의해서 site를 생성할때, static폴더내의 파일들이 사용된다.\n themes 이미 만들어진 hugo의 theme를 저장하는 폴더. theme를 사용하려면 이 폴더에 theme폴더를 저장하고 config파일을 수정하여야 한다.\n config config.toml, config.yaml, config.json의 형태로 작성되며, hugo site를 생성할 때 기본 설정파일의 역할을 한다. theme를 사용할 때, 이 부분을 수정하여 theme를 적용하듯이 site를 생성하는데 중요한 역할을 한다. 보통 theme마다 config를 적용하는 방법이 달라 각 theme의 config 내부를 잘 살펴보면 사용법이 적혀있다.\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_3_directory/","summary":"명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.\n( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.","title":"Getting Started Hugo [3] - 디렉터리 구조"},{"content":"Let\u0026rsquo;s create own blog 　Step 1. 블로그 폴더 생성   c://hugo 의 경로에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 blog로 하였다.)\n  폴더를 만들었으면 $ cd blog \u0026amp;\u0026amp; ls  를 입력해 생성된 폴더의 내부를 확인한다.\n-\u0026gt; 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.\n  테스트 $ hugo server 명령어를 입력하고 localhost:1313 을 크롬, 파이어폭스등 웹브라우저 주소창에 입력해 생성된 사이트를 확인해보자. 아직은 빈 화면만 있을것이다.\n　 　Step 2. 테마 적용하기  hugo themes link 로 이동하여 원하는 테마를 선택한다. 각 테마 소개 화면에서 Demo를 클릭하면 각 블로그의 예시를 체험해볼 수 있다. 마음에 드는 테마를 찾았으면 Download 버튼을 클릭 후 테마의 repository 로 이동한다.  테마 다운로드  테마의 repository url를 복사한다. c://hugo/blog/themes 경로에서 $ git clone [repository url]를 입력하여 테마를 다운로드한다.\n($ git submodule 명령어를 사용하여도 된다. 사실 hugo getting started에서는 submodule 명령어로 테마를 추가하라고 명시되어있다.)  테마 적용  편집기를 이용해 config.toml파일을 연뒤, 마지막줄에 theme = \u0026quot;다운로드받은 테마 폴더명\u0026quot;을 추가해준다.  　 　Step 3. 컨텐츠 포스팅 테스트 파일 생성  c://hugo/blog의 경로로 돌아가 $ hugo new post/test.md 커맨드를 입력한다. 그러면 content 폴더안에 post 라는 폴더가 생기고 그 안에 test.md 파일이 생성된다.  확인하기  $ hugo server -D 커맨드를 입력하고 localhost:1313으로 들어가본다. 그러면 아까 생성한 test.md 글이 업로드 된것을 확인해 볼 수 있을것이다.  참고 각 테마마다 폴더 구성이 조금씩 다르지만, 기본적으로 테마를 받은 폴더안에는 exampleSite라는 폴더가 있을것이다. 만약 잘 안된다면 이 폴더를 잘보고 자신의 blog 로컬경로와 비교해가며 확인해보는 것도 좋다.\n ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_2_quick_start/","summary":"Let\u0026rsquo;s create own blog 　Step 1. 블로그 폴더 생성   c://hugo 의 경로에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 blog로 하였다.)\n  폴더를 만들었으면 $ cd blog \u0026amp;\u0026amp; ls  를 입력해 생성된 폴더의 내부를 확인한다.\n-\u0026gt; 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.","title":"Getting Started Hugo [2] - 블로그 생성"},{"content":"Hugo? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.\nInstall 설치방법은 install hugo에 각 OS별로 설치를 하는 방법이 잘 안내되어 있다.\nOSX brew install hugo Debian, Ubuntu sudo apt-get install hugo package installer를 이용하는 방법외에는 Release 다운로드 사이트에서 직접 다운로드하여 설치하는 방법도 있다.\n설치가 끝났다면 hugo -help 를 터미널에 입력하여 아래의 메세지가 정상적으로 나오는지 확인한다.\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks config Print the site configuration convert Convert your content to different formats env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026quot;config\u0026quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026quot;hugo [command] --help\u0026quot; for more information about a command. ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_1_install/","summary":"Hugo? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.\nInstall 설치방법은 install hugo에 각 OS별로 설치를 하는 방법이 잘 안내되어 있다.\nOSX brew install hugo Debian, Ubuntu sudo apt-get install hugo package installer를 이용하는 방법외에는 Release 다운로드 사이트에서 직접 다운로드하여 설치하는 방법도 있다.","title":"Getting Started Hugo [1] - 설치 및 환경설정"}]