[{"content":"문제 링크 문제 해결 초기 접근은\n너비(width)를 기준으로 1부터 최대길이까지 각 width에 맞는 height를 전부 탐색 현재 조건에서 brown + yellow = 높이 * 너비를 만족하면 정답 리턴 이런식으로 구현하였다가, 일부 케이스에서 실패 및 시간초과가 나왔다. 직사각형을 만들기 위해 리스트를 append하는 부분에서 효율적이지 못한 코드였다.\n문제의 조건을 다시 보고, 특정 w,h에서 yellow와 brown이 만족하는 조건에 초점을 맞춰서 다시 구현하였다.\n기존 풀이방법의 width를 기준으로 height를 순회하는 방법을 사용하되, 조건을 각 w,h일때 입력으로 주어진 brown,yellow가 되는조건을 검사하여 해결하였다.\n$$ \\begin{align*} Brown = 2w + 2h - 4 \\newline Yellow = (h-2) * (h-2) \\end{align*} $$\n코드 def solution(brown, yellow): answer = [] # brown: 2w + 2h - 4 # yellow: (w-2) * (h-2) for w in range(1, brown): for h in range(w+1): if (2*w + 2*h - 4) == brown and (w-2) * (h-2) == yellow: answer = [w,h] return answer return answer 실패한 코드 def solution(brown, yellow): answer = [] # 최소 2 너비부터 시작 for n in range(2, brown): carpet = [] # n 크기의 사각형 윗 변(갈색) carpet.append([0] * n) height = 1 # 현재 높이 # 높이는 너비보다 작거나 같아야 함 while height \u0026lt; n: carpet.append([0] * n) # 현재 조건 체크 if brown + yellow == len(carpet) * n: answer = [n, len(carpet)] return answer height += 1 return answer ","permalink":"https://ralpioxxcs.github.io/post/ps/programmers_carpet/","summary":"문제 링크 문제 해결 초기 접근은\n너비(width)를 기준으로 1부터 최대길이까지 각 width에 맞는 height를 전부 탐색 현재 조건에서 brown + yellow = 높이 * 너비를 만족하면 정답 리턴 이런식으로 구현하였다가, 일부 케이스에서 실패 및 시간초과가 나왔다. 직사각형을 만들기 위해 리스트를 append하는 부분에서 효율적이지 못한 코드였다.\n문제의 조건을 다시 보고, 특정 w,h에서 yellow와 brown이 만족하는 조건에 초점을 맞춰서 다시 구현하였다.\n기존 풀이방법의 width를 기준으로 height를 순회하는 방법을 사용하되, 조건을 각 w,h일때 입력으로 주어진 brown,yellow가 되는조건을 검사하여 해결하였다.","title":"프로그래머스 카펫"},{"content":"문제 링크 문제 해결 bfs를 이용하여 풀었다. 현재위치 (1,1)에서 맵을 탐색해 나가면서 벽이 있으면 카운팅, 없으면 계속해서 탐색한다. 단, 최소한의 갯수로 벽을 부숴 도착지로 이동해야 하므로 경로좌표를 queue에 삽입할 때, 빈 공간이 있으면 해당 좌표를 우선순위로 삽입하여 불 필요한 벽을 카운팅하는 일이 없도록 해야한다.\n코드 from collections import deque # move helper mx = [0, 0, -1, 1] my = [1, -1, 0, 0] def check_range(x, y: int): return x \u0026lt; m and y \u0026lt; n and x \u0026gt;= 0 and y \u0026gt;= 0 def solve(): paths = deque() paths.append((0, 0, 0)) # 초기위치, 벽 부순 횟수 visited[0][0] = 1 while (len(paths)): curPos = paths.popleft() cx = curPos[0] cy = curPos[1] brk = curPos[2] if cx == m - 1 and cy == n - 1: return brk for idx in range(4): nx = cx + mx[idx] ny = cy + my[idx] # 중복 방문 및 범위 예외 처리 if check_range(nx, ny) == False: continue if visited[ny][nx] == 1: continue visited[ny][nx] = 1 # 방문 처리 if maze[ny][nx] == 1: paths.append((nx, ny, brk + 1)) # 탐색 리스트 추가 (벽 카운팅 O) else: paths.appendleft((nx, ny, brk)) # 탐색 리스트 추가 (벽 카운팅 X) maze[ny][nx] = 0 # 빈 공간 처리 return 0 m, n = map(int, input().split()) maze = [list(map(int, input())) for _ in range(n)] # 0: empty, 1: wall visited = [[0 for _ in r] for r in maze] breaks = [[0 for _ in r] for r in maze] print(solve()) ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_1261/","summary":"문제 링크 문제 해결 bfs를 이용하여 풀었다. 현재위치 (1,1)에서 맵을 탐색해 나가면서 벽이 있으면 카운팅, 없으면 계속해서 탐색한다. 단, 최소한의 갯수로 벽을 부숴 도착지로 이동해야 하므로 경로좌표를 queue에 삽입할 때, 빈 공간이 있으면 해당 좌표를 우선순위로 삽입하여 불 필요한 벽을 카운팅하는 일이 없도록 해야한다.\n코드 from collections import deque # move helper mx = [0, 0, -1, 1] my = [1, -1, 0, 0] def check_range(x, y: int): return x \u0026lt; m and y \u0026lt; n and x \u0026gt;= 0 and y \u0026gt;= 0 def solve(): paths = deque() paths.","title":"백준 1261 알고스팟"},{"content":"문제 링크 문제 해결 N번째 감소하는 수가 몇인지 출력하는 문제, N은 최대 100만까지 입력된다.\n간단하게 0부터 987654321까지 감소하는 수인지 판별하는것은 시간초과가 나오므로, 감소하는 수의 특성을 이용하여 풀어야한다.\n감소하는 수는 955같이 중복이 나오면 안되고 맨 앞자리의 수에 의해 나머지가 결정된다. 예를들어 특정 감소하는 수가 5로 시작된다면 나머지는 반드시 {1,2,3,4}의 조합으로 이루어져야 한다. 이런 성질을 이용해서 1부터 10까지 대표 앞자리를 설정한 후 각 앞자리마다 파생되는 나머지 숫자들을 조합하면 된다.\n1 10 21 -\u0026gt; 210 -\u0026gt; 20 -\u0026gt; 20 32 -\u0026gt; 321 -\u0026gt; 3210 -\u0026gt; 320 31 -\u0026gt; 310 30 43 -\u0026gt; 432 -\u0026gt; 4321 -\u0026gt; 43210 -\u0026gt; 431 -\u0026gt; 430 ... 위 처럼 숫자가 올라갈수록 파생되는 수가 많아진다.\n이를 구현하기 위해 각 숫자를 \u0026lsquo;1\u0026rsquo;, \u0026lsquo;0\u0026rsquo;과 같이 문자 리스트로 변환 후 마지막 자리의 수에서 계속 파생되도록 재귀 호출 방식을 사용하였다.\n모든 감소하는 수를 구한 후, 오름차순 정렬 후 N번째 감소하는 수를 구하면 된다.\n또한, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }에서 공집합을 제외한 모든 부분집합의 갯수는 $$ 2^{10} - 1 = 1023 $$ 으로 마지막 부분집합 {0,1,2,3,4,5,6,7,8,9}가 1022번째 원소이다. (0부터 시작하므로 1022번째)\n따라서, 1023번째 이상 감소하는 수는 없으므로 그런 경우에는 문제의 조건대로 -1을 리턴하도록 설정한다.\n코드 n = int(input()) def solve(num): # ex) num : 10 # \u0026#39;1\u0026#39;,\u0026#39;0\u0026#39; # \u0026#39;0\u0026#39; ans.append(num) lastNum = int(str(num)[-1]) # decremental number for i in range(lastNum): numStr = str(num) + str(i) solve(int(numStr)) if n \u0026gt; 1023: print(-1) else: ans = [] for i in range(10): solve(i) print(sorted(ans)[n]) ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_1038/","summary":"문제 링크 문제 해결 N번째 감소하는 수가 몇인지 출력하는 문제, N은 최대 100만까지 입력된다.\n간단하게 0부터 987654321까지 감소하는 수인지 판별하는것은 시간초과가 나오므로, 감소하는 수의 특성을 이용하여 풀어야한다.\n감소하는 수는 955같이 중복이 나오면 안되고 맨 앞자리의 수에 의해 나머지가 결정된다. 예를들어 특정 감소하는 수가 5로 시작된다면 나머지는 반드시 {1,2,3,4}의 조합으로 이루어져야 한다. 이런 성질을 이용해서 1부터 10까지 대표 앞자리를 설정한 후 각 앞자리마다 파생되는 나머지 숫자들을 조합하면 된다.\n1 10 21 -\u0026gt; 210 -\u0026gt; 20 -\u0026gt; 20 32 -\u0026gt; 321 -\u0026gt; 3210 -\u0026gt; 320 31 -\u0026gt; 310 30 43 -\u0026gt; 432 -\u0026gt; 4321 -\u0026gt; 43210 -\u0026gt; 431 -\u0026gt; 430 .","title":"백준 1038 감소하는 수"},{"content":"문제 링크 문제 해결 맵에 있는 탐색 가능한 모든 문서의 갯수를 찾는 문제로, BFS를 이용하여 풀었다. 특이한 점은 주어진 열쇠로 맵에 있는 문을 열어서 이동할 수 가 있다는것인데, 열쇠를 맵을 탐색하면서 추가적으로 획득할 수 있기 때문에 이 부분을 유의하여 풀어야 한다.\n입력 for _ in range(int(input())): height, width = map(int, input().split()) floor = [list(input()) for _ in range(height)] keys = set(input()) visited = [[0 for _ in row] for row in floor] documents = 0 doors = {} # 열리지 않은 문 리스트 for door in \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;: doors.setdefault(door, set()) 2차원 맵을 입력받기위해 floor변수에 list comprehension을 이용하여 2중 리스트로 입력받았다.\n중복 탐색을 방지하기 위해 floor와 같은 크기의 맵 변수visited와 열쇠가 생길 때 열쇠없이 지나간 문을 탐색하기 위한 key가 알파벳 대문자 문, value가 좌표를 담을 set()인 dictionary doors 변수를 초기화하였다.\n탐색 탐색할 경로들 담는 paths의 리스트의 원소들이 없어질 때까지 반복문을 도는 구조로 기본적인 순회를 구현하였다.\n현재 자리에서 상,하,좌,우로 움직여 각 위치에 맞는 문자를 확인한다.\n벽(*): 다음 자리 순회 빈 공간(.): paths 리스트에 추가 문서($): 찾은 문서 숫자를 카운팅 후, 빈 공간(.)으로 바꿔준 뒤, paths 리스트에 추가한다 문(ABCD...Z): 열쇠가 있으면, floor를 빈 공간(.)으로 바꿔준 뒤, paths 리스트에 추가한다. 열쇠가 없다면 다음에 방문해야 할 문 변수 doors에 현재 좌표를 추가한다 열쇠(abcd...z): 못 열었던 문들 중 일치하는 열쇠가 있다면 paths에 추가하여 탐색할 수 있도록 한다 코드 from enum import Enum # move helper dx = [0, 0, 1, -1] dy = [1, -1, 0, 0] class Space(Enum): EMPTY_SPACE = 1 WALL = 2 DOCUMENT = 3 DOOR = 4 KEY = 5 def checkRange(x: int, y: int): if x \u0026lt; 0 or x \u0026gt;= width or y \u0026lt; 0 or y \u0026gt;= height: return False return True def checkSpace(what): if what == \u0026#39;.\u0026#39;: return Space.EMPTY_SPACE elif what == \u0026#39;*\u0026#39;: return Space.WALL elif what == \u0026#39;$\u0026#39;: return Space.DOCUMENT elif \u0026#39;A\u0026#39; \u0026lt;= what \u0026lt;= \u0026#39;Z\u0026#39;: return Space.DOOR elif \u0026#39;a\u0026#39; \u0026lt;= what \u0026lt;= \u0026#39;z\u0026#39;: return Space.KEY def solve(y: int, x: int): global documents global doors paths = [] # discovering paths (queue) what = floor[y][x] space = checkSpace(what) if space == Space.WALL: return elif space == Space.DOCUMENT: documents += 1 floor[y][x] = \u0026#39;.\u0026#39; elif space == Space.DOOR: if what.lower() in keys: floor[y][x] = \u0026#39;.\u0026#39; else: doors[what].add((x,y)) return elif space == Space.KEY: if what.upper() in doors: for x,y in doors[what.upper()]: paths.append({\u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y}) keys.add(floor[y][x].lower()) floor[y][x] = \u0026#39;.\u0026#39; paths.append({\u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y}) while (len(paths)): cur = paths.pop() # 중복 탐색 방지 if visited[cur[\u0026#39;y\u0026#39;]][cur[\u0026#39;x\u0026#39;]]: continue else: visited[cur[\u0026#39;y\u0026#39;]][cur[\u0026#39;x\u0026#39;]] = 1 for idx in range(4): curX = cur[\u0026#39;x\u0026#39;] + dx[idx] curY = cur[\u0026#39;y\u0026#39;] + dy[idx] if not checkRange(curX, curY): continue # 현재 자리 체크 what = floor[curY][curX] space = checkSpace(what) if space == Space.WALL: continue elif space == Space.DOCUMENT: documents += 1 floor[curY][curX] = \u0026#39;.\u0026#39; paths.append({\u0026#39;x\u0026#39;: curX, \u0026#39;y\u0026#39;: curY}) elif space == Space.DOOR: # 현재 갖고있는 키중에 해당하는 키가 있는지 체크 if what.lower() in keys: floor[curY][curX] = \u0026#39;.\u0026#39; visited[curY][curX] = 0 paths.append({\u0026#39;x\u0026#39;: curX, \u0026#39;y\u0026#39;: curY}) # 키를 갖고있지 않으면 열리지 않은 문 리스트에 추가 else: doors[what].add((curX,curY)) elif space == Space.KEY: if what.upper() in doors: for x,y in doors[what.upper()]: paths.append({\u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y}) keys.add(what) floor[curY][curX] = \u0026#39;.\u0026#39; visited[curY][curX] = 0 paths.append({\u0026#39;x\u0026#39;: curX, \u0026#39;y\u0026#39;: curY}) elif space == Space.EMPTY_SPACE: paths.append({\u0026#39;x\u0026#39;: curX, \u0026#39;y\u0026#39;: curY}) for _ in range(int(input())): height, width = map(int, input().split()) floor = [list(input()) for _ in range(height)] keys = set(input()) visited = [[0 for _ in row] for row in floor] documents = 0 doors = {} # 열리지 않은 문의 좌표를 담을 dictionary 변수 for door in \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;: doors.setdefault(door, set()) for i in range(height): for j in range(width): # visit only edge of the map if (i == 0 or i == height - 1 or j == 0 or j == width - 1): solve(i, j) print(documents) ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_9328/","summary":"문제 링크 문제 해결 맵에 있는 탐색 가능한 모든 문서의 갯수를 찾는 문제로, BFS를 이용하여 풀었다. 특이한 점은 주어진 열쇠로 맵에 있는 문을 열어서 이동할 수 가 있다는것인데, 열쇠를 맵을 탐색하면서 추가적으로 획득할 수 있기 때문에 이 부분을 유의하여 풀어야 한다.\n입력 for _ in range(int(input())): height, width = map(int, input().split()) floor = [list(input()) for _ in range(height)] keys = set(input()) visited = [[0 for _ in row] for row in floor] documents = 0 doors = {} # 열리지 않은 문 리스트 for door in \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;: doors.","title":"백준 9328 열쇠"},{"content":" 최근에 멀티미디어 관련 프로젝트를 진행하면서 GStreamer를 사용할 일이 생겼다. 간단하게 사용하기에는 알아야할 것들이나 개념들이 꽤나 많기 때문에 GStreamer를 사용하면서 정리한 내용들 및 추가적으로 학습한 내용들을 포스팅할 예정이다.\nGStreamer gstreamer overview Gstreamer는 스트리밍 미디어 어플리케이션 생성을 위한 통합 미디어 프레임워크로, 수많은 모듈형식으로 구성된 멀티미디어 프레임워크이다. 주로 오디오, 비디오 스트림등 다양한 데이터 프로토콜의 흐름을 설계할 수 있도록 도와준다. 예를들어 어떤 영상 파일을 rtsp클라이언트를(ex. VLC)이용해서 접근할 수 있도록 rtp 데이터 스트림을 생성하는 rtsp서버를 간단하게 구현할 수 있게 해준다.\nsource codecs formats fileters sinks FFmpeg와의 차이점 둘 다 멀티미디어 스트림을 처리하는 오픈소스 라이브러리로 차이점이 있다기보단 각 프레임워크가 가진 장점들이 있다. FFmpeg는 광범위한 수많은 코덱을 지원하고 다양한 기능을 제공하는 강력한 CLI도구가 있다. GStreamer는 프레임워크 아키텍처가 직관적이고 문서화가 잘되어있어 쉽게 멀티미디어 어플리케이션을 만들 수 있다는 장점이 있다. 실제로 영상 파일을 트랜스코딩을 할 일이 있을때는 FFmpeg CLI를 자주 사용하기도 한다.\n개인적으로 FFmpeg는 트랜스코딩 및 각종 필터를 통한 후처리등 간단한 작업이 필요할 때 명령어 도구로 사용할 때 적합한 것 같고, 특정 미디어 어플리케이션 형태를 만들어야 할 때는 GStreamer 프레임워크가 사용하기에 더 편리한것 같다고 생각한다.\n설치 방법 우분투 환경을 사용한다면 aptitude 패키지 매니저를 이용하여 설치하면 간단하다. 아래 명령어는 core 라이브러리, 각종 기본 플러그인들을 설치한다.\n$ sudo apt install \\ libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-bad1.0-dev \\ gstreamer1.0-plugins-base \\ gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-libav \\ gstreamer1.0-doc \\ gstreamer1.0-tools \\ gstreamer1.0-x \\ gstreamer1.0-alsa \\ gstreamer1.0-gl \\ gstreamer1.0-gtk3 \\ gstreamer1.0-qt5 \\ gstreamer1.0-pulseaudio 잘 살펴보면 플러그인 라이브러리 이름이 base, good, bad, ugly로 되어있는걸 볼 수 있는데, GStreamer에선 아래와 같이 정의하고 있다.\ngst-plugins-base: 핵심 플러그인 집합 gst-plugins-good: LGPL을 준수하는 양질의 플러그인 집합 gst-plugins-ugly: 배포문제를 일으킬 수도 있는 좋은 플러그인들 (라이선스 등) gst-plugins-bad: 더 높은 퀄리티를 요구하는 플러그인 집합 (문서, 유지보수등이 부실한 경우) gst-libav: libav 래퍼 플러그인 파이프라인 실행 및 예제 gst-launch는 파이프라인을 CLI로 테스트해볼 수 있는 디버깅 유틸리티로, 각 elements들을 느낌표로 구분하여 사용한다.\ngst-launch-1.0 videotestsrc ! autovideosink 커맨드를 실행하면 아래와 같은 colorbar 창이 뜨는것을 확인할 수 있다. source와 sink element만 사용한 간단한 파이프라인으로, videotestsrc는 테스트용 비디오 스트림을 생성해주는 source 플러그인이다. pattern property를 변경하여 패턴을 변경할 수 있다. autovideosink는 display sink의 한 종류로 사용가능한 적합한 video sink를 찾아 자동으로 연결해준다. 예를들어 gtk 인터페이스를 통해 display하고 싶다면 sink부분을 아래와 같이 바꿔준다.\ngst-launch-1.0 videotestsrc ! gtksink 위와 다르게 출력하는 영상은 같지만 gtk 인터페이스로 창을 생성한것을 볼 수 있다.\naudio 소스 추가하기 videotestsrc처럼 오디오도 테스트용 source element가 있다 (audiotestsrc). source를 추가할 때는 느낌표 구분자를 사용하면 구문 오류가 나니 주의한다.\ngst-launch-1.0 \\ videotestsrc ! autovideosink \\ audiotestsrc ! autoaudiosink 위 명령어를 실행하면, 기존의 colorbar창에 삐 소리가 나는것을 확인할 수 있다.\n파이프라인 구성요소 Elements Element는 파이프라인을 구성하는 추상화된 Block형태를 정의한다. 특정 source가 들어오고, 처리되고, 출력(sink)되는 black box같은 개념이라고 생각하면 된다.\nsource 예를들어 위 예제에서 사용한 videotestsrc같은 데이터 스트림을 생성하는 element는 1개의 src만 가지고 있는 반면에, 1개의 스트림을 N개의 source로 demulptimex하는 demuxer같은 element는 여러개의 source를 갖는다. demuxer Pads 각 elements를 연결하는 src와 sink를 GStreamer에서는 Pad라고 정의한다. Plug, Port같은 외부 인터페이스 개념이라고 생각하면 된다.\n각 Pad는 caps negotitation라고 불리는 과정을 통해 element끼리의 연결을 만든다.\nBins Bin은 elements의 집합인 컨테이너 단위이다. elements들 자체의 서브클래스 개념이며, 어플리케이션의 많은 복잡성을 추상화할 수 있게 한다. 이를테면, bin자체의의 상태를 변경함으로써 모든 elements의 상태를 변경한다. 또한 error, tag, EOS 메시지같은 각각이 포함하는 children으로부터의 메시징 버스를 전달하기도 한다.\nCommunication 어플리케이션과 파이프라인 사이의 데이터교환및 커뮤니케이션을 위한 메커니즘을 제공한다.\nbuffers: 파이프라인의 element들 사이의 스트리밍 데이터를 나아가게하는 객체이다. buffers는 항상 source → sink 방향으로 이동한다. (upstream → downstream) events: elements혹은 어플리케이션에서 elemets 사이의 전달된 객체이다. events는 upstream → downstream 방향으로 이동하고, downstream event는 데이터 흐름에 동기화될 수 있다. messageses: 파이프라인 메시징 버스에 의해 posted된 객체이다. 스트리밍 스레드 컨텍스트로부터 동기적으로 가로채질 수 있다. 하지만 주로 어플리케이션의 메인스레드로부터 어플리케이션에 의해 비동기적으로 다루어진다. error, tag, state change, buffering, redirecte 같은 정보를 전송하는데 사용된다. querires: 구간,재생위치같은 정보를 요청한다. 쿼리는 항상 동기적으로 응답된다. peer elements로부터 정보를 요청하기 위해 queries를 사용할 수도 있다. (file size 나 duration같은), 파이프라인내에서 둘 다 사용될 수 있지만, 보통은 upstream quires가 일반적이다. References https://gstreamer.freedesktop.org/documentation/application-development/introduction/gstreamer.html?gi-language=c ","permalink":"https://ralpioxxcs.github.io/post/gstreamer/0_gst/","summary":"최근에 멀티미디어 관련 프로젝트를 진행하면서 GStreamer를 사용할 일이 생겼다. 간단하게 사용하기에는 알아야할 것들이나 개념들이 꽤나 많기 때문에 GStreamer를 사용하면서 정리한 내용들 및 추가적으로 학습한 내용들을 포스팅할 예정이다.\nGStreamer gstreamer overview Gstreamer는 스트리밍 미디어 어플리케이션 생성을 위한 통합 미디어 프레임워크로, 수많은 모듈형식으로 구성된 멀티미디어 프레임워크이다. 주로 오디오, 비디오 스트림등 다양한 데이터 프로토콜의 흐름을 설계할 수 있도록 도와준다. 예를들어 어떤 영상 파일을 rtsp클라이언트를(ex. VLC)이용해서 접근할 수 있도록 rtp 데이터 스트림을 생성하는 rtsp서버를 간단하게 구현할 수 있게 해준다.","title":"GStreamer 사용하기 [1] - 파이프라인 구성요소 및 개념"},{"content":"애플에서 M1 프로세서를 출시하고 나서부터 ARM 아키텍처가 각광받고 있지만, 보통 ARM 아키텍처를 사용하는 환경은 저전력, 제한된 리소스를 사용하기 때문에 쾌적한 빌드환경을 갖추기가 어렵다. 보통은 이러한 제한때문에 대부분의 개발 작업을 x86환경에서 크로스 컴파일을 사용해 타겟 아키텍처에서 실행가능한 형태로 빌드한다.\n회사에서 raspberry PI 혹은 nvidia jetson 보드를 이용해 신제품을 프로토타이핑 하는 경우가 잦았는데, 타겟 보드에서 테스트를 하려고 할 때마다 빌드 시간이 너무 느려 답답한 경우가 많았다. 그래서 크로스 컴파일 환경을 한번 갖춰놓으니 빌드 시간도 단축시킬 수 있었고, CI 서버에도 크로스 컴파일 자동화를 적용하여 전체적인 개발 속도를 높일 수 있었다.\nabi, eabi? 크로스컴파일 툴체인을 설치하기 위해 검색하다 보면\naarch64-none-linux-** aarch64-linux-gnu-** aarch64-linux-gnueabi-** 등 여러 단어로 조합된 다양한 종류의 툴체인을 볼 수 있다.\n일반적으로 toolchain의 네이밍은 [arch]-[vendor]-(os-)abi의 형태로 이루어진다.\n예를들어 aarch64-none-linux-gnueabi라고 한다면 aarch64아키텍처를 사용하고, 특정 vendor가 없는 즉, bare-metal을 뜻하고, linux OS에 맞춘 eabi전용 toolchain을 뜻한다.\n마지막에 붙는 ABI 혹은 EABI는 Application Binary Interface의 줄임말로 직역하면 응용프로그램 이진 인터페이스이다. 간단하게 API가 소스코드 레벨에서의 호환성을 뜻한다면 ABI는 Low-level관점에서의 호환성을 뜻한다. EABI에서 E는 \u0026ldquo;Embedded\u0026ldquo;를 뜻하며, ARM에서 PowerPC등 임베디드 환경에 적합하도록 개정한 ABI표준을 뜻한다.\naarch64 툴체인 설치 우선 아래의 명령어로 aarch64 툴체인을 설치한다\n$ sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu ubuntu 18.04 버전 기준으로 gcc/g++ 7.5.0 버전이 설치된다.\n설치가 완료되었으면 아래처럼 툴체인에 포함된 파일을들 확인해볼수 있다.\n$ find /usr/bin -type f | grep aarch64 /usr/bin/aarch64-linux-gnu-gcc-ar-7 /usr/bin/aarch64-linux-gnu-readelf /usr/bin/aarch64-linux-gnu-ld.bfd /usr/bin/aarch64-linux-gnu-gcc-nm-7 /usr/bin/aarch64-linux-gnu-gcc-nm /usr/bin/aarch64-linux-gnu-cpp-7 /usr/bin/aarch64-linux-gnu-objcopy /usr/bin/aarch64-linux-gnu-g++-7 /usr/bin/aarch64-linux-gnu-gprof /usr/bin/aarch64-linux-gnu-gcc-ar /usr/bin/aarch64-linux-gnu-c++filt /usr/bin/aarch64-linux-gnu-objdump /usr/bin/aarch64-linux-gnu-gcc-7 /usr/bin/aarch64-linux-gnu-ranlib /usr/bin/aarch64-linux-gnu-gcov-tool /usr/bin/aarch64-linux-gnu-g++ /usr/bin/aarch64-linux-gnu-ld.gold /usr/bin/aarch64-linux-gnu-nm /usr/bin/aarch64-linux-gnu-gcov-7 /usr/bin/aarch64-linux-gnu-gcov /usr/bin/aarch64-linux-gnu-gcov-dump-7 /usr/bin/aarch64-linux-gnu-strip /usr/bin/aarch64-linux-gnu-ld /usr/bin/aarch64-linux-gnu-elfedit /usr/bin/aarch64-linux-gnu-size /usr/bin/aarch64-linux-gnu-as /usr/bin/aarch64-linux-gnu-gcov-tool-7 /usr/bin/aarch64-linux-gnu-gcc-ranlib-7 /usr/bin/aarch64-linux-gnu-gcov-dump /usr/bin/aarch64-linux-gnu-dwp /usr/bin/aarch64-linux-gnu-gcc-ranlib /usr/bin/aarch64-linux-gnu-cpp /usr/bin/aarch64-linux-gnu-addr2line /usr/bin/aarch64-linux-gnu-gcc /usr/bin/aarch64-linux-gnu-ar /usr/bin/aarch64-linux-gnu-strings 위의 툴체인이 정상적으로 설치가 되었다면 크로스 컴파일을 위한 모든 준비는 완료된 것이다.\n간단한 예제코드로 제대로 크로스 컴파일이 되는지 확인한다\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;; return 0; } $ g++ hello.cpp -o hello $ g++-aarch64-linux-gnu hello.cpp -o hello_aarch64 하나는 일반적인 g++, 다른 하나는 방금 설치한 g++-aarch64-linux-gnu로 빌드한다.\n두 파일을 file 커맨드로 비교해보면\n$ file hello hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=3fe43e50a35fbee86be5bf31079a9dac3977761b, not stripped $ file hello hello_aarch64: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.7.0, BuildID[sha1]=12564e9f3a43d6f629f3e89520bb95a7b375fff5, not stripped 각각 x86-64, aarch64 아키텍처에 맞게 빌드가 된 것을 볼수 있다. 당연하게도 aarch64로 빌드된 파일을 x86에서 실행시키려고 하면 아래 처럼 오류가 난다.\n-bash: ./hello_aarch64: cannot execute binary file: Exec 형식 오류 CMake 프로젝트에 적용하기 실제 프로젝트에서는 cmake,meson등 빌드 시스템으로 프로젝트가 복잡하게 구성돼있으므로, 위 처럼 명령어 한줄로 크로스 컴파일을 할 수는 없다.\ncmake는 크로스 컴파일을 구성하는데 도움을 주는 공식 문서를 제공한다. 문서에서 설명하는 방법을 통해 실제 프로젝트에서는 어떻게 크로스 컴파일을 적용해야할지 테스트를 해보자\n# the name of the target operating system set(CMAKE_SYSTEM_NAME Windows) # which compilers to use for C and C++ set(CMAKE_C_COMPILER i586-mingw32msvc-gcc) set(CMAKE_CXX_COMPILER i586-mingw32msvc-g++) # where is the target environment located set(CMAKE_FIND_ROOT_PATH /usr/i586-mingw32msvc /home/alex/mingw-install) # adjust the default behavior of the FIND_XXX() commands: # search programs in the host environment set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # search headers and libraries in the target environment set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) ","permalink":"https://ralpioxxcs.github.io/post/etc/cross_compilation_arm/","summary":"애플에서 M1 프로세서를 출시하고 나서부터 ARM 아키텍처가 각광받고 있지만, 보통 ARM 아키텍처를 사용하는 환경은 저전력, 제한된 리소스를 사용하기 때문에 쾌적한 빌드환경을 갖추기가 어렵다. 보통은 이러한 제한때문에 대부분의 개발 작업을 x86환경에서 크로스 컴파일을 사용해 타겟 아키텍처에서 실행가능한 형태로 빌드한다.\n회사에서 raspberry PI 혹은 nvidia jetson 보드를 이용해 신제품을 프로토타이핑 하는 경우가 잦았는데, 타겟 보드에서 테스트를 하려고 할 때마다 빌드 시간이 너무 느려 답답한 경우가 많았다. 그래서 크로스 컴파일 환경을 한번 갖춰놓으니 빌드 시간도 단축시킬 수 있었고, CI 서버에도 크로스 컴파일 자동화를 적용하여 전체적인 개발 속도를 높일 수 있었다.","title":"aarch64 크로스 컴파일 환경 구성하기"},{"content":"Logrus? golang에서 사용하는 대표적인 logging 패키지인 logrus는 stdout, stderr등 다양한 output 및 커스터마이징이 가능한 formatter등 구조화된 로깅을 지원한다.\n구조화된(structured) 로깅? 로그를 단순한 텍스트의 연속이 아닌 특정 데이터 세트(날짜, 사용자, 각종 필드)로 처리할 수 있도록 특정한 메시지 포맷을 구현하는 방식이다.\n기본 사용법 간단하게 콘솔창에 로그를 찍는 예제는 다음과 같다\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; log \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log.SetOutput(os.Stdout) log.SetFormatter(\u0026amp;log.TextFormatter{ FullTimestamp: true, TimestampFormat: time.RFC822, }) log.SetLevel(log.InfoLevel) log.Info(\u0026#34;Info message\u0026#34;) log.WithFields(log.Fields{ \u0026#34;name\u0026#34;: \u0026#34;Neymar\u0026#34;, \u0026#34;age\u0026#34;: 32, \u0026#34;club\u0026#34;: \u0026#34;PSG\u0026#34;, }).Info(\u0026#34;Info message with fields\u0026#34;) log.Debug(\u0026#34;Debug message\u0026#34;) log.SetLevel(log.DebugLevel) log.Info(\u0026#34;Info message\u0026#34;) log.Debug(\u0026#34;Debug message\u0026#34;) } INFO[07 Jun 22 23:08 KST] Info message INFO[07 Jun 22 23:54 KST] Info message with fields age=32 club=PSG name=Neymar INFO[07 Jun 22 23:08 KST] Info message DEBU[07 Jun 22 23:08 KST] Debug message 이외에 다양한 사용방법에 대해서는 logrus 공식레포에서 확인하도록 하자\nMultisink 로깅 개발을 하다보면 단순히 콘솔창뿐만 아니라 파일에 로그를 남겨야 할 경우가 있다. 당연하게도 logrus 패키지에서는 io.Writer를 파라미터로 받는 logrus.SetOutput를 사용하여 콘솔, 파일 둘 다 동시에 로깅을 할 수 있다.\nfile, err := os.OpenFile(\u0026#34;test.log\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0755) if err != nil { panic(err) } log.SetOutput(io.MultiWriter(os.Stdout, file)) 위 코드를 실행하게 되면 아래와 같은 출력과 로그파일을 볼수있다.\ntime=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=info msg=\u0026#34;Info message\u0026#34; time=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=info msg=\u0026#34;Info message\u0026#34; time=\u0026#34;07 Jun 22 23:21 KST\u0026#34; level=debug msg=\u0026#34;Debug message\u0026#34; 로깅 형식이 바뀐 이유 단순히 output을 바꿔주기만 했을뿐인데 로깅 포맷이 바뀌었다. 그 이유가 너무 궁금해서 패키지 내부 코드를 살펴보았다\nfunc (entry *Entry) write() { serialized, err := entry.Logger.Formatter.Format(entry) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Failed to obtain reader, %v\\n\u0026#34;, err) return } entry.Logger.mu.Lock() defer entry.Logger.mu.Unlock() if _, err := entry.Logger.Out.Write(serialized); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Failed to write to log, %v\\n\u0026#34;, err) } } logrus 내부에서 실질적으로 로깅을 하는 부분을 봤더니 formatting된 byte slice를 받아서 logger에 등록된 io.Writer을 통해 write를 하는부분을 볼수 있었다.\nf.terminalInitOnce.Do(func() { f.init(entry) }) timestampFormat := f.TimestampFormat if timestampFormat == \u0026#34;\u0026#34; { timestampFormat = defaultTimestampFormat } if f.isColored() { f.printColored(b, entry, keys, data, timestampFormat) } else { // ... 출력 형식이 바뀐 이유가 된 핵심 부분이다. logrus내부에서 각 formatter에 맞게 형식을 변환시키는데 기본 TextFormatter의 경우, isTerminal이라는 변수로 터미널 여부를 판단한다. f.isColored 의 조건에 맞으면 원했던 로깅 포맷을 출력하게 되어있다.\nisColored := f.ForceColors || (f.isTerminal \u0026amp;\u0026amp; (runtime.GOOS != \u0026#34;windows\u0026#34;)) isColored의 조건은 위와 같다. 따라서 Formatter의 옵션중 하나인 ForceColors를 true로 설정해주면 이 문제는 해결된다.\n아래에서 서술할 내용이지만, 터미널 출력이 아닐경우 color code값이 로그파일에 남게되어 지저분해지니까 위와 같은 처리를 한 것같다.\nForceColor 옵션의 문제점 \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message with fields \u001b[36mage\u001b[0m=32 \u001b[36mclub\u001b[0m=PSG \u001b[36mname\u001b[0m=Neymar \u001b[36mINFO\u001b[0m[08 Jun 22 00:35 KST] Info message \u001b[37mDEBU\u001b[0m[08 Jun 22 00:35 KST] Debug message ForceColors옵션을 주어 강제로 색상을 주고 로그파일을 보면 위와같이 콘솔에서 색상을 출력해주기위한 color code값이 그대로 적혀있다.\n로깅 자체에는 문제가 없지만 파일을 열어서 봤을때 보기도 힘들고 아무래도 뭔가 찝찝하다\u0026hellip; 그렇다고 DisableColors값을 false로 주어 위 color code값을 없애자니 콘솔창에서 색상 highlight가 되지 않는다.\n사실 로그파일을 읽을때 grep 으로 level keyword를 highlight를 하는 등의 특정 키워드를 highlight하는 방법은 여러가지가 있다.\n그래도 이렇게 마무리하면 아쉬울 것 같아서\n같은 로깅 포맷을 사용 콘솔에서는 highlight를 그대로 사용 파일 로깅시에는 color code값을 제거 위를 모두 만족하는 방법은 없을까 해서 열심히 구글링을 해보다가. 비슷한 문제로 issue가 올라온걸 보았다.\n답변을 요약하면 SetOutput(os.Stdout)은 그대로 적용해 coloring을 하고, 별도의 formatter를 갖는 Hook을 추가하는 방법으로 문제를 해결하는 방법을 말하고 있다.\nFile Hooking logrus는 hook기능을 제공하는데 hook을 이용해 지정된 곳에 한번에 로그를 남길 수 있다.\n우선 color code가 없는 형태의 custom formatter 인터페이스를 구현한다\ntype PlainFormatter struct { log.TextFormatter TimestampFormat string LevelDesc []string } func NewPlainFormatter() *PlainFormatter { return \u0026amp;PlainFormatter{ TimestampFormat: time.RFC3339, LevelDesc: []string{\u0026#34;PANC\u0026#34;, \u0026#34;FATL\u0026#34;, \u0026#34;ERRO\u0026#34;, \u0026#34;WARN\u0026#34;, \u0026#34;INFO\u0026#34;, \u0026#34;DEBG\u0026#34;}, } } func (f *PlainFormatter) Format(entry *log.Entry) ([]byte, error) { timestamp := fmt.Sprintf(\u0026#34;%v\u0026#34;, entry.Time.Format(f.TimestampFormat)) return []byte(fmt.Sprintf(\u0026#34;[%s] [%s] %s\\n\u0026#34;, f.LevelDesc[entry.Level], timestamp, entry.Message)), nil } 다음으로 file을 생성하는 Hook 인터페이스를 구현한다\ntype FileHook struct { Formatter logrus.Formatter Level []logrus.Level Writer io.Writer } func NewFileHook() log.Hook { file, err := os.OpenFile(\u0026#34;test.log\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0755) if err != nil { panic(err) } return \u0026amp;FileHook{ Formatter: NewPlainFormatter(), Level: []log.Level{ log.InfoLevel, }, Writer: file, } } func (h *FileHook) Fire(entry *log.Entry) error { bytes, err := h.Formatter.Format(entry) if err != nil { return err } h.Writer.Write(bytes) return nil } func (h *FileHook) Levels() []logrus.Level { return h.Level } 중요한 부분은 FileHook 구조체에 별도의 Formatter와 Writer를 설정하는것이다.\nbuilt-in formatter인 TextFormatter를 사용하지 않는 이유는 color code값을 제거하기 위해서다.\n위 설정을 모두 추가한 후, 실제 사용부분에서 log.AddHook(NewFileHook) 만 추가해주면 완성이다.\n실제 쓰여진 파일로그를 보면, WithFields를 사용한 로그는 적용되지 않는데, 그 부분은 PlainFormatter의 interface method인 Format()에서 별도로 처리해야 한다.\nReference https://github.com/sirupsen/logrus/issues/784 ","permalink":"https://ralpioxxcs.github.io/post/etc/logging/","summary":"Logrus? golang에서 사용하는 대표적인 logging 패키지인 logrus는 stdout, stderr등 다양한 output 및 커스터마이징이 가능한 formatter등 구조화된 로깅을 지원한다.\n구조화된(structured) 로깅? 로그를 단순한 텍스트의 연속이 아닌 특정 데이터 세트(날짜, 사용자, 각종 필드)로 처리할 수 있도록 특정한 메시지 포맷을 구현하는 방식이다.\n기본 사용법 간단하게 콘솔창에 로그를 찍는 예제는 다음과 같다\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; log \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log.SetOutput(os.Stdout) log.SetFormatter(\u0026amp;log.TextFormatter{ FullTimestamp: true, TimestampFormat: time.RFC822, }) log.SetLevel(log.InfoLevel) log.Info(\u0026#34;Info message\u0026#34;) log.","title":"Golang Logrus Hook을 이용한 mutisink 로깅"},{"content":"좌표 정규화 투영\n카메라 parameter를 알고 있다고 가정하고, normalized 좌표는 다음 계산식을 통해 영상 좌표로 변환된다.\n$$ x_{img} = x_{norm}*f_x + c_x \\newline y_{img} = y_{norm}*f_y + c_y $$\n반대로, 식을 바꿔 image plane 좌표 또한 normalized 좌표로 변환될 수 있다.\n$$ x_{norm} = (x_{img}-c_x)/f_x \\newline y_{norm} = (y_{img}-c_y)/f_y $$\nfx, fy는 focal length, 초점거리, cx,cy는 principal point 즉, 주점이라고 부른다. 이 요소들을 3x3 행렬로 만든것을 camera matrix 혹은 intrinsic paramter라고 한다.\n$$ \\begin{bmatrix} f_x \u0026amp; 0 \u0026amp; c_x \\newline 0 \u0026amp; f_y \u0026amp; c_y \\newline 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n3D-2D Projection 위에서 설명한 좌표계를 바탕으로 3차원의 월드 좌표가 2차원의 이미지 평면으로 projection 되는것을 아래와 같이 표현할 수 있다.\n$$ s {\\begin{bmatrix} u \\newline v \\newline 1 \\end{bmatrix}} = \\begin{bmatrix} f_x \u0026amp; 0 \u0026amp; c_x \\newline 0 \u0026amp; f_y \u0026amp; c_y \\newline 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} r_{11} \u0026amp; r_{12} \u0026amp; r_{13} \u0026amp; t_{1}\\newline r_{21} \u0026amp; r_{22} \u0026amp; r_{23} \u0026amp; t_{2}\\newline r_{31} \u0026amp; r_{32} \u0026amp; r_{33} \u0026amp; t_{3}\\ \\end{bmatrix}\\begin{bmatrix} X \\newline Y \\newline Z \\newline 1 \\end{bmatrix} \\newline(s = scale factor) $$\n위의 식을 간단히 표현하면 아래와 같다\n$$ s {\\begin{bmatrix} u \\newline v \\newline 1 \\end{bmatrix}} = K[R | t]\\begin{bmatrix} X \\newline Y \\newline Z \\newline 1 \\end{bmatrix} $$\n여기서 K 행렬을 카메라 내부 파라미터인 intrinsic parameter 라고 부르고,\n[R|t]를 행렬 카메라 외부 파라미터인 extrinsic parameter라고 부른다.\n내부 파라미터 (intrinsic) 내부 파라미터는 카메라 focal length 를 나타내는 fx,fy principal point를 나타내는 cx,cy 로 구성된다. 초점 거리는 렌즈의 중심과 이미지 센서 (CMOS)의 중심간의 거리를 뜻한다. 카메라 캘리브레이션에서 사용하는 초점 거리의 단위(unit)는 pixel 단위로 표현된다.\n$$ Fx = f_x * W/w \\newline Fy = f_y * H/h \\newline $$ (F : mm단위, f : pixel 단위, W,H : 이미지 센서 너비,높이 , w,h : 이미지 센서 픽셀 너비,높이)\n위의 관계식을 통해 실제 초점거리를 구할 수 있다.\nExample focal length 가 4.2mm 이고 image sensor의 크기가 1/2.9\u0026rsquo; 일때, pixel 단위는?\n1/2.9\u0026#39; 이미지 센서 - W: 4.96mm, H: 3.72mm - w: 728pix, h: 544pix f_x = (4.2mm * 728pix) / 4.96mm -\u0026gt; 약, 616pix f_y = (4.2mm * 544pix) / 3.72mm -\u0026gt; 약, 614pix 주점을 나타내는 cx, cy 는 렌즈의 중심점이 이미지 센서로 투영된 점을 뜻한다. 언뜻 영상의 중심점으로 해석될 수 있으나, 카메라 조립 과정중 이미지 센서와 렌즈가 수평을 이루지 못하면, 영상 중심점과 주점은 서로 다른 값을 가질 수 있다. 이 외에 비대칭 계수(skew coefficients)가 있지만, 무시할 만큼 작은 값이고 현대의 카메라에서는 skew가 없기 때문에 고려하지 않는다.\n외부 파라미터 (extrinsic) 카메라 좌표계와 월드 좌표계 사이의 변환 관계를 나타내는 파라미터로 두 가지 행렬로 구성된다.\nRotation matrix, 회전 Translation matrix, 평행이동 intrinsic parameter와는 달리 카메라의 position, posture의 변화에 따라 달라지는 값이므로, 고유한 값을 갖지 않는다.\n","permalink":"https://ralpioxxcs.github.io/post/etc/camera_calibration_2/","summary":"좌표 정규화 투영\n카메라 parameter를 알고 있다고 가정하고, normalized 좌표는 다음 계산식을 통해 영상 좌표로 변환된다.\n$$ x_{img} = x_{norm}*f_x + c_x \\newline y_{img} = y_{norm}*f_y + c_y $$\n반대로, 식을 바꿔 image plane 좌표 또한 normalized 좌표로 변환될 수 있다.\n$$ x_{norm} = (x_{img}-c_x)/f_x \\newline y_{norm} = (y_{img}-c_y)/f_y $$\nfx, fy는 focal length, 초점거리, cx,cy는 principal point 즉, 주점이라고 부른다. 이 요소들을 3x3 행렬로 만든것을 camera matrix 혹은 intrinsic paramter라고 한다.","title":"카메라 캘리브레이션 - 좌표변환"},{"content":"카메라 캘리브레이션 3차원의 장면이 카메라를 통해 2차원의 평면으로 구현될 때, 각각의 3차원 상의 점들은 카메라의 위치, 방향 같은 기하학적인 요소와 이미지 센서의 초점 거리, 렌즈의 왜곡 등 여러 내부적인 요소(parameters) 들에 의해 결정된다. 이 내부 요소들을 통해 렌즈의 왜곡, 3D상의 물체에 대한 크기 및 면적, 카메라의 위치등을 계산할 수 있으며, 이 값들을 구하는 과정을 카메라 캘리브레이션 이라고 부른다.\n좌표계 좌표계\n카메라 캘리브레이션에서는 주로 4가지의 좌표계가 사용된다\n월드 좌표계 (3D) 픽셀 좌표계 정규 좌표계 카메라 좌표계 월드 좌표계 사물의 위치를 나타내는 좌표계로 3차원(X,Y,Z)을 사용하는 좌표계이다. 목표로 하는 사물의 위치를 기준으로 잡아 사용할 수 있으며, X축 Y축 또한 기준 원점을 어디로 삼느냐에 따라 달라질 수 있다.\n$$ P = (X,Y,Z) $$\n카메라 좌표계 월드 좌표계와 비슷하지만 어떤 공간상의 한 지점이 아닌 카메라의 광학축을 기준으로 한 3차원 좌표계이다. 카메라 렌즈의 정면 방향을 Z축, 카메라 렌즈의 아래쪽이 Y축, 렌즈의 오른쪽 방향을 X축으로 잡는다. 월드 좌표계와 동일한 단위(unit)을 사용해야 한다.\n$$ P_c = (X_c,Y_c,Z_c) $$\n영상 좌표계 (Image coordinate) 영상에서 사용하는 좌표계로, 이미지의 좌상단을 원점으로 오른쪽 방향이 x축, 아래쪽이 y축인 2차원 좌표계이다. 월드 좌표계의 한 점 P 는 영상 좌표계 평면의 한 점 p 로 투영된다.\n$$ p_i = (x,y) $$\n정규 좌표계 (Normalized Image coordinate) 카메라 parameter의 영향을 받지 않는 정규화된 이미지 좌표계로, 카메라의 초점거리가(f) 1인 가상의 이미지 좌표계를 뜻한다. 이상적인 카메라 모델인 핀홀 카메라 모델 이 정의하는 좌표계와 같다. 각 카메라간의 서로 다른 parameter들의 종속성을 없애기 위해, 불필요한 요소가 제거된 정규화된 이미지 평면 좌표계를 사용한다.\n$$ p_n = (u,v) $$\n","permalink":"https://ralpioxxcs.github.io/post/etc/camera_calibration_1/","summary":"카메라 캘리브레이션 3차원의 장면이 카메라를 통해 2차원의 평면으로 구현될 때, 각각의 3차원 상의 점들은 카메라의 위치, 방향 같은 기하학적인 요소와 이미지 센서의 초점 거리, 렌즈의 왜곡 등 여러 내부적인 요소(parameters) 들에 의해 결정된다. 이 내부 요소들을 통해 렌즈의 왜곡, 3D상의 물체에 대한 크기 및 면적, 카메라의 위치등을 계산할 수 있으며, 이 값들을 구하는 과정을 카메라 캘리브레이션 이라고 부른다.\n좌표계 좌표계\n카메라 캘리브레이션에서는 주로 4가지의 좌표계가 사용된다\n월드 좌표계 (3D) 픽셀 좌표계 정규 좌표계 카메라 좌표계 월드 좌표계 사물의 위치를 나타내는 좌표계로 3차원(X,Y,Z)을 사용하는 좌표계이다.","title":"카메라 캘리브레이션 - 좌표계"},{"content":"Cgo Cgo는 Go에서 C언어를 사용할 수 있게해주는 Go의 feature중 하나이다. 이 기능을 이용해 C언어와 Go언어사이의 콜백함수를 만들어 볼 것이다. 주의할 점은 Cgo에서 읽을 수 있는것은 C스타일의 심볼을 갖는 함수 뿐이다. 순수 C언어로만 작성된 라이브러리라면 문제가 없겠지만 C++ 베이스의 함수를 이용하고 싶기 때문에 해당 함수를 한번 wrapping해주는 형태로 만들어 볼 것이다\n기본 사용법 함수를 wrapping 해보기 전, 기본적인 사용법을 다시 보자\npackage main /* #include \u0026lt;stdio.h\u0026gt; void CFoo() { printf(\u0026#34;Hello from C\\n\u0026#34;); } */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello from Go\u0026#34;) C.CFoo() } 출력결과는 다음과 같을 것이다\nHello from Go Hello from C C++ 함수 래핑 C++함수를 래핑하여 Go에서 호출하는 방법이다\n// foo.h #include \u0026lt;string\u0026gt; void Foo(std::string str); // ------------------------------------------------ // foo.cpp #include \u0026#34;foo.h\u0026#34; #include \u0026lt;iostream\u0026gt; void Foo(std::string str) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } 위의 함수를 가지는libfoo.so 라이브러리가 있다고 했을 때, Go에서 위 함수를 사용하기 위해선 Cgo에서 wrapper함수를 만들어 호출하는 방식을 사용하면 된다. Cgo에서는 C스타일의 심볼만 읽을 수 있기 때문에 래퍼함수의 헤더파일은 반드시 C 스타일로 작성하여야 한다.\n// fooWrapper.h #ifdef __cplusplus #define extern \u0026#34;C\u0026#34; { #endif void FooCgo(char* str); #ifdef __cplusplus } #endif // fooWrapper.cpp #include \u0026#34;fooWrapper.h\u0026#34; #include \u0026#34;foo.h\u0026#34; void FooCgo(char* str) { Foo(str); } // fooWrapper.go package fooWrapper /* #cgo CFLAGS: -I/path/to/cpp_lib #cgo CXXFLAGS: -I/path/to/cpp_lib #cgo LDFLAGS: -L/path/to/cpp_lib -lfoo #include \u0026#34;fooWrapper.h\u0026#34; */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func Foo() { fmt.Println(\u0026#34;Hello from Go\u0026#34;) C.FooCgo(C.CString(\u0026#34;Hello from Cgo\u0026#34;)) } 출력결과 Hello from Go Hello from Cgo 소스 파일에서 foo.h를 인클루드하고, libfoo.so의 함수Foo()를 호출해주면 된다. 중요한 점은 Cgo에서 컴파일 될 수 있도록 extern \u0026quot;C\u0026quot;키워드를 사용하는 것이다.\nGo콜백함수 부르기 그렇다면, Go함수에서 콜백함수를 정의하고 그 함수를 C언어에서 콜백함수를 등록하는 방법이 있을까? Cgo에서는 export를 사용하여 Go로 작성된 함수를 C언어 심볼로 export할 수 있다.\n// foo.h #include \u0026lt;functional\u0026gt; using callbackFn = std::function\u0026lt;void(int a)\u0026gt;; void DoSomething(callbackFn fn) // ------------------------------------------------ // foo.cpp #include \u0026#34;foo.h\u0026#34; #include \u0026lt;iostream\u0026gt; void DoSomething(callbackFn fn) { std::cout \u0026lt;\u0026lt; \u0026#34;foo::DoSomething()\u0026#34; \u0026lt;\u0026lt; std::endl; fn(7); } 위 형태의 콜백함수를 인자로 갖는 호출하는 함수가 있다고 해보자, 우리는 위에서 CPP함수를 래핑하는 방법을 통해서 CPP함수를 호출할 수 있었다. 그리고 Go에서 작성된 콜백함수를 DoSomething()함수의 함수포인터로 보내고 싶다고 하자\n// fooWrapper.h #ifdef __cplusplus #define extern \u0026#34;C\u0026#34; { #endif typedef void(*callbackFnCGO)(int a); void DoSomethingCGO(callbackFnCGO fn) #ifdef __cplusplus } #endif 아까 했던 방법과 같은 방식으로 DoSomething()래퍼 함수를 만들고, C스타일 자료형 지정자 typedef 키워드로 콜백함수 형식을 만든다.\n// fooWrapper.go package wrapper /* #cgo CFLAGS: -I/path/to/cpp_lib #cgo CXXFLAGS: -I/path/to/cpp_lib #cgo LDFLAGS: -L/path/to/cpp_lib -lfoo #include \u0026#34;fooWrapper.h\u0026#34; void myCallback(int a); */ import \u0026#34;C\u0026#34; func DoSomething() { C.DoSomethingCGO(C.callbackFnCGO(C.myCallback)) } //export myCallback func myCallback(a C.int) { fmt.Printf(\u0026#34;callback from go context (%v)\\n\u0026#34;, int(a)) } (예제 코드 보기)\nGo에서 콜백함수를 작성하고 주석으로 //export [함수이름]의 형태로 작성한다. Cgo에서 이 부분을 보고 C함수심볼로 만들어주고 그것을 코드내에서 C.[export한 함수이름]로 사용할 수 있다. 그 함수를 래핑함수의 파라미터로 넘겨주면 된다. 주의할 점은 //와 export사이에 공백이 있으면 안된다. 이 점을 유의하여 삽질하지 않도록 주의하자..\n출력결과 foo::DoSomething() callback from go context (7) c/c++ 베이스로 작성된 라이브러리가 있고, 해당 라이브러리를 사용하는 REST API, GraphQL등의 서버 어플리케이션을 만들어야 할 때 자주 사용하는 방법인데 함수를 래핑하는 방법이 약간 노가다성이 있기도 하지만.. 생산성 및 효율성 등을 고려하면 사용하는 방법만 알아두면 유용하게 쓰일 수 있을 것 같다.\n","permalink":"https://ralpioxxcs.github.io/post/etc/cgo_callback/","summary":"Cgo Cgo는 Go에서 C언어를 사용할 수 있게해주는 Go의 feature중 하나이다. 이 기능을 이용해 C언어와 Go언어사이의 콜백함수를 만들어 볼 것이다. 주의할 점은 Cgo에서 읽을 수 있는것은 C스타일의 심볼을 갖는 함수 뿐이다. 순수 C언어로만 작성된 라이브러리라면 문제가 없겠지만 C++ 베이스의 함수를 이용하고 싶기 때문에 해당 함수를 한번 wrapping해주는 형태로 만들어 볼 것이다\n기본 사용법 함수를 wrapping 해보기 전, 기본적인 사용법을 다시 보자\npackage main /* #include \u0026lt;stdio.h\u0026gt; void CFoo() { printf(\u0026#34;Hello from C\\n\u0026#34;); } */ import \u0026#34;C\u0026#34; import \u0026#34;fmt\u0026#34; func main() { fmt.","title":"C/C++ \u003c-\u003e Go 콜백함수 구현하기"},{"content":"배경 최근에 간단한 쉘 스크립트 하나를 짜면서 겪은 문제가 하나 있다. ssh로 연결된 특정 보드의 이더넷 네트워크 인터페이스의 설정을 변경해주는 작업이었다. 적용할 보드가 한두개가 아니라서 해당 작업을 간편하게 하기위해서 HOST(노트북)에서 해당 작업을 수행하는 스크립트를 실행시키면 ssh를 통해 보드내 설정을 바꿔주도록 했다. 딱히 어려울것 없는 작업이라 sshpass, scp, ssh, sed 명령어 조합을 사용하였다.\n로컬 터미널에서 위의 명령어들을 쓰면서 잘 바뀌는것을 확인했고 그 로직을 그대로 쉘 스크립트를 작성하였다\u0026hellip; 하지만 문제는 로컬 터미널에서만 테스트 한 점이었다.\n# copy scp -o StrictHostKeyChecking=no config.yaml user@1.1.1.1:~ # change ssh -o StrictHostKeyChecking=no user@1.1.1.1 \\ \u0026#34;`export mac_addr=`cat /sys/class/net/eth0/address`` \u0026amp;\u0026amp; sed -i \u0026#39;s/mac_addr/\u0026#39;\u0026#34;${mac_addr}\u0026#34;\u0026#39;/g\u0026#39; ~/config.yaml\u0026#34; 내용은 대략 이러했다.\n템플릿 config 파일을 보드로 복사 해당 보드의 Mac address를 환경변수로 저장 sed 명령어로 템플릿 config 파일의 특정 문자열을 치환 하지만 저 상태로 스크립트를 실행하면 ${mac_addr} 부분이 스크립트를 실행한 로컬 터미널의 환경변수를 참조하게 되므로 공백값이 들어가게된다. quote 문자를 제대로 쓰지못해서 일어난것임을 깨닫고 bash에서의 double, single quote의 차이점을 알아봤다.\n(`,\u0026quot;,\u0026lsquo;의 쓰임새를 제대로 알지 못하고 중구난방으로 쓴것을 볼 수 있다..)\nbash에서의 \u0026ldquo;, \u0026rsquo; 기능 그렇다면 Bash에서 double quote(\u0026quot;)와 single quote(\u0026rsquo;)의 차이점은 무엇일까??\n아주 간단한 예시가 있다.\n$ echo \u0026#34;$(echo \u0026#34;hi\u0026#34;)\u0026#34; -\u0026gt; hi $ echo \u0026#39;$(echo \u0026#34;hi\u0026#34;)\u0026#39; -\u0026gt; $(echo \u0026#34;hi\u0026#34;) 보이는것처럼 double quote로 감싸진 문장은 $(echo \u0026quot;hi\u0026quot;)가 명령어로 확장된다. 하지만 single quote로 감싸진 문장은 명령어로 확장되지않고, 문자열(literal value) 그 자체를 보존한다.\n정확히는 double quote(\u0026quot;)는 명령어의 결과를 변수로 저장할 때 보통 많이 쓰는 $,`, \\ 문자를 제외한 모든 문자를 보존한다.\n수정 따라서 위의 스크립트가 본래 목적을 수행하도록 특정 부분을 수정했다.\n$(cat /sys/class/...) 부분이 명령어로 치환되지않고 문자열 그대로 전달되도록 sed -i 's/.../${MAC_ADDR}/g' 부분의 환경변수가 치환되지않고 그대로 전달되도록 결론 방법은 여러가지가 있다. 수행할 명령어들을 모두 로컬변수로 담아서 문자열 그대로 전달할수도 있고, '로 시작해서 \u0026amp;\u0026amp;를 이용해 여러 명령어를 붙여 한 명령어의 문자열로 모두 담아서 보내버릴수도 있다. 하지만 괜히 이상하게 오기가 생겨서 원래 하려던 방법으로 나름의 챌린징(삽질)을 했다..\n","permalink":"https://ralpioxxcs.github.io/post/etc/double_vs_single_quote/","summary":"배경 최근에 간단한 쉘 스크립트 하나를 짜면서 겪은 문제가 하나 있다. ssh로 연결된 특정 보드의 이더넷 네트워크 인터페이스의 설정을 변경해주는 작업이었다. 적용할 보드가 한두개가 아니라서 해당 작업을 간편하게 하기위해서 HOST(노트북)에서 해당 작업을 수행하는 스크립트를 실행시키면 ssh를 통해 보드내 설정을 바꿔주도록 했다. 딱히 어려울것 없는 작업이라 sshpass, scp, ssh, sed 명령어 조합을 사용하였다.\n로컬 터미널에서 위의 명령어들을 쓰면서 잘 바뀌는것을 확인했고 그 로직을 그대로 쉘 스크립트를 작성하였다\u0026hellip; 하지만 문제는 로컬 터미널에서만 테스트 한 점이었다.","title":"쉘 스크립트 삽질"},{"content":"WSL 메모리 사용량 wsl2을 사용하다가 메모리 사용량을 체크 해보면 Vmmem 이라는 놈이 메모리를 엄청 잡아먹고 있는걸 볼 수있다. 마소 공식 document에 따르면 총 메모리의 50퍼센트 혹은 특정 빌드 전 단계에서는 총 메모리의 무려 80퍼센트를 사용한다고 한다.\n50% of total memory on Windows or 8GB, whichever is less; on builds before 20175: 80% of your total memory on Windows\nconfig 파일 작성 다행히도 .wslconfig라는 파일을 사용해서 WSL 설정을 바꿀 수 있다. 아래는 설정 파일의 예시이다.\n[wsl2] memory=4GB processors=2 swap=1GB localhostForwarding=true 위처럼 파일을 작성하고 .wslconfig 이름으로 %USERPROFILE% 경로에 저장해준다. Powershell을 실행시켜 wsl --shutdown 명령어로 강제종료 후, WSL2을 재실행하면 설정이 적용된다.\n결과 적용 전 적용 후 htop으로 리소스 사용량을 체크해보니 .wslconfig에 작성한 대로 설정값이 적용이 된 모습을 볼 수 있었다.\nReference https://github.com/microsoft/terminal/issues/2743 https://docs.microsoft.com/ko-kr/windows/wsl/wsl-config#configuration-options ","permalink":"https://ralpioxxcs.github.io/post/etc/wsl_config/","summary":"WSL 메모리 사용량 wsl2을 사용하다가 메모리 사용량을 체크 해보면 Vmmem 이라는 놈이 메모리를 엄청 잡아먹고 있는걸 볼 수있다. 마소 공식 document에 따르면 총 메모리의 50퍼센트 혹은 특정 빌드 전 단계에서는 총 메모리의 무려 80퍼센트를 사용한다고 한다.\n50% of total memory on Windows or 8GB, whichever is less; on builds before 20175: 80% of your total memory on Windows\nconfig 파일 작성 다행히도 .wslconfig라는 파일을 사용해서 WSL 설정을 바꿀 수 있다. 아래는 설정 파일의 예시이다.","title":"WSL2 메모리 사용량 조절"},{"content":"push_back 과 emplace_back 둘 다 실질적으로 수행하는 일은 \u0026ldquo;컨테이너의 끝에 요소를 추가하는것\u0026rdquo; 로 동일하다. 하지만 두 함수를 memory allocation 관점에서 보면 emplace_back 이 훨씬 효율적으로 작동한다.\npush_back 이 호출될 때 객체 관점에서 순서는 다음과 같다.\nStack 영역에 생성자를 호출 하면서 임시객체(temporary object)가 할당 된다. 복사 생성자(copy constructor) 혹은 이동 생성자 통해 함수 안에서 또 하나의 temporay object를 생성한다. 생성된 temporary object를 벡터 컨테이너의 끝에 추가한다. 1번의 임시객체가 소멸된다. 이렇게, push_back 함수는 \u0026ldquo;객체\u0026rdquo; 자체를 집어넣는 방식으로, R-value의 임시객체가 필요하다. 단순히 하나의 객체를 추가하는 단순한 연산임에도 불구하고, 객체의 생성과 파괴가 한번 이루어진다.\n그에 반해서, emplace_back 는 direct하게 함수 내에서 임시객체를 생성과 이동을 통해 element를 생성한다. 다시말해, 불필요한 임시객체의 생성과 파괴 과정없이 효율적으로 벡터 element를 추가한다.\nExample #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; class Foo { public: Foo() = default; Foo(const std::string name, const int age) : m_name(name), m_age(age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo()\u0026#34; \u0026lt;\u0026lt; std::endl; } // declare copy constructor explicitly Foo(const Foo\u0026amp; rhs) : m_name(rhs.m_name), m_age(rhs.m_age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo() copy\u0026#34; \u0026lt;\u0026lt; std::endl; } // declare move constructor explicitly Foo(const Foo\u0026amp;\u0026amp; rhs) : m_name(rhs.m_name), m_age(rhs.m_age) { std::cout \u0026lt;\u0026lt; \u0026#34;Foo() move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Foo() { std::cout \u0026lt;\u0026lt; \u0026#34;~Foo()\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string m_name; int m_age; }; int main(int argc, char* argv[]) { std::vector\u0026lt;Foo\u0026gt; foovec; foovec.reserve(2); std::cout \u0026lt;\u0026lt; \u0026#34;emplace back\u0026#34; \u0026lt;\u0026lt; std::endl; foovec.emplace_back(\u0026#34;tom\u0026#34;, 63); std::cout \u0026lt;\u0026lt; \u0026#34;------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;push back\u0026#34; \u0026lt;\u0026lt; std::endl; foovec.push_back(Foo(\u0026#34;chris\u0026#34;, 44)); std::cout \u0026lt;\u0026lt; \u0026#34;------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } Result 예상했던것처럼, push_back 함수는 객체의 생성, 이동, 소멸이 되었지만, emplace_back 의 경우 객체가 생성만 된것을 확인할 수 있다.\nBenchmark #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; int main(int argc, char* argv[]) { std::vector\u0026lt;Foo\u0026gt; foovec; std::size_t count = std::atoi(argv[2]); foovec.reserve(count); if (argv[1] == std::string(\u0026#34;push_back\u0026#34;)) { auto t1 = std::chrono::high_resolution_clock::now(); for (std::size_t idx = 0; idx \u0026lt; count; idx++) { foovec.push_back(Foo(\u0026#34;blank\u0026#34;, 1)); } auto t2 = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; fp_ms = t2 - t1; std::cout \u0026lt;\u0026lt; \u0026#34;duration : \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; std::endl; } else if (argv[1] == std::string(\u0026#34;emplace_back\u0026#34;)) { auto t1 = std::chrono::high_resolution_clock::now(); for (std::size_t idx = 0; idx \u0026lt; count; idx++) { foovec.emplace_back(\u0026#34;blank\u0026#34;, 1); } auto t2 = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; fp_ms = t2 - t1; std::cout \u0026lt;\u0026lt; \u0026#34;duration : \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; std::endl; } return 0; } 1000만개의 elements를 추가하는 간단한 벤치마킹 코드를 돌려봤을때, emplace_back이 push_back보다 약 7ms정도 미세하게 빠르다는것을 확인할 수 있었다.\npush_back 을 언제 사용해야하는가 그렇다면, 모든 push_back 을 emplace_back으로 바꾸면 되는것일까? 라고 생각이 들 수 있다. 하지만 아래의 또 다른 예제를 보면 그렇지 않다는것을 알 수 있다.\nv.push_back(10000); v.emplace_back(10000); 위의 코드만 봤을때, push_back의 경우 명확하다. 숫자 10000을 vector에 추가한다는것을 나타내지만, emplace_back의 경우 확실히 알 수 없다.\n만약 vector가 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; 의 형태인 경우, 10000개의 요소를 메모리에 할당하게 된다. push_back을 사용했을 경우 compile error를 통해 compile 시점에 개발자가 인지하고 고칠 수 있지만, emplace_back의 경우 개발자가 의도하지 않은 결과를 초래하게 될 수도 있다.\n결론 위의 벤치마크 코드에서도 확인하였듯이 추가해야 할 element 객체의 크기가 엄청 큰 경우 혹은 performance critical한 경우가 아니라면, 명시적인 타입의 push_back을 사용하여 explicit하고, safety한 코드를 작성하는것도 하나의 방법이라고 생각한다.\nReference https://abseil.io/tips/112 https://en.cppreference.com/w/cpp/container/vector ","permalink":"https://ralpioxxcs.github.io/post/cpp/stdvector/","summary":"push_back 과 emplace_back 둘 다 실질적으로 수행하는 일은 \u0026ldquo;컨테이너의 끝에 요소를 추가하는것\u0026rdquo; 로 동일하다. 하지만 두 함수를 memory allocation 관점에서 보면 emplace_back 이 훨씬 효율적으로 작동한다.\npush_back 이 호출될 때 객체 관점에서 순서는 다음과 같다.\nStack 영역에 생성자를 호출 하면서 임시객체(temporary object)가 할당 된다. 복사 생성자(copy constructor) 혹은 이동 생성자 통해 함수 안에서 또 하나의 temporay object를 생성한다. 생성된 temporary object를 벡터 컨테이너의 끝에 추가한다. 1번의 임시객체가 소멸된다. 이렇게, push_back 함수는 \u0026ldquo;객체\u0026rdquo; 자체를 집어넣는 방식으로, R-value의 임시객체가 필요하다.","title":"push_back vs. emplace_back"},{"content":"이번에는 neovim에서 coc.nvim를 이용하여 C/C++ 개발환경을 세팅하는 방법에 대해서 알아보겠다.\ncoc.nvim은 Language Server Protocol인 LSP를 지원하는 코드 auto-completion 패키지인데 이전에는 ycm을 사용하다가 너무 무겁기도 하고 개인적으로 환경설정 부분에 불편함 점이 있어 coc.nvim을 사용하게 되었다.\ncoc.nvim 설치 vim-plug 설정부분에 아래를 추가해준뒤, :PlugInstall을 해준다.\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;tag\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;do\u0026#39;: \u0026#39;./install.sh\u0026#39;} 참고로, node.js 10.12 버전 이상이 설치되어있어야 한다. node.js가 설치되어있지 않다면 여기를 참고하여 다운로드 및 설치를 진행해주자.\ncpp language server 설치 이곳을 보면 C/C++ language server에 맞는 configuration example을 제공한다.\nclangd, coc-clangd, ccls, cquery등이 여러 language server 패키지가 있지만, 이 포스팅에서는 ccls를 설정하는 방법을 다룰것이다.\nccls를 사용하려면 직접 빌드를 해주어야하는데, ccls는 다음의 패키지를 필요로 한다.\nCMake 3.8 버전 이상 C++17을 지원하는 컴파일러 clang \u0026gt;=5 gcc \u0026gt;=7.2 clang+llvm \u0026gt;=7 의 include와 lib clagn+llvm 의 include와 lib를 저장하고있는 폴더가 없거나 경로지정이 애매하다면, 여기에서 pre-built binaries를 다운로드 한뒤, 특정 폴더에다 해제를 한다.\n위의 조건을 모두 만족한다면 빌드 준비가 모두 완료된것이므로, ccls repository를 clone후 아래 명령어를 따라 빌드한다.\ngit clone --depth=1 --recursive https://github.com/MaskRay/ccls cd ccls cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-xxx # clang pre-built binaries 폴더 cmake --build Release wget 커맨드를 이용하는 방법도 있다.\nwget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release 빌드가 끝났다면, 아래 명령어로 설치를 완료한다.\n만약 설치경로를 변경하고 싶다면 CMakeCache.txt파일을 수정하여 CMAKE_INSTALL_PREFIX에 원하는 경로를 입력한다.\ncmake --build Release --target install coc config 빌드 및 설치가 완료되었다면, coc.nvim에서 ccls를 사용할 수 있도록 config파일을 수정할 차례이다.\nconfig파일을 수정하는 방법은 두가지 방법이 있다.\n$HOME/.config/nvim 경로에 coc-setting.json을 파일을 만들어 작성 vim을 실행한뒤 :CoCConfig명령어를 입력 두 방법 모두 결국엔 같은 파일을 수정하는것이긴 하다.\nExample { \u0026#34;languageserver\u0026#34;: { \u0026#34;ccls\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;ccls\u0026#34;, \u0026#34;filetypes\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;cpp\u0026#34;], \u0026#34;rootPatterns\u0026#34;: [\u0026#34;.ccls\u0026#34;, \u0026#34;compile_commands.json\u0026#34;], \u0026#34;initializationOptions\u0026#34;: { \u0026#34;cache\u0026#34;: { \u0026#34;directory\u0026#34;: \u0026#34;.ccls-cache\u0026#34; }, \u0026#34;client\u0026#34;: { \u0026#34;snippetSupport\u0026#34; : true }, \u0026#34;compilationDatabaseDirectory\u0026#34;: \u0026#34;./build/\u0026#34; } } } } ccls는 rootPatterns에 명시된 파일의 패턴을 기준으로 project전체를 indexing하여 정보를 제공한다. 이 패턴 파일을 생성하는 방법은 2가지가 있다.\ncompile_commands.json 파일을 사용하는 방법 .ccls파일을 직접 만들어 사용하는 방법 보통 CMake같은 build system generator를 통해 compile_commands.json파일을 자동적으로 생성할 수 있으므로, 1번 방법을 사용하는편이 간단하다.\n아래와 같이 cmake configuration arguments로 파일을 만들고, project root폴더에서 해당 파일을 심볼릭링크를 해준다.\nmkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .. cd .. ln -s build/compile_commands.json . 추가로 compilationDatabaseDirectory 옵션을 통해 compile_commands.json 파일의 경로를 설정해주면 심볼릭 링킹을 일일이 해주지 않아도 된다.\nReference https://github.com/MaskRay/ccls/wiki/coc.nvim ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_3/","summary":"이번에는 neovim에서 coc.nvim를 이용하여 C/C++ 개발환경을 세팅하는 방법에 대해서 알아보겠다.\ncoc.nvim은 Language Server Protocol인 LSP를 지원하는 코드 auto-completion 패키지인데 이전에는 ycm을 사용하다가 너무 무겁기도 하고 개인적으로 환경설정 부분에 불편함 점이 있어 coc.nvim을 사용하게 되었다.\ncoc.nvim 설치 vim-plug 설정부분에 아래를 추가해준뒤, :PlugInstall을 해준다.\nPlug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;tag\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;do\u0026#39;: \u0026#39;./install.sh\u0026#39;} 참고로, node.js 10.12 버전 이상이 설치되어있어야 한다. node.js가 설치되어있지 않다면 여기를 참고하여 다운로드 및 설치를 진행해주자.\ncpp language server 설치 이곳을 보면 C/C++ language server에 맞는 configuration example을 제공한다.","title":"Vim 사용하기 #3 - C/C++ 개발환경 세팅"},{"content":"보통 로그파일 실시간으로 보고싶을때 tail 명령어를 사용한다. 하지만 여러 로그를 보고싶을때는 tmux등 화면 분할을 해서 봐야하는데 이 방법은 귀찮다. 이럴때 multitail을 사용하면 간단하게 여러 로그를 모니터링할수 있다.\n설치 apt install multitail을 입력하여 간단하게 설치한다. 맥 유저라면 brew install multitai을 쓴다.\n사용법 1개의 파일 모니터링\nmultitail [filename]\n2개의 파일 모니터링 (가로로 분할)\nmultitail [filename] [filename] 2개의 파일 모니터링 (세로로 분할)\nmultitail -s 2 [filename] [filename] colorscheme 설정 multitail은 자체 config파일을 통해 로그파일 highlighting을 지원한다.\n/usr/local/etc/ 경로에 기본 파일이 있고, 기본적으로 syslog, apache등의 여러가지 colorscheme들이 있다.\n기본 명령어에 -cS 옵션을 추가하여 사용하면 된다.\nmultitail -cS [colorscheme] [logfile] 공식문서에 따르면 /etc/multitail.conf에 파일이 있다면 적용이 된다고 하는데, 계속 -cS 옵션을 줘도 colorscheme을 찾을수 없다고 하면서 오류가 났다\n구글링을 해보니까 .multitailrc 라는 파일을 홈 경로에 만들어주면 된다고 해서 해봤더니 바로 적용이 되었다. 대신 multitail.conf을 참고하여 사용할 colorscheme만 복사해서 사용해야 한다.\nmutitailrc 예시 colorscheme:syslog:kernel and unsorted messages # segfaults cs_re_s:red,,bold:kernel: ([^:]*): segfault at [^ ]* rip [^ ]* rsp [^ ]* error cs_re:yellow:kernel: .*: segfault at [^ ]* rip [^ ]* rsp [^ ]* error # misc cs_re:red,,inverse/underline:kernel cs_re:green:Detected.*$ cs_re:green:\\[ cs_re:green:\\] cs_re:cyan:: cs_re:blue|blue,,bold:^... .. ..:..:.. cs_re_s:,,bold:^... .. ..:..:.. [^ ]* ([A-z0-9]*) cs_re:red:scanlogd.* cs_re:yellow:Did.not 또한 정규표현식을 지원하므로 자신만의 custom colorscheme을 만들수도 있다.\n예를들어 info, debug, warning등 로그에 사용되는 특정필터들에 색깔을 입혀보고 싶다면, 다음과 같이 설명하면 된다.\n# test colorscheme:test # date cs_re:magenta,,bold: *[a-z]*[0-9]+[a-z]* # filter cs_re:cyan,,bold:\u0026lt;trace\u0026gt; cs_re:green,,bold:\u0026lt;info\u0026gt; cs_re:magenta,,bold:\u0026lt;debug\u0026gt; cs_re:yellow,,bold:\u0026lt;warning\u0026gt; cs_re:red:\\[ cs_re:red:\\] multitial -cS test file.log -l \u0026quot;ping 8.8.8.8\u0026quot;를 입력한 결과 ","permalink":"https://ralpioxxcs.github.io/post/etc/log_monitoring/","summary":"보통 로그파일 실시간으로 보고싶을때 tail 명령어를 사용한다. 하지만 여러 로그를 보고싶을때는 tmux등 화면 분할을 해서 봐야하는데 이 방법은 귀찮다. 이럴때 multitail을 사용하면 간단하게 여러 로그를 모니터링할수 있다.\n설치 apt install multitail을 입력하여 간단하게 설치한다. 맥 유저라면 brew install multitai을 쓴다.\n사용법 1개의 파일 모니터링\nmultitail [filename]\n2개의 파일 모니터링 (가로로 분할)\nmultitail [filename] [filename] 2개의 파일 모니터링 (세로로 분할)\nmultitail -s 2 [filename] [filename] colorscheme 설정 multitail은 자체 config파일을 통해 로그파일 highlighting을 지원한다.","title":"multitail을 이용한 로그 모니터링"},{"content":"문제 링크 문제 해결 단순 정렬 문제, 각 배열 원소들의 곱 S가 최솟값이 나와야하므로, 큰 수와 작은 수 끼리 곱해주면 된다.\nA는 오름차순 정렬, B는 내림차순 정렬을 한 뒤, 반복문을 이용하여 해결\nCode a = [] b = [] n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) a = sorted(a, reverse=True) b = sorted(b) sum = 0 for i in range(n): sum += a[i] * b[i] print(sum) ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_1026/","summary":"문제 링크 문제 해결 단순 정렬 문제, 각 배열 원소들의 곱 S가 최솟값이 나와야하므로, 큰 수와 작은 수 끼리 곱해주면 된다.\nA는 오름차순 정렬, B는 내림차순 정렬을 한 뒤, 반복문을 이용하여 해결\nCode a = [] b = [] n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) a = sorted(a, reverse=True) b = sorted(b) sum = 0 for i in range(n): sum += a[i] * b[i] print(sum) ","title":"백준 1026 보물"},{"content":"문제 링크 문제 해결 정수 M개의 입력이 50만개이기때문에 단순 순차 탐색으로는 시간초과가 나온다. 숫자 카드 배열을 먼저 정렬한 후 binary search를 이용하여 해결하였다.\nCode # binary search def search(key, left, right): mid = (left + right) // 2 # 종료 조건 if cards[mid] == key: return True if left \u0026gt; right: return False if key \u0026gt; cards[mid]: return search(key, mid+1, right) elif key \u0026lt; cards[mid]: return search(key, left, mid-1) n = int(input()) cards = sorted(list(map(int, input().split()))) # binary search를 위해 선 정렬 m = int(input()) checks = list(map(int, input().split())) answers = [] for c in checks: if search(c, 0, n-1): answers.append(\u0026#39;1 \u0026#39;) else: answers.append(\u0026#39;0 \u0026#39;) print(\u0026#39;\u0026#39;.join(answers)) ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_10815/","summary":"문제 링크 문제 해결 정수 M개의 입력이 50만개이기때문에 단순 순차 탐색으로는 시간초과가 나온다. 숫자 카드 배열을 먼저 정렬한 후 binary search를 이용하여 해결하였다.\nCode # binary search def search(key, left, right): mid = (left + right) // 2 # 종료 조건 if cards[mid] == key: return True if left \u0026gt; right: return False if key \u0026gt; cards[mid]: return search(key, mid+1, right) elif key \u0026lt; cards[mid]: return search(key, left, mid-1) n = int(input()) cards = sorted(list(map(int, input().","title":"백준 10815 숫자카드"},{"content":" 입력 : 세로 크기 N, 가로 크기 M ( 2 \u0026lt;= M,N \u0026lt;= 1,000 )\n1 = 익은 토마토 0 = 익지 않은 토마토 -1 = 토마토가 들어있지 않은 칸 출력 : 토마토가 모두 익을 때까지의 최소 날짜 출력\n저장될 때부터 모든 토마토가 익었다면 0 모두 익지 못하는 상황이면 -1 문제 해결 입력을 받으면서 익은토마토의 위치를 큐에 PUSH하고 (BFS를사용), 안 익은 토마토의 갯수를 저장한다.\n안익은 토마토가 없다면 모두 익은것이므로 0을 출력하고 끝낸다. 아니라면 큐를 이용하여 BFS를 시작한다. day를 기록하기위해 큐에 들어간 사이즈만큼 탐색을 해야한다.\nBFS의 조건 ( 토마토가 들어있지않은곳, 맵 밖 벗어난곳 ) 을 생각하여 큐에 넣는다.\n큐 사이즈만큼 POP이 끝났으면 하루가 지난것이므로 day를 증가\n큐가 비어있을때까지 반복한다.\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef struct coordinate { int x; int y; }; int dx[4] = { 0,0,1,-1 }; int dy[4] = { 1,-1,0,0 }; int m, n; // 가로m 세로n int map[1000][1000]; int visit[1000][1000]; int tomato_count; queue\u0026lt;coordinate\u0026gt; qu; int day = -1; void input() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt;n; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) { cin \u0026gt;\u0026gt; map[i][j]; if (map[i][j] == 1) qu.push({ i,j }); // 익은 토마토의 자리는 큐에 넣어준다. else if (map[i][j] == 0) tomato_count++; // 안익은 토마토의 갯수를 카운트한다. } } void bfs() { // tomato_count 가 모두 소진됐다면 토마토가 모두 익은것 // tomato_count 가 남아있다면 ( 0 이상 ) 토마토가 익지 못하는 상황 -\u0026gt; -1 출력 while (!qu.empty()) // 큐가 공백이 될때까지 반복한다 { int queue_size = qu.size(); // 큐 사이즈 변수.. 큐 사이즈만큼 pop을 돌리고 day를 카운트 for (int i = 0; i \u0026lt; queue_size; i++) { coordinate temp = qu.front(); // 큐의 최하단 원소 빼내어 변수에 저장 qu.pop(); // 이미 bfs를 통해 방문했던 곳이라면 패스, 아니면 visit 배열에 체크 if (visit[temp.x][temp.y]) continue; else visit[temp.x][temp.y] = 1; // 맵 경계선, 토마토가 들어있지않은곳 검사하여 사방좌표를 큐에 넣어준다. for (int j = 0; j \u0026lt; 4; j++) { int x = temp.x + dx[j]; int y = temp.y + dy[j]; if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m) continue; else if (map[x][y] == -1) continue; else if (map[x][y] == 0) { qu.push({ x,y }); map[x][y] = 1; tomato_count--; } } } // 큐 사이즈만큼 돌렸으면 day 하나 증가시킨다. day++; } // 안익은 토마토가 남아있다면,, if (tomato_count \u0026gt; 0) day = -1; } int main() { input(); // 안익은 토마토가 없다면 모두 익은것이므로 0 출력 if (tomato_count == 0) day = 0; else bfs(); cout \u0026lt;\u0026lt; day; return 0; } ","permalink":"https://ralpioxxcs.github.io/post/ps/boj_7576/","summary":"입력 : 세로 크기 N, 가로 크기 M ( 2 \u0026lt;= M,N \u0026lt;= 1,000 )\n1 = 익은 토마토 0 = 익지 않은 토마토 -1 = 토마토가 들어있지 않은 칸 출력 : 토마토가 모두 익을 때까지의 최소 날짜 출력\n저장될 때부터 모든 토마토가 익었다면 0 모두 익지 못하는 상황이면 -1 문제 해결 입력을 받으면서 익은토마토의 위치를 큐에 PUSH하고 (BFS를사용), 안 익은 토마토의 갯수를 저장한다.\n안익은 토마토가 없다면 모두 익은것이므로 0을 출력하고 끝낸다.","title":"백준 7576 토마토"},{"content":"SSH 시큐어 셸(Secure SHell, SSH)은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 기존의 rsh, rlogin, 텔넷 등을 대체하기 위해 설계되었으며, 강력한 인증 방법 및 안전하지 못한 네트워크에서 안전하게 통신을 할 수 있는 기능을 제공한다. -Wiki\n리눅스 개발환경을 구성하다보면 거의 필수적으로 사용하게 되는 ssh(secure shell) 을 구성하는 방법을 알아보자.\nSSH 서버 설치 ubuntu 및 osx 에는 기본적으로 ssh client는 설치돼있다. 아래 명령어를 이용해 ssh server를 설치한다.\nsudo apt install openssh-server sudo /etc/ini.d/sshd start # ssh service 시작 SSH 서버 구성 ssh server는 /etc/ssh/sshd_config 경로의 파일을 수정해 서버 설정을 할수있다.\nssh client 는~/.ssh/config 포트 변경 #Port 22 Port 8282 기본 ssh port(22) 말고 다른 포트를 사용하고 싶을때 수정한다.\n포트번호 수정후엔 ufw allow [Port] 해주는것을 잊지말자\n인증방식 원격지에서 ssh 서버로 접근할 때의 인증방식은 기본적으로 패스워드 인증방식을 사용한다.\n#PubkeyAuthentication yes # 공개키 인증방식 사용 PasswordAuthentication yes # id, passwd 인증방식 사용 (default) HostbasedAuthentication no # 호스트 기반 인증 방식 사용 여부 기타 설정 X11Forwarding no # 원격지에서 X11 포워딩 허용 여부 ListenAddress 0.0.0.0 # server에서 listen할 특정 주소 설정 ","permalink":"https://ralpioxxcs.github.io/post/etc/sshd_config/","summary":"SSH 시큐어 셸(Secure SHell, SSH)은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 기존의 rsh, rlogin, 텔넷 등을 대체하기 위해 설계되었으며, 강력한 인증 방법 및 안전하지 못한 네트워크에서 안전하게 통신을 할 수 있는 기능을 제공한다. -Wiki\n리눅스 개발환경을 구성하다보면 거의 필수적으로 사용하게 되는 ssh(secure shell) 을 구성하는 방법을 알아보자.\nSSH 서버 설치 ubuntu 및 osx 에는 기본적으로 ssh client는 설치돼있다.","title":"SSH 서버 설정"},{"content":"Vim Plugins vim을 쓰는 가장 큰 이유중 하나는 바로 이 Plugin에 있지않나 싶다. 설치도 비교적 간편하며, 확장성이 뛰어나서 플러그인을 사용하면서 불편한 부분들을 설정파일을 통해 입맛에 맞게 바꿀 수 있다는 점이 매력적이다.\n지금도 유용하게 사용하는 vim 플러그인들에 대한 소개와 설치방법 및 사용법에 대해 간단히 알아보겠다.\n플러그인 매니저 설치 vim에서 Plugin들을 설치, 관리해주는 도구들이 여러개 있는데 (Vundle, Pathogen) 그 중에서 나는 junegunn님이 만드신 vim-plug를 사용중이다.\n현재 neovim을 사용중이므로 설치 방법은 아래와 같다.\nsh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; 그 외의 설치방법은 여기를 참고하면 된다.\nNerdTree nerdtree는 vim에서 파일트리를 보여주는 도구로, 여러 파일을 왔다갔다 할때 유용하게 사용된다.\n선택된 파일에서 단축키 m을 입력하면 위 사진처럼 현재 경로의 파일들을 트리형식으로 나타내준다.\na : 파일 및 디렉터리를 추가생성한다. m : mv와 같은명령으로 파일 및 디렉터리를 옮긴다. r : 탐색기로 선택된 파일을 연다 ( nautilus, finder ..) o : 메모장이나 gedit 같은 시스템 편집기로 선택된 파일 연다. vim 설정은 아래와 같이 설정해두었다.\n\u0026#34; vim을 열때마다 자동으로 nerdtree를 실행한다. \u0026#34; https://github.com/preservim/nerdtree#how-can-i-open-nerdtree-automatically-when-vim-starts-up-on-opening-a-directory autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 1 \u0026amp;\u0026amp; isdirectory(argv()[0]) \u0026amp;\u0026amp; !exists(\u0026#34;s:std_in\u0026#34;) | exe \u0026#39;NERDTree\u0026#39; argv()[0] | wincmd p | ene | exe \u0026#39;cd \u0026#39;.argv()[0] | endif \u0026#34; \u0026lt;F9\u0026gt; NerdTree 열고 닫기 매크로 설정 noremap \u0026lt;F9\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; Tagbar Tagbar는 현재 파일의 Class ,Structure 정보 및 ctags가 생성한 tags를 트리 형식으로 보여주는 플러그인이다. 이 플러그인을 사용하려면 우선적으로 ctags가 설치돼있어야 한다.\n\u0026#34;Ubuntu\u0026#34; sudo apt-get install exuberant-ctags \u0026#34;OS X\u0026#34; brew install ctags 아래의 vim 설정을 통해 F8을 Tagbar단축키로 설정해두었다.\n\u0026#34; ctags 경로 설정 let g:tagbar_ctags_bin=\u0026#39;/usr/local/bin/ctags\u0026#39; let g:tagbar_autoclose=0 let g:tabar_autofocus=1 \u0026#34; \u0026lt;F8\u0026gt; Tagbar 열고 닫기 매크로 설정 noremap \u0026lt;F8\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt; FZF 강력한 터미널 파일탐색 도구인 fzf를 vim 플러그인으로 사용할 수 있다.\n기존에는 ctrlp를 사용하다가 fzf를 알고나서부터는 이것만 주욱 써오고 있다. 아직은 fzf를 완벽하게 사용하지는 못하고 있지만, 파일 탐색, 버퍼, 문자열 찾기 기능등으로 쓰고 있다.\nvim-plug를 이용해 설치한다.\nPlug \u0026#39;junegunn/fzf\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; fzf#install() } } Plug \u0026#39;junegunn/fzf.vim\u0026#39; fzf-vim의 기능 중 Ag와 Rg의 기능을 사용하기 위해 다음의 프로그램중 하나를 필요로 한다.\nThe Silver Searcher Ripgrep 만약 검색결과에 대해 Syntax Highlighting을 원한다면 bat을 설치해주자.\nCustomization fzf-vim은 기본적으로 편집창 아래에 검색결과를 나타내주는데, 이것또한 변경이 가능하다.\n1. fzf layout \u0026#34; fzf layout let g:fzf_layout = {\u0026#39;up\u0026#39;:\u0026#39;~90%\u0026#39;, \u0026#39;window\u0026#39;: { \u0026#39;width\u0026#39;: 0.8, \u0026#39;height\u0026#39;: 0.8,\u0026#39;yoffset\u0026#39;:0.5,\u0026#39;xoffset\u0026#39;: 0.5, \u0026#39;highlight\u0026#39;: \u0026#39;Todo\u0026#39;, \u0026#39;border\u0026#39;: \u0026#39;sharp\u0026#39; } } let $FZF_DEFAULT_OPTS = \u0026#39;--layout=reverse --inline-info\u0026#39; let $FZF_DEFAULT_COMMAND=\u0026#34;rg --files --hidden --glob \u0026#39;!.git/**\u0026#39;\u0026#34; \u0026#34; Customize fzf colors to match your color scheme \u0026#34; - fzf#wrap translates this to a set of `--color` options let g:fzf_colors = \\ { \u0026#39;fg\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;bg\u0026#39;: [\u0026#39;bg\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;hl\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Comment\u0026#39;], \\ \u0026#39;fg+\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;CursorLine\u0026#39;, \u0026#39;CursorColumn\u0026#39;, \u0026#39;Normal\u0026#39;], \\ \u0026#39;bg+\u0026#39;: [\u0026#39;bg\u0026#39;, \u0026#39;CursorLine\u0026#39;, \u0026#39;CursorColumn\u0026#39;], \\ \u0026#39;hl+\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Statement\u0026#39;], \\ \u0026#39;info\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;PreProc\u0026#39;], \\ \u0026#39;border\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Ignore\u0026#39;], \\ \u0026#39;prompt\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Conditional\u0026#39;], \\ \u0026#39;pointer\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Exception\u0026#39;], \\ \u0026#39;marker\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Keyword\u0026#39;], \\ \u0026#39;spinner\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Label\u0026#39;], \\ \u0026#39;header\u0026#39;: [\u0026#39;fg\u0026#39;, \u0026#39;Comment\u0026#39;] } 2. Files \u0026#34;Get Files command! -bang -nargs=? -complete=dir Files \\ call fzf#vim#files(\u0026lt;q-args\u0026gt;, fzf#vim#with_preview({\u0026#39;options\u0026#39;: [\u0026#39;--layout=reverse\u0026#39;, \u0026#39;--inline-info\u0026#39;]}), \u0026lt;bang\u0026gt;0) 3. Rg \u0026#34; Get text in files with Rg \u0026#34; command! -bang -nargs=* Rg \u0026#34; \\ call fzf#vim#grep( \u0026#34; \\ \u0026#34;rg --column --line-number --no-heading --color=always --smart-case --glob \u0026#39;!.git/**\u0026#39; \u0026#34;.shellescape(\u0026lt;q-args\u0026gt;), 1, \u0026#34; Make Ripgrep ONLY search file contents and not filenames command! -bang -nargs=* Rg \\ call fzf#vim#grep( \\ \u0026#39;rg --column --line-number --hidden --smart-case --no-heading --color=always \u0026#39;.shellescape(\u0026lt;q-args\u0026gt;), 1, \\ \u0026lt;bang\u0026gt;0 ? fzf#vim#with_preview({\u0026#39;options\u0026#39;: \u0026#39;--delimiter : --nth 4..\u0026#39;}, \u0026#39;up:60%\u0026#39;) \\ : fzf#vim#with_preview({\u0026#39;options\u0026#39;: \u0026#39;--delimiter : --nth 4.. -e\u0026#39;}, \u0026#39;right:50%\u0026#39;, \u0026#39;?\u0026#39;), \\ \u0026lt;bang\u0026gt;0) \u0026#34; Ripgrep advanced function! RipgrepFzf(query, fullscreen) let command_fmt = \u0026#39;rg --column --line-number --no-heading --color=always --smart-case %s || true\u0026#39; let initial_command = printf(command_fmt, shellescape(a:query)) let reload_command = printf(command_fmt, \u0026#39;{q}\u0026#39;) let spec = {\u0026#39;options\u0026#39;: [\u0026#39;--phony\u0026#39;, \u0026#39;--query\u0026#39;, a:query, \u0026#39;--bind\u0026#39;, \u0026#39;change:reload:\u0026#39;.reload_command]} call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen) endfunction command! -nargs=* -bang RG call RipgrepFzf(\u0026lt;q-args\u0026gt;, \u0026lt;bang\u0026gt;0) ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_2/","summary":"Vim Plugins vim을 쓰는 가장 큰 이유중 하나는 바로 이 Plugin에 있지않나 싶다. 설치도 비교적 간편하며, 확장성이 뛰어나서 플러그인을 사용하면서 불편한 부분들을 설정파일을 통해 입맛에 맞게 바꿀 수 있다는 점이 매력적이다.\n지금도 유용하게 사용하는 vim 플러그인들에 대한 소개와 설치방법 및 사용법에 대해 간단히 알아보겠다.\n플러그인 매니저 설치 vim에서 Plugin들을 설치, 관리해주는 도구들이 여러개 있는데 (Vundle, Pathogen) 그 중에서 나는 junegunn님이 만드신 vim-plug를 사용중이다.\n현재 neovim을 사용중이므로 설치 방법은 아래와 같다.","title":"Vim 사용하기 #2 - Plugin"},{"content":"이 링크 로 들어가면 아래 사진과 같은 화면이 나오며 각 Release 버전에 맞는 llvm 패키지들을 다운로드 받을 수 있다. llvm, clang, lld, lldb등 각 패키지에 대한 설명은 여기에 잘 나와있다.\n아무튼 위의 사진에 나온것처럼 설치방법으로는 크게 4가지로 나눌 수 있다.\n소스코드 다운로드 후 직접 빌드 미리 빌드된 바이너리 설치 Automatic Installation Script apt install 커맨드 사용하여 설치 이 포스팅에서는 3번째인 Automatic installation script를 이용하여 설치하는 방법을 다루려고 한다.\nAutomatic installation script llvm에서는 llvm 저장소와 apt insatll 커맨드를 간편하게 하나의 스크립트로 설치 해주는 Automactic installation script를 제공하여 간편하게 llvm package들을 다운로드 받을 수 있다.\n대신 이 방식으로 설치를 하면 LLVM, Clang, compiler-rt, polly, LLDB, LLD, libFuzzer, libc++, libc++abi, openmp 의 모든 패키지들을모두 포함하여 설치를 하게된다. 만약 원하는것만 설치하고 싶다면 소스코드를 직접 다운로드하거나, apt 커맨드를 이용한 설치방법을 이용하여야 한다.\nLatest stable version 설치 bash -c \u0026#34;$(wget -O - https://apt.llvm.org/llvm.sh)\u0026#34; 현재 날짜(2020-07-04)기준 latest version은 10이다.\n만약 최신버전을 받고 싶다면 위의 명령어만 입력하면 llvm script가 다운로드되고 알아서 설치를 진행한다.\nThis script must be run as root 메시지가 나오면서 설치가 진행되지 않으면 sudo를 앞에 추가 후 다시 진행하면 된다.\nSpecific version 설치 wget https://apt.llvm.org/llvm.sh chmod +x llvm.sh sudo ./llvm.sh \u0026lt;version number\u0026gt; 만약 llvm9 버전을 받고 싶다면 sudo ./llvm.sh 9로만 입력해주면 된다.\n설치 확인 설치가 완료되었다면 /usr/lib/llvm-9/ 디렉터리로 가서 잘 설치가 되었는지 확인한다. Reference\nhttps://apt.llvm.org/ ","permalink":"https://ralpioxxcs.github.io/post/etc/llvm_install/","summary":"이 링크 로 들어가면 아래 사진과 같은 화면이 나오며 각 Release 버전에 맞는 llvm 패키지들을 다운로드 받을 수 있다. llvm, clang, lld, lldb등 각 패키지에 대한 설명은 여기에 잘 나와있다.\n아무튼 위의 사진에 나온것처럼 설치방법으로는 크게 4가지로 나눌 수 있다.\n소스코드 다운로드 후 직접 빌드 미리 빌드된 바이너리 설치 Automatic Installation Script apt install 커맨드 사용하여 설치 이 포스팅에서는 3번째인 Automatic installation script를 이용하여 설치하는 방법을 다루려고 한다.\nAutomatic installation script llvm에서는 llvm 저장소와 apt insatll 커맨드를 간편하게 하나의 스크립트로 설치 해주는 Automactic installation script를 제공하여 간편하게 llvm package들을 다운로드 받을 수 있다.","title":"Ubuntu LLVM Package 설치"},{"content":"ubuntu 환경에서 c,cxx 기본 컴파일러는 /usr/bin/cc , /usr/bin/c++에 심볼릭 링크로 지정되어있는데 기본적으로는 gcc와 **g++**로 설정되어있다.\n빌드시에 컴파일러 경로를 직접 입력해주는 방법도 있지만, /usr/bin/c++의 심볼릭 링크를 변경해줌으로써 고정을 시킬수도 있다.\n이 과정전에 반드시 clang이 설치되어야 한다. clang을 설치하는 방법은 여기에 포스팅해 두었다.\n환경변수 변경 export CC=/usr/bin/clang export CXX=/usr/bin/clang++ 위의 명령어로 환경변수를 바꿔주는 방법으로 컴파일러를 바꿔줄 수 있다. 영구적으로 지정시키고 싶다면 ~/.bashrc에 추가하는 방법으로 환경변수를 설정해주하면 된다.\n지정 커맨드 이용 # c++ compiler sudo update-alternatives --config c++ # c compiler sudo update-alternatives --config cc 위의 커맨드를 입력하고 아래처럼 결과 창이 나오면 원하는 번호를 입력하여 c와 c++에 지정된 컴파일러 경로를 바꿔준다. ","permalink":"https://ralpioxxcs.github.io/post/etc/change_compiler/","summary":"ubuntu 환경에서 c,cxx 기본 컴파일러는 /usr/bin/cc , /usr/bin/c++에 심볼릭 링크로 지정되어있는데 기본적으로는 gcc와 **g++**로 설정되어있다.\n빌드시에 컴파일러 경로를 직접 입력해주는 방법도 있지만, /usr/bin/c++의 심볼릭 링크를 변경해줌으로써 고정을 시킬수도 있다.\n이 과정전에 반드시 clang이 설치되어야 한다. clang을 설치하는 방법은 여기에 포스팅해 두었다.\n환경변수 변경 export CC=/usr/bin/clang export CXX=/usr/bin/clang++ 위의 명령어로 환경변수를 바꿔주는 방법으로 컴파일러를 바꿔줄 수 있다. 영구적으로 지정시키고 싶다면 ~/.bashrc에 추가하는 방법으로 환경변수를 설정해주하면 된다.\n지정 커맨드 이용 # c++ compiler sudo update-alternatives --config c++ # c compiler sudo update-alternatives --config cc 위의 커맨드를 입력하고 아래처럼 결과 창이 나오면 원하는 번호를 입력하여 c와 c++에 지정된 컴파일러 경로를 바꿔준다.","title":"Ubuntu Clang 컴파일러 설정"},{"content":" 나에게 vim이란 라즈베리파이 같은 리소스나 메모리등 작업 환경이 열악하거나 불가피한 사유로 인터넷을 사용하지 못하는 상황에서 가끔 쓰던 편집기였다.\nhjkl로 움직이고, visual mode, normal mode 등등 처음에는 진입장벽이 높게 느껴져서 손이 안가다가, 마우스를 쓰는게 너무 귀찮아서 일주일만 마음먹고 연습(?)을 했더니 이제는 vim이 없으면 코딩을 할 맛이 안나게 될 정도로 익숙해져버렸다.\nvim으로 갈아타게 된 결정적인 계기는 VSCode에서 지원하는 c/cpp extension이 메모리를 너무 잡아먹어서이다.. (물론 vim도 이것저것 많이 깔면 느려지겠지만)\n아무튼 내가 생각하는 vim의 장점은 이렇다\n프로그램이 light하고 seamless 하다 vim script 작성으로 기능 커스터마이징이 자유롭다 처음 learning curve만 극복하면 작업효율이 엄청 상승한다 간지난다 neovim 설치하기 neovim은 terminal buffer를 지원하는 좀 더 기능이 확장된 형태의 vim이다. terminal buffer말고도, 24bit true color 지원 등 더 다양하고 좋은 기능들을 탑재한 vim이라, neovim을 설치하였다.\n내가 사용하는 os:q 는 ubuntu이므로 Debian install 가이드를 따라 설치를 진행하였다.\nsudo add-apt-repository ppa:neovim-ppa/unstable sudo apt-get update sudo apt-get install neovim sudo apt-get install python-dev python-pip sudo apt-get install python3-dev python3-pip 설치가 완료되면 터미널에 nvim을 치면아래의 그림처럼 neovim이 실행된다. 기본 설정 neovim도vim과 똑같이 vimrc같은 설정파일을 수정하여 기본적인 설정을 할 수 있다.\n설정 파일의 경로는 ~/.config/nvim이며 이 경로에 파일을 직접 생성해야 한다.\n$ mkdir ~/.config/nvim $ cd ~/.config/nvim $ touch init.vim 아래는 현재 사용중인 init.vim의 설정이다.\nset iskeyword+=- set formatoptions-=cro syntax on set hidden \u0026#34; 버퍼를 수정한 직후 버퍼를 감춰지도록 함 set wrap \u0026#34; 자동 줄 바꿈 set encoding=UTF-8 \u0026#34; UTF-8 인코딩 set t_Co=256 \u0026#34; 256 칼라 지원 set number \u0026#34; 라인 수 표시 set ruler \u0026#34; 커서 표시 set cursorline \u0026#34; 현재 커서 하이라이팅 set pumheight=10 \u0026#34; 팝업 메뉴 크기 조정 set showcmd \u0026#34; 명령어를 상태라인에 보여준다 set mouse=a \u0026#34; 마우스 사용 가능 set tabstop=2 \u0026#34;\u0026#34; set shiftwidth=2 \u0026#34;\u0026#34; set smarttab \u0026#34;\u0026#34; set smartindent \u0026#34; 새로운 라인 시작 시, auto indentation 수행 set autoindent \u0026#34; 자동 들여쓰기 set expandtab \u0026#34; tab을 space로 확장 set showmatch \u0026#34; 매칭되는 괄호 표시 set background=light set showtabline=2 set noshowmode set nobackup \u0026#34; 백업파일을 생성하지 않는다 set signcolumn=yes set updatetime=300 set timeoutlen=100 set clipboard=unnamedplus \u0026#34; 클립보드 복사\u0026amp;붙여넣기 허용 set incsearch \u0026#34; 점진적으로 찾기 set hlsearch \u0026#34; 검색어 하이라이팅 set nowrapscan \u0026#34; 찾기 파일 맨 끝 도달시, 계속하여 찾지 않음 set guifont=Hack\\ Nerd\\ Font \u0026#34; 폰트 설정 set ignorecase \u0026#34; 검색시 대소문자 구별 X let $TERM=\u0026#34;xterm-256color\u0026#34; \u0026#34; true color \u0026#34; 파일 열기 마지막 부분 저장 if has(\u0026#34;autocmd\u0026#34;) \u0026#34; When editing a file, always jump to the last cursor position autocmd BufReadPost * \\ if line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026gt; 0 \u0026amp;\u0026amp; line (\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026lt;= line(\u0026#34;$\u0026#34;) | \\ exe \u0026#34;normal g\u0026#39;\\\u0026#34;\u0026#34; | \\ endif endif ","permalink":"https://ralpioxxcs.github.io/post/vim/vim_1/","summary":"나에게 vim이란 라즈베리파이 같은 리소스나 메모리등 작업 환경이 열악하거나 불가피한 사유로 인터넷을 사용하지 못하는 상황에서 가끔 쓰던 편집기였다.\nhjkl로 움직이고, visual mode, normal mode 등등 처음에는 진입장벽이 높게 느껴져서 손이 안가다가, 마우스를 쓰는게 너무 귀찮아서 일주일만 마음먹고 연습(?)을 했더니 이제는 vim이 없으면 코딩을 할 맛이 안나게 될 정도로 익숙해져버렸다.\nvim으로 갈아타게 된 결정적인 계기는 VSCode에서 지원하는 c/cpp extension이 메모리를 너무 잡아먹어서이다.. (물론 vim도 이것저것 많이 깔면 느려지겠지만)\n아무튼 내가 생각하는 vim의 장점은 이렇다","title":"Vim 사용하기 #1 - Install"},{"content":" OpenCV 라이브러리를 사용해본 사람이라면 한번쯤 ImageWatch 플러그인을 사용해봤을 것이다.\n디버거에서 확인하기 힘든 Mat 데이터내 index value등 간편한 인터페이스를 통해 직관적으로 확인이 가능한 유용한 툴이다. 하지만, Visual Studio에서만 사용이 가능한 플러그인이라, 리눅스 환경에서 개발을 하는 나에게는 아쉬움이 많았다.\n그러다가 github에서 imagewatch와 비슷하게 간편한 인터페이스로 index값을 확인할 수 있는 프로그램을 발견하게 되었고, 지금까지 아주 유용하게 사용하고 있다.\n설치조건 gdb imagewatch는 아래의 프로그램들의 설치를 필요로 한다.\nOpenGL 2.1++ C+11 컴파일러 gdb 7.10 버전 이상 Qt 5.6 버전 이상 (HighDPI 필요) Python 3+ $ gdb --version 으로 현재 gdb의 버전이 7.10 이상인지 확인한다.\n설치 및 빌드 위의 설치조건에 모두 부합하다면, git을 이용하여 프로그램을 다운로드 한다. (git url)\n$ git clone https://github.com/csantosbh/gdb-imagewatch $ cd gdb-imagewatch $ git submodule init $ git submodule update 다운로드 및 submodule 설정을 해주고, 아래의 명령어들을 이용해 build 한다\n$ mkdir build \u0026amp;\u0026amp; cd build $ qmake .. BUILD_MODE=release PREFIX=/path/to/installation/folder $ make -j4 $ make install build mode의 prefix 부분은 설치의 경로를 지정해주면 된다. 기본적으로 /usr/local이 지정되어있다.\n빌드가 성공적으로 되었다면 설치경로에서 python3 gdb-imagewatch.py --test 명령어를 통해 정상적으로 설치가 되었는지 확인한다.\n사용법 gdb에서 imageWatch를 자동으로 실행시켜주기 위해 ~/.gdbinit 파일을 열어서 마지막 라인에 아래의 줄을 추가한다\nsource /path/to/gdb-imagewatch/gdb-imagewatch.py 아래 사진처럼 gdb가 breakpoint에서 걸리면 자동으로 창이 생성되면 보고자 하는 symbol명을 입력하면 된다.\ncode example 50x50행렬, 8 bit 3 channel을 모두 1로 초기화한 행렬을 imageWatch를 통해 확인한다.\nimage watch ","permalink":"https://ralpioxxcs.github.io/post/etc/gdb_imagewatch_1/","summary":"OpenCV 라이브러리를 사용해본 사람이라면 한번쯤 ImageWatch 플러그인을 사용해봤을 것이다.\n디버거에서 확인하기 힘든 Mat 데이터내 index value등 간편한 인터페이스를 통해 직관적으로 확인이 가능한 유용한 툴이다. 하지만, Visual Studio에서만 사용이 가능한 플러그인이라, 리눅스 환경에서 개발을 하는 나에게는 아쉬움이 많았다.\n그러다가 github에서 imagewatch와 비슷하게 간편한 인터페이스로 index값을 확인할 수 있는 프로그램을 발견하게 되었고, 지금까지 아주 유용하게 사용하고 있다.\n설치조건 gdb imagewatch는 아래의 프로그램들의 설치를 필요로 한다.\nOpenGL 2.1++ C+11 컴파일러 gdb 7.10 버전 이상 Qt 5.","title":"gdb에서 imagewatch 사용하기"},{"content":"set 변수를 사용해 Shell에 출력되는 문자들의 색상을 지정할 수 있다.\nif(NOT WIN32) string(ASCII 27 Esc) set(ColourReset \u0026#34;${Esc}[m\u0026#34;) set(ColourBold \u0026#34;${Esc}[1m\u0026#34;) set(Red \u0026#34;${Esc}[31m\u0026#34;) set(Green \u0026#34;${Esc}[32m\u0026#34;) set(Yellow \u0026#34;${Esc}]33m\u0026#34;) set(Blue \u0026#34;${Esc}]34\u0026#34;) set(Magenta \u0026#34;${Esc}]35m\u0026#34;) set(Cyan \u0026#34;${Esc}]36m\u0026#34;) set(White \u0026#34;${Esc}[37m\u0026#34;) set(BoldRed \u0026#34;${Esc}[1;31m\u0026#34;) set(BoldGreen \u0026#34;${Esc}[1;32m\u0026#34;) set(BoldYellow \u0026#34;${Esc}[1;33m\u0026#34;) set(BoldBlue \u0026#34;${Esc}[1;34m\u0026#34;) set(BoldMagenta \u0026#34;${Esc}[1;35m\u0026#34;) set(BoldCyan \u0026#34;${Esc}[1;36m\u0026#34;) set(BoldWhite \u0026#34;${Esc}[1;37m\u0026#34;) endif() 위의 내용을 .cmkae파일로 만들어 include하거나 CmakeLists.txt 의 상단에 삽입한다.\nExample message(\u0026#34; \u0026#34;) message( \u0026#34;${BoldGreen}\\t\\t\\t[ BUILD SUMMARY ] ${White}\u0026#34; ) message( \u0026#34;${BoldWhite}------------------------------------------------------------------------${ColourReset}\u0026#34; ","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_4/","summary":"set 변수를 사용해 Shell에 출력되는 문자들의 색상을 지정할 수 있다.\nif(NOT WIN32) string(ASCII 27 Esc) set(ColourReset \u0026#34;${Esc}[m\u0026#34;) set(ColourBold \u0026#34;${Esc}[1m\u0026#34;) set(Red \u0026#34;${Esc}[31m\u0026#34;) set(Green \u0026#34;${Esc}[32m\u0026#34;) set(Yellow \u0026#34;${Esc}]33m\u0026#34;) set(Blue \u0026#34;${Esc}]34\u0026#34;) set(Magenta \u0026#34;${Esc}]35m\u0026#34;) set(Cyan \u0026#34;${Esc}]36m\u0026#34;) set(White \u0026#34;${Esc}[37m\u0026#34;) set(BoldRed \u0026#34;${Esc}[1;31m\u0026#34;) set(BoldGreen \u0026#34;${Esc}[1;32m\u0026#34;) set(BoldYellow \u0026#34;${Esc}[1;33m\u0026#34;) set(BoldBlue \u0026#34;${Esc}[1;34m\u0026#34;) set(BoldMagenta \u0026#34;${Esc}[1;35m\u0026#34;) set(BoldCyan \u0026#34;${Esc}[1;36m\u0026#34;) set(BoldWhite \u0026#34;${Esc}[1;37m\u0026#34;) endif() 위의 내용을 .cmkae파일로 만들어 include하거나 CmakeLists.txt 의 상단에 삽입한다.\nExample message(\u0026#34; \u0026#34;) message( \u0026#34;${BoldGreen}\\t\\t\\t[ BUILD SUMMARY ] ${White}\u0026#34; ) message( \u0026#34;${BoldWhite}------------------------------------------------------------------------${ColourReset}\u0026#34; ","title":"CMake Part4 - 색상 지정"},{"content":"어떤 프로젝트를 cmake를 이용하여 관리 및 빌드하고자 할때, CMakeLists.txt를작성 시 자주 사용되는 cmake 기본 명령어들이 있다.\n(Root) |- CMakeLists.txt |- README.md |- [src] | |- CMakeListst.txt | |- foo.cpp | |- poo.cpp | |- main.cpp |- [include] | |- foo.h | |- poo.h |- [cmake] | |- options.cmake 이런 구조를 가지는 프로젝트 폴더가 있다고 할 때, CMakeLists.txt는 아래와 같다.\n# [/CMakeListst.txt] cmake_minimum_required(VERSION 3.3) project(foo CXX) # -\u0026gt; \u0026#39;foo\u0026#39;라는 project를 정의한다. # cmake files list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) include(options) # -\u0026gt; project 설정관련 전반 .cmake 파일들을 include한다 # build configure set(CMAKE_BUILD_TYPE Debug) set(CMAKE_VERBOSE_MAKEFILE true) # -\u0026gt; build 타입및 compile 관련 설정 # -\u0026gt; header파일들을 include paht에 포함시키고 src 폴더내의 CMakeLists.txt를 수행 include_directories(${CMAKE_CURRENT_LIST_DIR}/include) add_subdirectory(src) src폴더 내, CMakeLists.txt파일은\n# [src/CMakeListst.txt] # src files.. set(SRC_PATH ${CMAKE_CURRENT_LIST_DIR}/main.cpp ${CMAKE_CURRENT_LIST_DIR}/foo.cpp ${CMAKE_CURRENT_LIST_DIR}/poo.cpp) set(OUTPUT_EFL test.out) # -\u0026gt; build할 파일들을 SRC_PATH 변수에 담는다 # generate executable file add_executable(${OUTPUT_ELF} ${SRC_PATH}) # -\u0026gt; executable 파일을 생성 taget_link_libraries(${OUTPUT_ELF} libs) # -\u0026gt; 라이브러리 링크 file(MAKE_DIRECTORY ${CMAKE_SOURCE_DIR}/install) # -\u0026gt; install 폴더 생성 # install 명령 수행 install(TARGETS ${OUTPUT_ELF} DESTINATION ${CMAKE_SOURCE_DIR}/install) ","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_3/","summary":"어떤 프로젝트를 cmake를 이용하여 관리 및 빌드하고자 할때, CMakeLists.txt를작성 시 자주 사용되는 cmake 기본 명령어들이 있다.\n(Root) |- CMakeLists.txt |- README.md |- [src] | |- CMakeListst.txt | |- foo.cpp | |- poo.cpp | |- main.cpp |- [include] | |- foo.h | |- poo.h |- [cmake] | |- options.cmake 이런 구조를 가지는 프로젝트 폴더가 있다고 할 때, CMakeLists.txt는 아래와 같다.\n# [/CMakeListst.txt] cmake_minimum_required(VERSION 3.3) project(foo CXX) # -\u0026gt; \u0026#39;foo\u0026#39;라는 project를 정의한다. # cmake files list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) include(options) # -\u0026gt; project 설정관련 전반 .","title":"CMake Part3 - 프로젝트 구성"},{"content":"Hi! 😀 My name is JaeHong Kim.\nI work as a Software Engineer on an IT Compnay from Korea.\nI focus on Image processing Development.\nProgramming as a craftsmanship is my main hobby, learning something new keeps me motivated.\nAlso, I love to build keyboards.\nI made this blog to improve my development skills and career.\n","permalink":"https://ralpioxxcs.github.io/about/","summary":"Hi! 😀 My name is JaeHong Kim.\nI work as a Software Engineer on an IT Compnay from Korea.\nI focus on Image processing Development.\nProgramming as a craftsmanship is my main hobby, learning something new keeps me motivated.\nAlso, I love to build keyboards.\nI made this blog to improve my development skills and career.","title":"About"},{"content":"1. project 초기 설정 CMAKE_MINIMUM_REQUIRED [용법]\ncmake_minimum_required(VERSION major.minor[.patch[.tweak]][FATAL_ERROR]) 만약 어떤 오픈소스 라이브러리가 cmake 3.0 버전 이상으로 작성 되었고, 현재 나의 빌드환경은 cmake 2.8버전 미만이라면 빌드 시, 다음의 에러가 출력된다 -\u0026gt;\nCMake 3.0 or higher is required. You are running version 2.8.12.2\n이 커맨드는 반드시 CMakeListst.txt 작성시 맨 처음에 선언 해 놓아야 정상적인 버전 호환 에러를 출력할 수 있다.\n# Bad example project(foo) cmake_minimum_required(VERSION 3.0) message(\u0026#34;Using CMake version ${CMAKE_VERSION}\u0026#34;) PROJECT [용법]\nproject(\u0026lt;PROJECT-NAME\u0026gt; [LANGUAGES] [\u0026lt;language-name\u0026gt;...]) project(\u0026lt;PROJECT-NAME\u0026gt; [VERSION \u0026lt;major\u0026gt;[.\u0026lt;minor\u0026gt;[.\u0026lt;patch\u0026gt;[.\u0026lt;tweak\u0026gt;]]]] [LANGUAGES \u0026lt;language-name\u0026gt;...]) 이름 및 버전, 언어등 전체 프로젝트에 대한 정의를 한다.\n아래와 같이 1.0 버전의 c/c++로 작성된 foo라는 프로젝트를 명시할 수 있다. Visual Studio로 예를 들자면 솔루션 탐색기의 최상단에 위치하는 프로젝트의 이름이 된다.\nproject(foo C CXX VERSION 1.0) SET [용법]\n# Normal Variable set(\u0026lt;variable\u0026gt; \u0026lt;value\u0026gt;... [PARENT_SCOPE]) # Cache Entry set(\u0026lt;variable\u0026gt; \u0026lt;value\u0026gt;... CACHE \u0026lt;type\u0026gt; \u0026lt;docstring\u0026gt; [FORCE]) 각종 변수를 정의하는데 사용되는 명령어이다.\nset( var1 10 )일때 var1은 10의 값을 가지고 현재 디렉토리내에서만 유효하다. 하지만 만약 마지막에 PARENT_SCOPE 옵션을 사용한다면 var1의 scope는 부모 디렉터리까지 유효하게 된다. 또한, ENV옵션을 사용해 다음처럼 환경변수를 정의할 수도 있다.\nset(ENV{LOG_LEVEL} TRACE) INCLUDE [용법]\ninclude(\u0026lt;file|module\u0026gt; [OPTIONAL] [RESULT_VARIABLE \u0026lt;VAR\u0026gt;] [NO_POLICY_SCOPE]) .cmake 로 작성된 파일들을 사용할수 있도록 프로젝트에 포함시킨다. CMAKE_MODULE_PATH라는 예약변수에 의해 경로가 설정되며, 해당 경로를 통해 .cmake 파일을 탐색한다.\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # cmake폴더 path 추가 include(options) # options.cmake 파일 Load INCLUDE_DIRECTORIES [용법]\ninclude_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 컴파일러에게 각 소스파일에 있는 #include로 포함된 헤더파일들을 포함시킬 수 있도록 하는 명령이다. 아래 예시를 들면 include폴더에 있는 모든 헤더파일을 찾을 수 있도록 한다.\n# EXAMPLE # 현재 CMakeLists.txt가 실행되는 파일 위치의 경로에서 include라는 폴더를 포함함 include_directories( ${CMAKE_CURRENT_LIST_DIR}/include ) ADD_SUBDIRECTORY [용법]\nadd_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) cmake 빌드에 필요한 디렉토리를 추가하는 명령이다. 만약 모듈별, 폴더별로 CMakeLists.txt가 나누어져 있다고 하면, 이 명령어를 통해서 CMakeListst.txt가 있는 폴더의 위치를 명시해줌으로써, 하위 모듈의 CMakeLists.txt파일들을 source_dir에 추가시킬 수 있도록 한다.\n# EXAMPLE # src 폴더내의 CMakeLists.txt를 포함해 실행될수 있도록 함 add_subdirectory( ${CMAKE_CURRENT_LIST_DIR}/src ) 2. compile 설정 관련 ADD_COMPILE_OPTIONS [용법]\nadd_compile_options(\u0026lt;option\u0026gt; ...) 소스를 컴파일해 오브젝트 파일(.obj)을 만들때, 컴파일러에게 옵션(flag)를 지정해주는 명령어.\nadd_compile_options(-Wall) 은 gcc -Wall과 대치된다.\nADD_DEFINITIONS [용법]\nadd_definitions(-DFOO -DBAR ...) preprocesor에서 처리할 변수를 선언한다. gcc flag중 -D option에 대치된다.\nadd_definitions( -D__linux__ )는 #define __linux와 같다.\nCMAKE_BUILD_TYPE project의 build type을 결정한다.\nDebug : 디버깅 정보를 포함하는 빌드 Relase : 릴리즈 전용 빌드 RelWithDebInfo : 디버깅 정보를 포함하는 릴리즈 빌드 MinSizeRel : 최소크기를 가지는 릴리즈 빌드 # EXAMPLE # 릴리즈로 빌드 set(CMAKE_BUILD_TYPE Release) CMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다.\n# EXAMPLE set(CMAKE_VERBOSE_MAKEFILE true) true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.\nCMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다.\nset(CMAKE_VERBOSE_MAKEFILE true) true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.\n3. build 설정 관련 ADD_EXECUTABLE [용법]\nadd_executable(\u0026lt;name\u0026gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) \u0026lt;name\u0026gt;으로 설정된 project 타겟에 대하여 source list로부터 실행가능한 executable 파일을 생성한다. 기본적으로 생성된 파일의 위치는 명령어가 발생한 곳의 위치에 생성되며, RUNTIME_OUTPUT_DIRECTORY 변수를 통해 위치를 변경할 수 있다.\n# EXAMPLE set(src main.cpp foo.cpp boo.cpp) # test.out의 실행파일을 생성 add_executable(test.out ${src}) LINK_LIBRARIES [용법]\nlink_libraries([item1 [item2 [...]]] [[debug|optimized|general] \u0026lt;item\u0026gt;] ...) 모든 타겟에 대해 사용될 라이브러리를 링크하는 명령. gcc 옵션중 -l에 대치되는 명령이며 링크옵션 또한 사용가능하다.\n# EXAMPLE # libbluetooth 라이브러리를 링크 link_libraries(bluetooth) INSTALL [용법]\ninstall(TARGETS targets... [EXPORT \u0026lt;export-name\u0026gt;] [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE| PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE] [DESTINATION \u0026lt;dir\u0026gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT \u0026lt;component\u0026gt;] [OPTIONAL] [EXCLUDE_FROM_ALL] [NAMELINK_ONLY|NAMELINK_SKIP] ] [...] [INCLUDES DESTINATION [\u0026lt;dir\u0026gt; ...]] ) make install 명령어 입력시 진행되는 과정을 정의하는 명령. 주로 cmake 빌드 과정을 통해 나오는 결과물 ( 실행파일, 라이브러리, 리소스) 등을 특정한 위치로 복사하는 동작을 한다.\n# EXAMPLE # output.out 바이너리 파일을 /usr/local/bin의 위치로 설치함 install(TARGETS output.out DESTINATION usr/local/bin) 4. 기타 FIND_FILE [용법]\nfind_file ( \u0026lt;VAR\u0026gt; name | NAMES name1 [name2 ...] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \u0026#34;cache documentation string\u0026#34;] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 찾을 파일의 이름의 전체경로를 찾아주는 명령. \u0026lt;VAR\u0026gt;변수에 결과가 저장되도록 한다. 만약 경로를 찾지 못하였을경우 \u0026lt;VAR\u0026gt;-NOTFOUND로 최종적으로 저장이된다.\n# EXAMPLE # test.cpp 파일의 전체 경로를 ${CPP_FILE_PATH}변수에 저장 find_file(CPP_FILE_PATH test.cpp PATHS /home/test) FIND_PACKAGE [용법]\nfind_package(\u0026lt;package\u0026gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE]) 시스템에 설치된 Package들을 찾는 명령. Package를 찾았을 경우 \u0026lt;package\u0026gt;_FOUND 변수에 결과가 저장된다.\nversion : package의 버전을 요청 EXACT : 버전이 정확히 일치하도록 요청 QUIET : package를 찾을 수 없는경우 메시지 비활성화 MODULE : 모듈모드로 package 찾음\n결론적으로, target link libraries 명령을 사용할 때 사용되는 정보들을 받아 linking하는데 관련된 정보를 사용할 수 있도록 하는 명령어이다. 기타 세부설명은 다음 링크에서 확인한다. [click] (https://cmake.org/cmake/help/v3.10/command/find_package.html) # EXAMPLE find_package(pak 1.0) if(pak_FOUND) # ... endif() # pak 이라는 패키지를 찾았으면 if실행 ------------------------------------------ find_package(pak 1.0 REQUIRED) # pak 이라는 패키지를 찾지 못할경우 오류 메시지 출력 (\u0026#39;REQUIRED\u0026#39;에 의해) FIND_LIBRARY [용법]\nfind_library ( \u0026lt;VAR\u0026gt; name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC \u0026#34;cache documentation string\u0026#34;] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) shared library(.so) , static library(.a) 파일등을 찾는 cmake 명령어이다. 찾고자하는 파일을 발견하면, \u0026lt;VAR\u0026gt;변수에 결과가 저장되며, 라이브러리 파일을 찾지 못하였을 경우 \u0026lt;VAR\u0026gt;-NOTFOUND를 저장한다.\n# EXAMPLE find_library ( FOO_LIBS NAMES foo PATHS /usr/lib ) # /usr/lib의 경로에서 libfoo.so 라이브러리를 찾았으면 if실행 if( FOO_LIBS ) set(FOO_LIBS_FOUND true) include_directories(...) message(STATUS \u0026#34;success to find library\u0026#34;) else() message(STATUS \u0026#34;failed to find libarary\u0026#34;) endif() ","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_2/","summary":"1. project 초기 설정 CMAKE_MINIMUM_REQUIRED [용법]\ncmake_minimum_required(VERSION major.minor[.patch[.tweak]][FATAL_ERROR]) 만약 어떤 오픈소스 라이브러리가 cmake 3.0 버전 이상으로 작성 되었고, 현재 나의 빌드환경은 cmake 2.8버전 미만이라면 빌드 시, 다음의 에러가 출력된다 -\u0026gt;\nCMake 3.0 or higher is required. You are running version 2.8.12.2\n이 커맨드는 반드시 CMakeListst.txt 작성시 맨 처음에 선언 해 놓아야 정상적인 버전 호환 에러를 출력할 수 있다.\n# Bad example project(foo) cmake_minimum_required(VERSION 3.0) message(\u0026#34;Using CMake version ${CMAKE_VERSION}\u0026#34;) PROJECT [용법]","title":"CMake Part2 - Commands \u0026 Vars"},{"content":"CMake? cmake란 cross platform 기반의 프로젝트 전체 빌드 프로세스를 관리해주는 유용한 툴이다. 직접 빌드를 수행하지는 않지만 지정된 OS에 맞는 Make파일 혹은 **솔루션(sln)**파일의 생성을 도와주어 소스코드 빌드를 편리하게 해준다.\nCmake의 장점 (root) |- foo.cpp |- CMakeLists.txt foo.cpp 라는 소스코드가 하나 있다고 가정하자. 이 소스코드를 각각의 다른 OS에서 빌드할 때, 윈도우즈라면 Visual Studio를, OSX라면 Xcode, Linux라면 Makefile을 이용할것이다. Cmake는 이런 귀찮은 과정을 CMakeLists.txt라는 프로젝트를 정의하는 파일을 하나 만듦으로써, 각 OS에 맞는 Build tool을 파악해 build command만 입력하면 될수 있도록 해준다.\nInstall $ sudo apt install cmake 의 명령어를 입력해 간단하게 설치할 수 있다.\n$ cmake --version 명령어를 입력해 cmake가 제대로 install 되었는지 확인한다.\nExample 1. Configure main.cpp 라는 파일이 있다고 하면, 같은 폴더 내 \u0026lsquo;CMakeLists.txt\u0026rsquo; 라는 파일을 새로 생성 후 아래와 같이 작성한다.\n# CMakeListst.txt cmake_minimum_required(VERSION 3.3) project (test) add_executable(test main.cpp) 2. Generate 이제 작성된 CMakeLists.txt를 기반으로 CMake가 native build tool을 생성할 것이다.\n커맨드창에 $ cmake .를 입력하면 마지막 줄에 아래처럼 나오며 Makefile이 생성된다.\n-- Configure done -- Generating done -- Build files have been written to: ... 3. Build $ make 커맨드를 입력하면 작성된 Makefile에 의하여 foo.cpp -\u0026gt; foo.cpp.o -\u0026gt; foo 의 과정을 통해 executable 파일이 생성된다.\n","permalink":"https://ralpioxxcs.github.io/post/cmake/cmake_1/","summary":"CMake? cmake란 cross platform 기반의 프로젝트 전체 빌드 프로세스를 관리해주는 유용한 툴이다. 직접 빌드를 수행하지는 않지만 지정된 OS에 맞는 Make파일 혹은 **솔루션(sln)**파일의 생성을 도와주어 소스코드 빌드를 편리하게 해준다.\nCmake의 장점 (root) |- foo.cpp |- CMakeLists.txt foo.cpp 라는 소스코드가 하나 있다고 가정하자. 이 소스코드를 각각의 다른 OS에서 빌드할 때, 윈도우즈라면 Visual Studio를, OSX라면 Xcode, Linux라면 Makefile을 이용할것이다. Cmake는 이런 귀찮은 과정을 CMakeLists.txt라는 프로젝트를 정의하는 파일을 하나 만듦으로써, 각 OS에 맞는 Build tool을 파악해 build command만 입력하면 될수 있도록 해준다.","title":"CMake Part1 - Overview"},{"content":"Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.\nShotcode 사용하기 shortcode는 { {\u0026lt; shortcodename parameters \u0026gt;} } 의 용법으로 간단하게 사용할 수 있다.\nshortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..) parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐 Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다.\ncode example { {\u0026lt; figure src=\u0026#34;/images/ar87.jpg\u0026#34; title=\u0026#34;GMK Oblivion\u0026#34; caption=\u0026#34;caption\u0026#34;\u0026gt;} } use example GMK Oblivioncaption\nhighlight 주로 code들을 highlight를 지원하는 언어들은 여기에서 확인할수 있다. 대부분의 언어를 지원한다.\ncode example { {\u0026lt; highlight cpp \u0026gt;} } #include\u0026lt;stdio.h\u0026gt; printf(\u0026#34;hello world!\\n\u0026#34;) { {\u0026lt; /highlight \u0026gt;} }\nuse example #include\u0026lt;stdio.h\u0026gt; printf(\u0026#34;hello world!\\n\u0026#34;)\n이외에도 instagram, gist, tweet등 다양한 shortcode를 제공한다.\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_4_shortcodes/","summary":"Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.\nShotcode 사용하기 shortcode는 { {\u0026lt; shortcodename parameters \u0026gt;} } 의 용법으로 간단하게 사용할 수 있다.\nshortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..) parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐 Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다.","title":"Hugo Content Management [4] - Shortcodes"},{"content":"Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. Formats Hugo는 다음 3가지의 마크업 언어를 지원한다.\nTOML : +++ YAML : --- JSON : {, }\n을 이용해 front matter의 시작과 끝을 지정한다. 예를들어, a.md라는 새로운 파일을 만들었다면 --- title: \u0026#34;this is title!\u0026#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,\n위처럼 front matter에 설정한대로, title과 date가 입력이된것을 볼수있다.\nVariables Hugo에서 미리 정의되고 바로 사용할수 있는 front matter 변수들은 다음과 같다.\ntitle content의 제목을 결정한다.\ndescription content의 설명\ndraft draft를 true를 설정하면, --buildDrafts 혹은 -D 플래그를 설정하지 않는 이상 이 파일은 hugo로 빌드?되어지지 않는다.\nweight content의 순서를 결정한다, 숫자가 낮을수록 상단에 위치하게 된다.\nAccss to front matter ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_3_frontmatter/","summary":"Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. Formats Hugo는 다음 3가지의 마크업 언어를 지원한다.\nTOML : +++ YAML : --- JSON : {, }\n을 이용해 front matter의 시작과 끝을 지정한다. 예를들어, a.md라는 새로운 파일을 만들었다면 --- title: \u0026#34;this is title!\u0026#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,\n위처럼 front matter에 설정한대로, title과 date가 입력이된것을 볼수있다.","title":"Hugo Content Management [3] - Front Matter"},{"content":"Hugo에서는 Page Bundles이라는 개념을 사용해 컨텐츠를 관리한다. Page Bundles에는 2가지 종류가 있다.\nLeaf Bundle Branch Bundle Left Bundle left bundle은 단독 페이지를 구성하는데 사용되고, index.md 파일을 포함하는 폴더로 구성된다.\n3 of Leaf Bundle Example content/ ├── project │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md │ └── study │ ├── first.md │ └── second.md │ └── index.md project 1개의 index.md파일만을 갖는 leaf bundle page\nmy-post 2개의 Markdown 컨텐츠와 index.md파일을 갖는 leaf bundle page\nstudy 2개의 Markdown 컨텐츠를 갖는 leaf bundle page\n* Headless Bundle headless bundle은 다음의 특징을 갖는다.\nPermalink를 갖지 않음 .Site.RegularPage의 부분에 속하지 않음\n다시말해, headless bundle은 어디에도 게시되지않는 무형의 페이지이다. 오직 leaf bundle만이 headless bundle로 만들어 질 수 있다.\n(추가예정)\nBranch Bundle branch bundle은 여러 페이지들을 구성하는데 사용되고, leaf bundle과는 다르게 _index.md 파일을 포함하는 폴더로 구성된다.\ncontent/ 디렉터리 안에 _index.md파일을 작성할 수도 있다.\n2 of Leaf Bundle Example content/ ├── branch_bundle_1 │ ├── branch_contents1.md │ ├── branch_contents2.md │ ├── branch_image1.png │ ├── branch_image2.png │ ├── _index_.md │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md ├── branch_bundle_2 │ ├── branch2_contents1.md │ ├── branch2_contents2.md │ ├── _index.md branch_bundle_1 2개의 Markdown 콘텐츠, 2개의 image, 1개의 leaf bundle, _index.md를 포함하는 branch bundle page\nmy-branch_bundle_2 2개의 Markdown 컨텐츠와 index.md파일을 갖는 branch bundle page index.md와 _index.md의 차이점 Left Bundle Branch Bundle 파일이름 index.md _index.md 사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing 사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_2_page/","summary":"Hugo에서는 Page Bundles이라는 개념을 사용해 컨텐츠를 관리한다. Page Bundles에는 2가지 종류가 있다.\nLeaf Bundle Branch Bundle Left Bundle left bundle은 단독 페이지를 구성하는데 사용되고, index.md 파일을 포함하는 폴더로 구성된다.\n3 of Leaf Bundle Example content/ ├── project │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md │ └── study │ ├── first.md │ └── second.md │ └── index.","title":"Hugo Content Management [2] - Page Bundle"},{"content":"Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.\n컨텐츠 구성 (root) └── content └── project | └── index.md // \u0026lt;- https://example.com/project/ ├── posts | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ └── study ├── first.md // \u0026lt;- https://example.com/study/first/ └── second.md // \u0026lt;- https://example.com/study/second/ 위 처럼 각각 project, posts, study 총 3개의 카테고리가 있다고 가정할 때, Hugo는 section, slug, path, url의 변수들을 이용해 컨텐츠를 관리한다.\nsection : default 컨텐츠 타입, content폴더의 어느위치에 있느냐에 따라 달라진다. slug : slug 변수는 각 컨텐츠 파일의 이름 (e.g., firstpost.md) 가 될수 있고, frontmatter에 의해 설정될 수 있다. path : section에서 slug 직전 까지의 경로 url : 컨텐츠의 상대적인 url, section부터 slug가 포함된 경로와 같다. . url . ⊢--^-⊣ . path slug . ⊢--^-⊣⊢---^---⊣ . filepath . ⊢------^------⊣ content/posts/firstpost.md 컨텐츠 경로 재정의 Hugo가 생성한 defualt 컨텐츠 경로를 frontmatter를 이용해 재정의(override)할 수 있다.\nslug\nslug를 재정의 하는 방법은 frontmatter에 slug를 추가한다.\n(e.g., content/posts/old-post.md) +++ title =\u0026#34;New Post\u0026#34; slug =\u0026#34;new-post\u0026#34; +++\n결과 : example.com/posts/new-post/\nurl\nURL또한 재정의(override)될 수 있다. url은 baseURL 다음으로 올 경로를 넣으면 된다. (참고로 --uglyURLs 옵션을 무시한다) (e.g., content/posts/old-url.md) +++ title =\u0026#34;old url\u0026#34; slug =\u0026#34;/blog/new-url\u0026#34; +++\nbaseURL이 ttps://example.com로 설정된 경우, 기존 url인 posts/old-url.md를 다음처럼 바꾼다.\n결과 : https://example.com/blog/new-url/ ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_content_management_1_contents_path/","summary":"Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.\n컨텐츠 구성 (root) └── content └── project | └── index.md // \u0026lt;- https://example.com/project/ ├── posts | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ └── study ├── first.md // \u0026lt;- https://example.com/study/first/ └── second.md // \u0026lt;- https://example.com/study/second/ 위 처럼 각각 project, posts, study 총 3개의 카테고리가 있다고 가정할 때, Hugo는 section, slug, path, url의 변수들을 이용해 컨텐츠를 관리한다.","title":"Hugo Content Management [1] - Contents Path"},{"content":"나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.\nStep 1. github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다.\nblog 폴더 자체를 저장할 repository hugo로 빌드된 결과파일들을 저장할 repository\n두번째 repository의 이름은 [github계정명].github.io의 형식으로 만들어야 한다. remote repository 연동 c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성한다. $ git remote add origin [첫번째 repository url]를 입력한다. $ git submodule add -b master [두번째 repository url] public을 입력하여 hugo로 빌드될 public폴더를 서브모듈로 연결한다. $ hugo -t [테마 폴더명]를 입력하면 hugo가 빌드를 시작하고 public 폴더가 생성이 된다. Step 2. 컨텐츠 배포 Commit c://hugo/blog/public 경로에서 git add . $ git commit -m \u0026quot;first commit\u0026quot; $ git push origin master c://hugo/blog 경로에서 위의 3과정 반복 Check 이제 https://github.com/계정명.github.io로 접속하여 블로그의 컨텐츠들이 업로드 되었는지 확인한다..\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_4_remote_repo_link/","summary":"나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.\nStep 1. github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다.\nblog 폴더 자체를 저장할 repository hugo로 빌드된 결과파일들을 저장할 repository\n두번째 repository의 이름은 [github계정명].github.io의 형식으로 만들어야 한다. remote repository 연동 c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성한다. $ git remote add origin [첫번째 repository url]를 입력한다. $ git submodule add -b master [두번째 repository url] public을 입력하여 hugo로 빌드될 public폴더를 서브모듈로 연결한다.","title":"Getting Started Hugo [4] - 레포지토리 연동 및 웹 호스팅"},{"content":"명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.\n( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.\ncontent 모든 게시글들 (contents)파일들은 content 디렉토리내에 쓰여지고 저장된다. 예를들면 사이트내에 3개의 주요 카테고리 (eg. blog, articles, tutorials) 가 있다고하면 content폴더내의 디렉토리 구조는 content/blog, content/articels, content/tutorials의 구조를 갖게된다.\ndata Hugo에서 site를 생성할 떄, 구성파일들을 저장하는데 사용되는 폴더이다. yaml, toml, json 형태로 쓸 수 있다.\nlayouts static site를 구성하는 모든 ~.html 확장자를 갖는 파일들을 저장한다. list pages, homepage, single page 등 더 많은 템플릿을 포함하고, hugo theme를 이용하는 사용자의 측면에서 가장 중요한 폴더이며, 이 부분을 수정하여 입맛에 맞게 수정하여 사용할 수도 있다.\nstatic CSS, JavaScript, image등의 정적인 파일들이 저장된 폴더이다. Hugo에 의해서 site를 생성할때, static폴더내의 파일들이 사용된다.\nthemes 이미 만들어진 hugo의 theme를 저장하는 폴더. theme를 사용하려면 이 폴더에 theme폴더를 저장하고 config파일을 수정하여야 한다.\nconfig config.toml, config.yaml, config.json의 형태로 작성되며, hugo site를 생성할 때 기본 설정파일의 역할을 한다. theme를 사용할 때, 이 부분을 수정하여 theme를 적용하듯이 site를 생성하는데 중요한 역할을 한다. 보통 theme마다 config를 적용하는 방법이 달라 각 theme의 config 내부를 잘 살펴보면 사용법이 적혀있다.\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_3_directory/","summary":"명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.\n( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.","title":"Getting Started Hugo [3] - 디렉터리 구조"},{"content":"Let\u0026rsquo;s create own blog Step 1. 블로그 폴더 생성 c://hugo 의 경로에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 blog로 하였다.)\n폴더를 만들었으면 $ cd blog \u0026amp;\u0026amp; ls 를 입력해 생성된 폴더의 내부를 확인한다.\n-\u0026gt; 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.\n테스트 $ hugo server 명령어를 입력하고 localhost:1313 을 크롬, 파이어폭스등 웹브라우저 주소창에 입력해 생성된 사이트를 확인해보자. 아직은 빈 화면만 있을것이다.\nStep 2. 테마 적용하기 hugo themes link 로 이동하여 원하는 테마를 선택한다. 각 테마 소개 화면에서 Demo를 클릭하면 각 블로그의 예시를 체험해볼 수 있다. 마음에 드는 테마를 찾았으면 Download 버튼을 클릭 후 테마의 repository 로 이동한다. 테마 다운로드 테마의 repository url를 복사한다. c://hugo/blog/themes 경로에서 $ git clone [repository url]를 입력하여 테마를 다운로드한다.\n($ git submodule 명령어를 사용하여도 된다. 사실 hugo getting started에서는 submodule 명령어로 테마를 추가하라고 명시되어있다.) 테마 적용 편집기를 이용해 config.toml파일을 연뒤, 마지막줄에 theme = \u0026quot;다운로드받은 테마 폴더명\u0026quot;을 추가해준다. Step 3. 컨텐츠 포스팅 테스트 파일 생성 c://hugo/blog의 경로로 돌아가 $ hugo new post/test.md 커맨드를 입력한다. 그러면 content 폴더안에 post 라는 폴더가 생기고 그 안에 test.md 파일이 생성된다. 확인하기 $ hugo server -D 커맨드를 입력하고 localhost:1313으로 들어가본다. 그러면 아까 생성한 test.md 글이 업로드 된것을 확인해 볼 수 있을것이다. 참고 각 테마마다 폴더 구성이 조금씩 다르지만, 기본적으로 테마를 받은 폴더안에는 exampleSite라는 폴더가 있을것이다. 만약 잘 안된다면 이 폴더를 잘보고 자신의 blog 로컬경로와 비교해가며 확인해보는 것도 좋다.\n","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_2_quick_start/","summary":"Let\u0026rsquo;s create own blog Step 1. 블로그 폴더 생성 c://hugo 의 경로에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 blog로 하였다.)\n폴더를 만들었으면 $ cd blog \u0026amp;\u0026amp; ls 를 입력해 생성된 폴더의 내부를 확인한다.\n-\u0026gt; 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.\n테스트 $ hugo server 명령어를 입력하고 localhost:1313 을 크롬, 파이어폭스등 웹브라우저 주소창에 입력해 생성된 사이트를 확인해보자.","title":"Getting Started Hugo [2] - 블로그 생성"},{"content":"Hugo? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.\nInstall 설치방법은 install hugo에 각 OS별로 설치를 하는 방법이 잘 안내되어 있다.\nOSX brew install hugo Debian, Ubuntu sudo apt-get install hugo package installer를 이용하는 방법외에는 Release 다운로드 사이트에서 직접 다운로드하여 설치하는 방법도 있다.\n설치가 끝났다면 hugo -help 를 터미널에 입력하여 아래의 메세지가 정상적으로 나오는지 확인한다.\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks config Print the site configuration convert Convert your content to different formats env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026#34;config\u0026#34;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don\u0026#39;t sync permission mode of files --noTimes don\u0026#39;t sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. ","permalink":"https://ralpioxxcs.github.io/post/hugo/hugo_start_1_install/","summary":"Hugo? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.\nInstall 설치방법은 install hugo에 각 OS별로 설치를 하는 방법이 잘 안내되어 있다.\nOSX brew install hugo Debian, Ubuntu sudo apt-get install hugo package installer를 이용하는 방법외에는 Release 다운로드 사이트에서 직접 다운로드하여 설치하는 방법도 있다.","title":"Getting Started Hugo [1] - 설치 및 환경설정"},{"content":" 선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다 큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.\n선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.( Front == Rear )\n데이터를 5개 모두 넣었다면 Rear값은 5가 되어있을것이고 큐가 모두 찼으므로 이 상태는 큐가 포화상태라는 것을 뜻 한다. ( 큐 Size == Rear )\n이렇게만 보면 선형 큐가 문제가 없어보이지만 바로 여기서 선형 큐의 맹점이 드러난다. 현재 큐가 꽉 차있는 상태에서 데이터를 하나 삭제하게되면 Front값이 1로 증가할것이고 빈 방 1개가 나올것이다, 그런데 Front는 1 이고 Rear는 5이므로 큐의 공백조건을 만족하지 못하므로 빈 방이 있음에도 불구하고 큐의 데이터삽입이 불가능하게 된다. 이러한 맹점을 보완한것이 바로 **원형 큐 (Circular Queue)**이다.\n원형 큐 (Circula Queue) Circular Queue는 선입선출(先入先出, First In First Out; FIFO)를 그대로 유지하면서 큐의 입구와 출구를 연결하여 원형으로 만들어 사용하는 구조이다.이때, Front와 Rear사이에 완충지대를 두어 원형 큐의 비어있는 상태와 포화상태를 구분한다. 완충지대의 위치는 항상 Front의 하나 앞방이다. (유동성)\n완충지대 때문에 예를들어 7개의 데이터를 넣는 큐를 만드려면 큐의 사이즈를 8으로 지정하여야한다. 초기에는 Front와 Rear는 0으로 설정한다. 자동으로 완충지대는 [7]번방이 된다.\n원형 큐 에서는 Rear값 및 Front값을 증가시킬때 선형 큐처럼 단순히 +1을 하게되면 원형 큐가 되지 않으므로 \u0026ldquo;%\u0026rdquo; 기능을 활용하여 Rear값을 바꿔준다.\nRear가 0번방에서 1번방으로 가야하므로 +1을 해준뒤 큐 사이즈만큼 나눠주고 나머지 값을 Rear값으로 하면 된다. Rear = (Rear+1) % QueueSize\n계속 데이터를 삽입하여 7번방까지 데이터를 삽입하였다면 Rear가 완충지대를 가리키고 있을것이고 이 상태는 포화상태를 의미한다. 즉, Rear가 완충지대를 가리키고있다면 큐는 포화상태라는 뜻이다. 공백상태는 선형 큐와 같다. Rear와 Front가 같으면 공백상태를 뜻한다.\n그러면 여기서, 아까 선형 큐가 해결하지 못했던 문제를 해결할 수 있다. 데이터가 꽉 차있는 상태에서 Dequeue를 하여 Front값을 1로 바꿔준다 ( Front = (Front +1) % QueueSize )\n그러면 자동으로 완충지대는 Front가 이동하였으므로 원래위치 7번방에서 (Front의 이전 방) 0번방으로 옮겨갈 것이다.\n따라서, Rear는 완충지대를 가리키고 있지 않으므로 큐의 포화조건에서 탈출하게 되고 데이터의 삽입이 가능해진다. Rear가 7번방이었으므로 위와같이 ( Rear = (Rear+1) % QueueSize ) 를 이용하면 Rear는 0번방을 가리키며 0번방에 데이터를 삽입하게 된다.\nImplementation structure typedef struct _queue { DataType *queue; int qSize; int front, rear; }Queue; 큐를 관리하는 구조체\n데이터를 저장할 데이터필드 영역과 큐의 크기를 저장하는 변수, Front와 Rear를 지정하는 변수로 이루어져있다.\ninitialize void initQueue(Queue * qPtr, int size) { qPtr-\u0026gt;qSize = size; qPtr-\u0026gt;front = 0; qPtr-\u0026gt;rear = 0; qPtr-\u0026gt;queue = (DataType *)calloc(qPtr-\u0026gt;qSize, sizeof(DataType)); } 큐를 초기화 및 생성하는 함수\n전달인자로 큐의 사이즈를 받아서 큐의 사이즈를 넣어주고, Front와 Rear의 값을 모두 0으로 초기화한뒤 calloc함수를 통해 size만큼 메모리를 할당받는다.\nenqueue int enqueue(Queue * qPtr, DataType inData) { // rear가 완충지대에 있으면 put불가 if((qPtr-\u0026gt;rear+1)%qPtr-\u0026gt;qSize == qPtr-\u0026gt;front){ return FALSE; } qPtr-\u0026gt;queue[qPtr-\u0026gt;rear] = inData; qPtr-\u0026gt;rear++; qPtr-\u0026gt;rear = (qPtr-\u0026gt;rear)%qPtr-\u0026gt;qSize; return TRUE; } 큐에 데이터를 삽입하는 함수\n처음 조건문을 걸어서 큐가 비어있는지 확인한다. Rear가 완충지대에 있으면 큐가 포화상태인것이므로 True시 False를 리턴한다. False일시, 아래 코드로 내려와서 현재 Rear값에 데이터를 넣어주고, Rear값 증가한다.\n(Rear = (Rear+1) % QueueSize)\ndequeue int dequeue(Queue * qPtr, DataType * getData) { // 큐가 비어있으면 dequeue 불가 if( isQueueEmpty(qPtr) ) { return FALSE; } *getData = qPtr-\u0026gt;queue[qPtr-\u0026gt;front]; qPtr-\u0026gt;front++; qPtr-\u0026gt;front = (qPtr-\u0026gt;front)%qPtr-\u0026gt;qSize; return TRUE; } 큐에서 데이터를 빼와 출력하는 함수\n전달인자로 출력할 데이터의 주소값을 받아오고 초기 조건문으로 큐가 비어있는지 함수를 통해 확인, 비어있지않을시, Front방의 값을 불러오고 front를 하나 증가시킨다.\n( Front = (Front +1) % QueueSize )\ncheck int isQueueEmpty(const Queue *qPtr) { if(qPtr-\u0026gt; front == qPtr-\u0026gt;rear) return TRUE; else return FALSE; } 큐가 비었는지 확인하는 함수로 Front와 Rear가 같을때 큐가 빈것으로 판별\n","permalink":"https://ralpioxxcs.github.io/post/cs/queue/","summary":"선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다 큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.\n선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.","title":"C로 구현하는 자료구조 - Queue"},{"content":" \u0026ldquo;트리 (Tree)\u0026rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 \u0026ldquo;루트노드 (Root Node)\u0026rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 \u0026ldquo;서브 트리 (Sub Tree)\u0026ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 \u0026ldquo;부모 노드 (Parent Node)\u0026rdquo; 라고 하고 그 바로 아래 노드들을 \u0026ldquo;자식 노드 (Children Node)\u0026ldquo;라 한다.\n이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다. 이런 이진트리에서는 서브트리가 2개 이하기 때문에 서브트리는 왼쪽과 오른쪽으로 구분된다.\n이진트리를 구현하는 방법으로 배열과 링크드리스트 2가지가 있다.\n배열 배열로 구현하게 될 경우, 연결리스트로 구현하는것보다 더 복잡하고 생각해야할것이 많다. 하지만 그렇다고해서 아예 안쓰이지는 않고, 힙 트리의 경우 배열로 구현하게 되는 경우가 많다. 배열로 구현하는 방법은 다음과 같다.\n우선, 0번방은 비워놓고 루트노드를 1번방으로 시작하여 내려간다. 임의의 노드를 탐색하고 싶은 경우 해당 배열 방 번호를 입력하면 된다. [그림 2]처럼 데이터 4의 노드에서 오른쪽 자식노드(5)를 가고자 하면 =\u0026gt; (2 x i ) + 1 을 해주면 데이터 5의 방 번호가 나온다.\n정리하면,\n노드 i의 부모 노드 = i/2 노드 i의 왼쪽 자식 노드 = 2 x i 노드 i의 오른쪽 자식 노드 = ( 2 x i ) + 1 루트 노드 = 1 배열로 구현하는 방법의 장점은 시간복잡도를 줄일수 있다는 점이 있지만, 편향 진트리의 경우 사용하지 않는 배열 원소에 대한 메모리 낭비가 발생하고, 삽입/삭제에 대한 배열의 크기 변경이 어렵다는 점이 있다.\n링크드리스트 링크드 리스트로 구현하는 방법은 배열로 구현하는것보다 더 쉽고 접근에 있어서 더 직관적이다. 하지만, 배열 구조에서만 가능한 임의 노드로의 접근이 불편(?)하다. 데이터가 커질수록 전위,후위 순회 하는 속도가 더 느려지므로 탐색시간에 있어서 링크드 리스트가 배열 구조보다 시간이 더 오래걸린다는 점이 있다.\n구조체 정의 typedef struct _node Node; typedef struct _node { DataType data; Node *left; Node *right; }Node; typedef struct _tree { Node *root; int nodeCnt; }Tree; 그림3 처럼 노드의 구조체를 코드처럼 데이터방, 노드포인터 왼쪽,오른쪽 변수를 가지는 구조체를 선언하고, 트리관리 구조체를 하나 선언한다. 트리관리 구조체를 선언하는 이유는 노드의 삽입 및 삭제 시 노드의 갯수를 저장해주는 공간의 필요와 삭제 시에 루트노드가 바뀌는 경우가 있으므로 루트노드를 지정해주기 위해 선언한다.\n트리 초기화 void initTree(Tree *tr) { tr-\u0026gt;root = NULL; tr-\u0026gt;nodeCnt = 0; } 루트노드를 NULL 값으로 초기화하고, 노드의갯수를 0으로 초기화 한다.\n노드 생성 Node *makeNode(DataType *data, Node *left, Node *right) { Node *node = (Node*)calloc(1,sizeof(Node)); if (node != NULL) { node-\u0026gt;data = *data; node-\u0026gt;left = left; node-\u0026gt;right = right; } return node; } 전달인자로 왼쪽노드와 오른쪽노드의 주소를 받아 해당 데이터를 메모리할당한 공간에 삽입해주고 왼쪽과 오른쪽의 주소값을 연결해준다.\n이진 탐색 트리 [그림 4]의 트리구조를 보면 조건이 하나 있다. 부모노드를 기준으로 왼쪽자식은 부모노드의 값보다 더 작은 값, 오른쪽 자식은 부모노드의 값보다 더 큰 값을 가지고 있다. 그 아래 서브트리도 마찬가지로 왼쪽이 작은 값 오른쪽이 큰 값을 가지는 형태로 이루어져있다.\n예를 들어, [그림 4]의 \u0026ldquo;21\u0026rdquo; 데이터를 찾는다고 하면, 루트노드 10을 기준으로 하여 대/소 비교를 하며 트리 아래로 내려간다. 첫번째로 현재 노드가 찾을 값과 같은지 비교하고 같지 않으면 10과 21을 비교한다. 21이 더 크므로 오른쪽 자식으로 내려가고 그 다음 18과 비교하여 21이 더 크므로 오른쪽으로 간다. 이런 조건을 가지는 트리를 \u0026ldquo;이진 탐색 트리 (Binary Search Tree)\u0026rdquo; 라고 부른다.\n다음은 그 과정을 코드로 구현한 것이다.\n노드 탐색 Node *searchNode(Tree *tr, DataType *data, int(*compare)(DataType*, DataType*)) { Node *temp = tr-\u0026gt;root; while (temp != NULL) { if (*data == temp-\u0026gt;data) { return temp; } if (compare(data, \u0026amp;temp-\u0026gt;data) \u0026gt; 0) { temp = temp-\u0026gt;right; } else { temp = temp-\u0026gt;left; } } return NULL; } 배열처럼 임의의 노드를 찾기위해 방 번호를 입력하는게 아닌 임시노드를 하나 선언하여 루트노드로 지정해준 뒤 모든 노드를 이진 트리 조건에 맞춰서 순회하여 값을 찾는 방식이다.\n노드 삽입 Node *addNode(Tree *tr, DataType *data, int(*compare)(DataType *, DataType*)) { Node *newNode; Node *parent = tr-\u0026gt;root; Node *son = tr-\u0026gt;root; newNode = makeNode(data, NULL, NULL); // 새로운노드 할당 if (newNode == NULL) // 메모리할당 실패시 리턴 return NULL; // 루트노드에 add할지 아닐지 검사 if (tr-\u0026gt;root != NULL) {// 루트노드 아닌경우 // parent,son포인터 이용하여 값 대입할 곳 위치찾기 while (son != NULL) { // son이 null이 될때까지 반복 if (compare(data,\u0026amp;son-\u0026gt;data)\u0026gt;0) {// 대입할 값이 더 큰경우 -\u0026gt; 오른쪽 parent = son; son = son-\u0026gt;right; } else if(compare(data, \u0026amp;son-\u0026gt;data)\u0026lt;0) { // 대입할 값이 더 작은경우 -\u0026gt; 왼쪽 parent = son; son = son-\u0026gt;left; } } // 대소비교하여 노드삽입 if (compare(data, \u0026amp;parent-\u0026gt;data)\u0026gt;0) {// 오른쪽으로 parent-\u0026gt;right = newNode; } else if (compare(data, \u0026amp;parent-\u0026gt;data)\u0026lt;0) { // 왼쪽으로 parent-\u0026gt;left = newNode; } tr-\u0026gt;nodeCnt++; // 노드카운트 ++ } else { // 루트노드인 경우 tr-\u0026gt;root = newNode; tr-\u0026gt;nodeCnt++; } return newNode; } 노드 삽입은 이진탐색트리 조건에 맞춰 노드를 삽입한다. 우선 변수로 \u0026lt; 1) 삽입할 새로운 노드 2) 임시로 부모노드 역할 해줄 노드 3) 임시로 자식노드 역할 해줄 노드 \u0026gt; 를 선언한다. 임시로 부모노드와 자식노드를 지정하는 이유는 이진탐색트리 조건에 맞춰서 대소비교를 하며 노드 아래로 내려가야 하기 때문에 노드의 주소가 바뀌지 않도록 임시변수를 지정해 주는 것이다. 부모노드, 자식노드 둘다 초기값으로 루트노드를 지정해준다.\n새로운노드 메모리를 할당해준뒤, 맨 첫번째로 할 것은 삽입할 곳이 루트노드인지 루트노드가 아닌지 검사하는것이다. 이 과정은 처음만 일어나는 경우지만 이 조건이 없다면 루트노드가 수시로 바뀌어 트리의 구조가 엉망이 될 것이다.\n다음으로, 부모와 자식 포인터노드를 이용하여 대입할 곳의 위치를 찾는 작업이다. 대/소 조건에 맞춰 부모노드와 자식노드를 같게 해준뒤 대입할 값보다 자식노드가 클 경우 자식노드는 자기사진의 왼쪽노드 \u0026hellip;작을경우 오른쪽노드로 옮긴다. 이 과정을 반복하다보면 자식노드가 null이 되는데 이때 반복문이 종료되고 현재 임시부모노드의 위치는 삽입할 곳의 부모노드 위치가 된다.\n그 상태에서 마지막으로, 대소비교를하여 데이터가 부모노드 ( 현 임시부모노드위치 ) 보다 크면 오른쪽에 , 작으면 왼쪽에 삽입하는 식으로 부모노드의 오른쪽,왼쪽에 새로운노드 주소를 연결해줌으로 끝이난다.\n그리고 마지막으로 노드 카운트 (갯수) 를 증가시켜준다.\n노드 삭제 Node *deleteNode(Tree *tr, DataType *data, int(*compare)(DataType*, DataType*)) { Node *temp = tr-\u0026gt;root; // 삭제할 노드 임시 저장 포인터 Node *parent = tr-\u0026gt;root; Node *child; // 삭제할 노드 위치 검색 while ((temp!=NULL)\u0026amp;\u0026amp; (temp-\u0026gt;data != *data)) {// 찾을때까지 반복 parent = temp; if (compare(data, \u0026amp;temp-\u0026gt;data) \u0026gt; 0) // 대입할 값이 더 큰경우 -\u0026gt; 오른쪽 temp = temp-\u0026gt;right; else if (compare(data, \u0026amp;temp-\u0026gt;data) \u0026lt; 0) // 대입할 값이 더 작은경우 -\u0026gt; 왼쪽 temp = temp-\u0026gt;left; } if (temp == NULL) { return temp; } // 유형 1 (삭제할 노드의 오른쪽 자식이 없는 경우) if (temp-\u0026gt;right == NULL) { child = temp-\u0026gt;left; // 삭제할 노드의 왼쪽자식을 임시포인터 child에게 준다 if (compare(data, \u0026amp;parent-\u0026gt;data) \u0026gt; 0) {// 삭제할 노드가 삭제할노드의부모보다 컸다면 parent-\u0026gt;right = child; // 삭제할노드부모노드 오른쪽에 child 붙인다 } else { // 삭제할 노드가 삭제할노드의부모보다 작았다면 parent-\u0026gt;left = child; // 삭제할노드부모노드 왼쪽에 child 붙인다 } } // 유형 2 (삭제할 노드의 오른쪽 자식의 왼쪽자식이 없는 경우) else if (temp-\u0026gt;right-\u0026gt;left == NULL) { child = temp-\u0026gt;right; // 삭제할 노드의 오른쪽자식을 임시포인터 child에게 준다 if (compare(data, \u0026amp;parent-\u0026gt;data) \u0026gt; 0) { // 삭제할 노드가 삭제할노드의부모보다 컸다면 parent-\u0026gt;right = child; // 삭제할노드부모노드 오른쪽에 child 붙인다 child-\u0026gt;left = temp-\u0026gt;left; } else { // 삭제할 노드가 삭제할노드의부모보다 작았다면 parent-\u0026gt;left = child; // 삭제할노드부모노드 왼쪽에 child 붙인다 child-\u0026gt;left = temp-\u0026gt;left; } } // 유형 3 (그 외 모든 경우) else { Node *tempp; tempp = temp; child = temp-\u0026gt;right; while (child-\u0026gt;left != NULL) { // child노드의 왼쪽이 없을때까지 탐색 tempp = child; child = child-\u0026gt;left; } tempp-\u0026gt;left = child-\u0026gt;right; if (temp == tr-\u0026gt;root) {// 삭제하려는 노드가 루트노드랑 같은경우 tr-\u0026gt;root = child; tr-\u0026gt;root-\u0026gt;right = temp-\u0026gt;right; tr-\u0026gt;root-\u0026gt;left = temp-\u0026gt;left; } else {// 루트노드가 아닌경우 temp = child; // 삭제한 자리에 child값 주고 child-\u0026gt;right = temp-\u0026gt;right; // 노드 이어줌 child-\u0026gt;left = temp-\u0026gt;left; } } free(temp); return parent; } 노드를 삭제하는 과정은 꽤나 까다롭다. 링크드 리스트나 스택, 큐 자료구조와 달리 계층구조로 이루어져 있기 때문에 임의의 한 노드를 삭제한다고 하면 그 임의의노드의 부모노드, 자식노드, 경우에 따라 루트노드까지 바꿔주어야하기 때문에 고려할것이 많다. 그 수많은 케이스를 3분류로 나눌 수 있는데 그것은 아래와 같다.\nCase 1 : 삭제할 노드의 오른쪽 자식이 없는 경우 Case 2 : 삭제할 노드의 오른쪽 자식의 왼쪽 자식이 없는 경우 Case 3 : 그 외의 모든 경우 우선 삭제하기 전 노드삽입때와 마찬가지로 몇 가지 변수를 선언해주어야 한다. \u0026lt; 1) 삭제할 노드의 부모노드 2) 삭제할 노드대신 자식역할을 할 노드 3) 삭제할 노드 \u0026gt; 이다. 1)과 3)의 변수를 루트노드의 주소로 초기화 시켜준다. 처음으로 삭제 할 노드를 찾기 위해 반복문을 설정해준다. 과정은 노드탐색 함수와 비슷하게 대소비교를 하며 탐색한다. 탐색이 완료되면 3) 삭제할 노드 변수에는 삭제할 노드의 주소가 지정돼있을것이고 1) 부모노드 에는 삭제할 노드의 부모노드의 주소가 지정이 됐을것이다.\n다음은 Case를 분류한다. 유형 1의 경우 간단하므로 2) 자식노드 변수에 삭제할 노드의 왼쪽주소를 넣어준다.\n유형 2의 경우 삭제할 노드의 오른쪽 자식이 자식노드 역할을 한다. 자식노드에 삭제할 노드 (del)의 오른쪽 주소를 넣어주고 삭제할 노드의 왼쪽노드랑 연결해 주어야하므로 자식노드의 왼쪽에 삭제할 노드 (del)의 왼쪽주소를 넣어준다.\n유형 3의 경우는 1,2의 경우를 제외한 모든 경우를 뜻하는데, 이 케이스가 가장 많고 생각해내기가 좀 까다롭다. 간단히 말하면 삭제를 하고하 하는 노드가 자식을 모두 가지고 있는 경우이다. [그림4] 를 예시로 들어 설명하겠다.\n예를들어, 10값을 가진 노드를 삭제한다고 가정하자. 10노드를 삭제하게 되면 10의 자리에는 어떤 값이 들어가야 할까? 이진탐색트리의 조건에 맞춰서 6보다는 크고 18보다는 작아야 한다. 그 값은 두 가지로 구할수 있다. 하나는 삭제하고자 하는 노드의 왼쪽노드 부분에서 최대값을 찾는 것이고 하나는 삭제하고자 하는 노드의 오른쪽노드 부분에서 최솟값을 찾는것이다. 전자는 \u0026ldquo;8\u0026rdquo; 이 될 것이고 후자의 경우 \u0026ldquo;15\u0026rdquo; 가 될 것이다.\n여기서는 후자의 경우 ( 최소값찾기 ) 로 설명하겠다. 임시노드 temp를 하나 선언해준다. temp값에는 삭제할 노드 (del)의 오른쪽 주소로 초기화해준다. 그리고 오른쪽노드 부분에서 최소값을 찾기위해 반복문을 설정하는데 최소값은 왼쪽 노드로 계속 이동해야하므로 왼쪽노드가 null 이 될 때까지 반복문을 설정한다. 모두 끝나면 temp는 최솟값을 담고있는 노드의 부모노드 주소를 가지고 있게된다. 2) 자식노드 (son) 에도 temp의 왼쪽주소값을 지정해준다. ( 최소값 노드 ) 이제 \u0026ldquo;10\u0026quot;의 위치에 2) 자식노드 (son)을 넣어주어야 하므로 son의 왼쪽에 \u0026ldquo;10\u0026quot;의 왼쪽노드주소, son의 오른쪽에 \u0026ldquo;10\u0026quot;의 오른쪽노드주소를 주며 인수인계 작업을 해준다.\n마지막으로 free함수를 이용하여 del 노드를 메모리 해제하며 끝낸다.\n노드 붕괴 void destroyTree(Tree *tr, void(*print)(DataType *)) { postorderDelete(tr-\u0026gt;root, print); tr-\u0026gt;nodeCnt = 0; tr-\u0026gt;root = NULL; } 이 함수는 트리의 모든 노드를 소멸시키는 함수로 후위순회를 해주며 각 노드마다 free() 메모리 해제를 해주며 순차적으로 없애나간다.\n노드 붕괴 (후위 순회식) void postorderDelete(Node *np, void(*print)(DataType *)) { if (np != NULL) { postorderTraverse(np-\u0026gt;left, print); postorderTraverse(np-\u0026gt;right, print); print(\u0026amp;np-\u0026gt;data); free(np); // 노드 삭제 } printf(\u0026#34;\\n\\n\u0026#34;); } 노드붕괴함수에 연계되는 함수로 후위순회의 방식을 따르면서 추가로 free() 메모리해제를 해준다.\n노드 순회 \u0026ldquo;순회 (Traversal)\u0026rdquo; 란 이진트리의 모든 노드를 특정한 순서대로 한 번씩 방문하는 것이다. 순회방법으로는\n전위순회 (Pre Order) 중위순회 (In Order) 후위순회 (Post Order) 방식이 있다. 전위 순회 void preorderTraverse(Node *np, void(*print)(DataType *)) { if (np != NULL) { print(\u0026amp;np-\u0026gt;data); preorderTraverse(np-\u0026gt;left, print); preorderTraverse(np-\u0026gt;right, print); } } 전위순회는 루트노드를 먼저 방문하고 왼쪽 서브트리, 오른쪽 서브트리 순으로 방문하는 방법이다. 왼쪽서브트리를 모두 방문하고 왼쪽방이 더 이상 없으면 그 이전 노드로 돌아가 오른쪽 노드를 탐색하고 왼쪽,,,또 오른쪽..이런 순으로 방문한다.\n중위 순회 void inorderTraverse(Node *np, void(*print)(DataType *)) { if (np == NULL) { return; } inorderTraverse(np-\u0026gt;left, print); print(\u0026amp;np-\u0026gt;data); inorderTraverse(np-\u0026gt;right, print); } 중위순회는 먼저 왼쪽부터 방문한 뒤 루트노드를 탐색하고 오른쪽 서브트리를 방문한다.\n후위 순회 void postorderTraverse(Node *np, void(*print)(DataType *)) { if (np == NULL) { return; } postorderTraverse(np-\u0026gt;left, print); postorderTraverse(np-\u0026gt;right, print); print(\u0026amp;np-\u0026gt;data); } 후위순회는 왼쪽 서브트리, 오른쪽 서브트리, 그리고 마지막에 루트노드를 방문한다.\n","permalink":"https://ralpioxxcs.github.io/post/cs/binary_tree/","summary":"\u0026ldquo;트리 (Tree)\u0026rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 \u0026ldquo;루트노드 (Root Node)\u0026rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 \u0026ldquo;서브 트리 (Sub Tree)\u0026ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 \u0026ldquo;부모 노드 (Parent Node)\u0026rdquo; 라고 하고 그 바로 아래 노드들을 \u0026ldquo;자식 노드 (Children Node)\u0026ldquo;라 한다.\n이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다.","title":"C로 구현하는 자료구조 - Binary Tree"},{"content":"Graph 그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.\n(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)\nImplementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다. ( 0번방 -\u0026gt; A , 1번방 -\u0026gt; B\u0026hellip; 이런 식) 구조체에는 인접행렬을 표기할 배열 graph 2차원 배열, 정점의 갯수와 간선의 갯수를 저장해줄 int형 변수들을 선언해준다.\nInit graph void initGraph(GraphMatrix *gm, char *fileName) { FILE *pFile = fopen(fileName, \u0026#34;r\u0026#34;); char str[3]; if (pFile == NULL) { printf(\u0026#34;불러오기 실패\\n\u0026#34;); } else { fscanf(pFile, \u0026#34;%d\u0026#34;, \u0026amp;gm-\u0026gt;vertexcnt); // 정점갯수 가져옴 fscanf(pFile, \u0026#34;%d\u0026#34;, \u0026amp;gm-\u0026gt;edgeCnt); // 간선갯수 가져옴 for (int i = 0; i \u0026lt; gm-\u0026gt;vertexcnt; i++) { // 배열 방 \u0026#39;0\u0026#39; 으로 초기화 for (int j = 0; j \u0026lt; gm-\u0026gt;vertexcnt; j++) { gm-\u0026gt;graph[i][j] = 0; } } for (int k = 0; k \u0026lt; gm-\u0026gt;edgeCnt; k++) { fscanf(pFile, \u0026#34;%s\u0026#34;, str); str[0] = str[0] - 65; str[1] = str[1] - 65; // ex) str[3] = { 0 , 1 } gm-\u0026gt;graph[str[0]][str[1]] = 1; gm-\u0026gt;graph[str[1]][str[0]] = 1; } } } 이 글에서는 행렬 텍스트 파일을 파일입출력을 통해 불러와 반복문을 통해 배열에 입력하는 방식으로 구현했다. FILE 함수를 통해 파일을 읽어들인 후, 간선, 정점의 갯수를 모두 읽는다.\n우선, 인접행렬영역을 0 (방문X)로 초기화를 해주고, 무방향 그래프에서의 대칭성을 고려하여 간선의 갯수만큼 반복문을 이용해 행렬에 입력한다.\nPrint graph void outputGraph(GraphMatrix *gm) { printf(\u0026#34; \u0026#34;); for (int k = 0; k \u0026lt; gm-\u0026gt;vertexcnt; k++) { printf(\u0026#34; [%c]\u0026#34;, 65 + k); } for (int i = 0; i \u0026lt; gm-\u0026gt;vertexcnt; i++) { printf(\u0026#34;[%c]\u0026#34;, 65 + i); for (int j = 0; j \u0026lt; gm-\u0026gt;vertexcnt; j++) { printf(\u0026#34;%5d\u0026#34;, gm-\u0026gt;graph[i][j]); } } } DFS 그래프내의 각 정점들을 간선을 타고 중복없이 한 번씩 방문하는 방법으로 깊이 우선 탐색 ( Depth First Search ) 법과 너비 우선 탐색 ( Breadth First Search)법이 있다. 무방향 그래프는 특성상 방향이 없기때문에 순회 순서가 유일하지 않다는 특징이 있다. 2가지 중 하나인 \u0026ldquo;깊이 우선 탐색(DFS)\u0026rdquo; 는 탐색을 시작할 정점에 연결된 정점 중 하나를 선택하여 들어가고 그 하나와 연결된 정점들 중 또 하나를 선택해서 들어가고 깊이 들어가는 방식으로 탐색하는 기법이다. DFS의 과정은 스택을 사용하므로 재귀와 비재귀로 구현 할 수 있다\nRecursive dfs void DFS_recursive(GraphMatrix *gm, int vNum) { int i; check[vNum] = 1; /* 방문한 정점 표시를 위해 1 저장 */ visit(vNum); /* 방문에 따른 처리 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { if(gm-\u0026gt;graph[vNum][i] != 0) { /* 연결된 정점이 있으면 */ if(check[i] == 0) { /* 또한 방문한 적이 없는 정점이면 */ DFS_recursive(gm, i); /* 재귀 호출을 통해 정점 방문을 한다 */ } } } } 전달인자로 받은 정점번호를 방문처리 해준 뒤, ( 1로 바꿈 ) 그 정점을 visit함수 ( 출력 ) 한다. 다음으로, 정점갯수만큼 반복문을 설정.. 해당 정점에 연결된 정점이 있고 그 정점이 방문배열에서 방문한 적이 없는 정점 이라면 재귀호출을 통해 정점 방문 처리를 해준다.\nNon-Recursive dfs void nrDFS_Matrix(GraphMatrix *gm) { int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026amp;stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; } for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { push(\u0026amp;stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026amp;stack) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { pop(\u0026amp;stack, \u0026amp;popData); visit(popData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) if(gm-\u0026gt;graph[popData][j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { push(\u0026amp;stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyStack(\u0026amp;stack); return; } 재귀기법을 사용하지 않으면 스택자료구조를 이용해야한다. 스택 초기화 및 생성을 하고 재귀방법과 똑같이 체크배열은 0으로 시켜준다. 순차적으로 정점을 방문한다. 그 정점이 방문한경우가 아니라면 스택에 그 정점을 푸쉬하고 방문상태를 바꿔준다 ( 1로 ) 그리고 스택이 모두 비면 한 연결 요소에 대해 순회가 끝난것을 의미하므로 스택이 빌 때까지 반복문을 걸어준다. pop을 하여 정점을 꺼내고 해당 정점에 연결된 정점이 있고 방문처리 되지 않은 경우 그 인접정점을 스택에 넣고 방문처리를 해준다. 이런 과정을 모두 하고나면 모든 정점에 대해 순회가 완료된다.\nBFS 너비우선탐색 (BFS) 는 시작한 정점과 연결된 모든 정점을 탐색하고 다시 시작 정점의 다른 연결된 정점을 찾는 순으로, 깊이 들어가기전에 옆으로 넓게 퍼지며 탐색하는 기법이다. DFS와 달리 너비우선탐색 (BFS) 는 스택을 사용하지않고 큐 자료구조를 이용해야 한다. 따라서 재귀호출기법으로는 구현할 수 없다.\nvoid BFS_Matrix(GraphMatrix *gm) { int i, j; int getData; /* dequeue(get)한 데이터 저장 */ Queue queue; initQueue(\u0026amp;queue, MAX_VERTEX); /* 큐 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; } for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { /* 순차적으로 정점을 방문함 */ if(check[i] == 0) { /* 방문하지 않은 정점을 발견 하면 */ enqueue(\u0026amp;queue, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isQueueEmpty(\u0026amp;queue) ) { /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ dequeue(\u0026amp;queue, \u0026amp;getData); visit(getData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) if(gm-\u0026gt;graph[getData] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) { /* j정점이 스택에 들어있지 않으면 */ enqueue(\u0026amp;queue, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyQueue(\u0026amp;queue); return; } 과정은 DFS랑 매우 비슷하다. 자료구조만 스택에서 큐로 바꾸면 바로 너비우선탐색법이 된다. 큐를 선언 및 초기화 후 체크배열을 초기화한다. 그리고 시작 정점을 기준으로 하여 큐에 넣고 큐가 빌때까지 반복문, 인접정점, 방문 유무를 판단한다. [그림 3] 을 예로들어서 설명하면 \u0026ldquo;1\u0026quot;을 시작으로 Enqueue한뒤, \u0026ldquo;1\u0026quot;의 인접정점 8 , 5, 2 를 순서대로 모두 Enqueue한다. 그리고 Dequeue를 하면 큐 특성상 첫번째로 넣은 값이 나오게 되므로 8을 방문처리하고 8의 인접정점 6 ,4 ,3 을 모두 Enqueue 그 다음 5를 Dequeue\u0026hellip; 5는 인접정점이 없으므로 다음 Dequeue 2를 방문\u0026hellip;이런 식으로 옆으로 넓게 퍼지며 탐색을 한다.\nprint graph int countGraphComponents(GraphMatrix *gm) { int componetsCount=0; /* 그래프 내의 연결 요소 카운트 변수 */ int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026amp;stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; } for(i=0; i\u0026lt;gm-\u0026gt;vertexCnt; ++i) { /* 순차적으로 정점을 방문함 */ if(check[i] == 0) { /* 방문하지 않은 정점을 발견 하면 */ ++componetsCount; /* 방문하지 않은 정점을 발견되면 연결 요소 카운트를 증가 시킴 */ printf(\u0026#34;\\n연결 요소 %d : \u0026#34;, componetsCount); push(\u0026amp;stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026amp;stack) ) { /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ pop(\u0026amp;stack, \u0026amp;popData); visit(popData); /* 정점 방문 */ for(j=0; j\u0026lt;gm-\u0026gt;vertexCnt; ++j) { if(gm-\u0026gt;graph[popData][j] != 0) { /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) { /* j정점이 스택에 들어있지 않으면 */ push(\u0026amp;stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } } } destroyStack(\u0026amp;stack); return componetsCount; } print graph ","permalink":"https://ralpioxxcs.github.io/post/cs/graph_matrix/","summary":"Graph 그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.\n(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)\nImplementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다.","title":"C로 구현하는 자료구조 - Graph"},{"content":"자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.\nImplementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,\n순회를 하기 위한 Head, Tail 노드만을 가리키는 노드 포인터와 현재 노드 가리킴 및 여러 용도로 쓰이는 노드 포인터, 노드의 개수를 저장하는 int형 변수로 이루어져 있다. initalization void create(LinkedList * lp) { lp-\u0026gt;head = (Node *)malloc(sizeof(Node)); //헤드 노드 생성 assert(lp-\u0026gt;head!=NULL); lp-\u0026gt;tail = (Node *)malloc(sizeof(Node)); //테일 노드 생성 assert(lp-\u0026gt;tail!=NULL); /*head node와 tail node를 연결 함*/ lp-\u0026gt;head-\u0026gt;prev=lp-\u0026gt;head; lp-\u0026gt;head-\u0026gt;next=lp-\u0026gt;tail; lp-\u0026gt;tail-\u0026gt;prev=lp-\u0026gt;head; lp-\u0026gt;tail-\u0026gt;next=lp-\u0026gt;tail; lp-\u0026gt;cur=NULL; //cur가 NULL pointer로 초기화 lp-\u0026gt;length=0; //데이터 노드의 개수를 0으로 초기화 return ; } 헤드 노드, 테일 노드를 할당 후, 헤드 노드와 테일 노드를 서로 연결해준다.\npush node Node * makeNode(DataType *dataPtr, Node *prev, Node *next) { Node *np; np = (Node *)malloc(sizeof(Node)); //새로운 노드 생성 assert(np!=NULL); np-\u0026gt;prev = prev; np-\u0026gt;next = next; np-\u0026gt;data = *dataPtr; if(prev != NULL) { prev-\u0026gt;next = np; } if(next != NULL) { next-\u0026gt;prev = np; } return np; } Node * appendFromTail(LinkedList *lp, DataType *dataPtr) { lp-\u0026gt;cur = makeNode(dataPtr, lp-\u0026gt;tail-\u0026gt;prev, lp-\u0026gt;tail); //새로운 노드 생성 assert(lp-\u0026gt;cur!=NULL); lp-\u0026gt;length++; //데이터개수 1 증가 return lp-\u0026gt;cur; } 양방향 연결 리스트에서 노드를 삽입하는 방법은 두 가지가 있다, 첫 번째는 헤드 노드 앞으로 데이터를 삽입하는 법과 테일 노 드 뒤쪽으로 데이터를 삽입하는 방식이다. 헤드 노드 앞으로 데이터를 삽입하는 방법은 데이터를 다 넣고 출력을 하게 되면 데이터의 순서가 들어온 순서랑 역순이 되므로 여기선, 테일 노 드 뒤로 삽입하는 코드를 썼다. 우선, 첫째로 makeNode 함수를 이용하여 노드를 하나 할당 후, 데이터 개수를 1개 증가시켜준다. makeNode 함수는 malloc을 통해 메모리를 할당 후, 전달인자로 이전 노드, 다음 노드를 가져와 서로 선을 이어주는 함수이다.\nremove node void deleteNode (LinkedList *lp, Node *target) { if(target==NULL) { return; } //삭제할 데이터의 앞,뒤 노드를 연결시킴 target-\u0026gt;prev-\u0026gt;next=target-\u0026gt;next; target-\u0026gt;next-\u0026gt;prev=target-\u0026gt;prev; free(target); // target노드 삭제 lp-\u0026gt;length--; // 데이터 개수 1 감소 } void destroy (LinkedList *lp) { while(lp-\u0026gt;head-\u0026gt;next != lp-\u0026gt;tail) { // 데이터 노드가 있다면 해제 deleteNode(lp,lp-\u0026gt;head-\u0026gt;next); // head 노드 바로 뒷 노드를 삭제 } free(lp-\u0026gt;head); // head 노드 삭제 free(lp-\u0026gt;tail); // tail 노드 삭제 lp-\u0026gt;head = lp-\u0026gt;cur = lp-\u0026gt;tail = NULL; //모든 포인터를 NULL로 초기화 lp-\u0026gt;length = 0; //데이터개수 0으로 초기화 return ; } 노드를 삭제하는 함수, 모든 노드를 삭제하는 함수이다. deleteNode함수는 전달인자로 삭제할 노드 (target)을 받아 target노드의 이전노드와 target노드의 다음노드를 서로 이어준 뒤, target노드를 free함수를 통해 메모리를 해제하는 방식으로 이루어져있다. destory함수는 우선 헤드 노드와 테일 노드를 삭제 한 후, 나머지 데이터노드들을 순차적으로 메모리 해제해주는 방식이다.\nsort void deleteNode (LinkedList *lp, Node *target) void sortList(LinkedList *lp, int (*compare)(DataType *, DataType *)) { Node *tp; Node *target; DataType temp; // swap용 임시변수 lp-\u0026gt;cur=lp-\u0026gt;head-\u0026gt;next; // 첫 데이터 노드를 가리키게 하고 while(lp-\u0026gt;cur!=lp-\u0026gt;tail) {// 맨 뒷 노드까지 검색 target = lp-\u0026gt;cur; tp=lp-\u0026gt;cur-\u0026gt;next; // cur의 다음 노드를 가리키게 함 while(tp!=lp-\u0026gt;tail) { if(compare(\u0026amp;target-\u0026gt;data, \u0026amp;tp-\u0026gt;data) \u0026gt; 0) { target = tp; } tp=tp-\u0026gt;next; } temp = lp-\u0026gt;cur-\u0026gt;data; lp-\u0026gt;cur-\u0026gt;data = target-\u0026gt;data; target-\u0026gt;data = temp; lp-\u0026gt;cur=lp-\u0026gt;cur-\u0026gt;next; } return; } 변수로는 임시 노드 포인터 tp와 정렬할때 바뀜이 되는 대상 임시 노드 포인터 target, 그리고 Data Swap을 위해 필요한 temp변수가 있다. 링크드리스트 관리 구조체의 cur포인터를 헤드노드 뒷 노드 즉, 첫번째 데이터노드를 가리키게 한 뒤, 반복문을 통해 데이터 끝까지 갈 수 있도록 해준다. 여기서, target노드는 현재 cur포인터로 지정해주고 임시 tp포인터는 cur포인터의 다음 노드를 가리키게 한다. (ex) 45 - 25 - 11 - 5 - 23 의 구조로 이루어져있는 링크드 리스트일때 target을 45, tp를 25로 지정) compare함수를 통해 비교하고 그것이 참이면 서로 swap해준다.\n","permalink":"https://ralpioxxcs.github.io/post/cs/linked_list/","summary":"자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.\nImplementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,","title":"C로 구현하는 자료구조 - Linked List"},{"content":" 후입선출(Last In First Out; LIFO)의 특성을 갖는 자료구조로, 데이터를 쌓아올리는(stack)의 형태를 갖는다.\npush: 데이터를 넣는 작업 pop: 데이터를 꺼내는 작업 Implementation 스택은 배열(array)와 연결리스트(linked list)로 구현할 수 있는데, 여기서는 연결리스트를 이용해서 스택을 구현할 것이다.\nstructure typedef struct node { void* data; struct node *next; } node; typedef struct stack { int size; node *head; } stack; 동적으로 할당할 data와 다음 노드를 가리킬 next 포인터로 하나의 element 형태를 갖는다.\ninitialize stack init_stack() { stack st; st.head = NULL; return st; } stack를 만들고, 아무것도 가리키는것이 없으니 head를 NULL로 초기화한다\npush void push(stack *st, void *in) { node* n = (node *)malloc(sizeof(node)); n-\u0026gt;data = in; n-\u0026gt;next = st-\u0026gt;head; st-\u0026gt;head = n; ++st-\u0026gt;size; } 새로 추가할 노드를 할당한 뒤, 새로 추가된 노드의 next에 이전 노드가 가리키던 head포인터를 넘겨주고, 후입선출의 성질을 갖도록 스택의 head에는 방금 추가한 노드 포인터를 가리키게 해준다.\npop void* pop(stack *st) { assert(st-\u0026gt;size \u0026lt;= 0) { return NULL; } node *n = st-\u0026gt;head; st-\u0026gt;head = n-\u0026gt;next; --st-\u0026gt;size; void *out = n-\u0026gt;data; free(n); return out; } 가장 위에 있는node가 먼저 나가야하므로 현재 head가 가리키는 node의 data주소를 별도의 포인터 변수에 저장한 뒤, 이전 노드를 가리키도록 head에는 지울 노드가 가리키던 next 노드를 가리키도록 한다.\n","permalink":"https://ralpioxxcs.github.io/post/cs/stack/","summary":"후입선출(Last In First Out; LIFO)의 특성을 갖는 자료구조로, 데이터를 쌓아올리는(stack)의 형태를 갖는다.\npush: 데이터를 넣는 작업 pop: 데이터를 꺼내는 작업 Implementation 스택은 배열(array)와 연결리스트(linked list)로 구현할 수 있는데, 여기서는 연결리스트를 이용해서 스택을 구현할 것이다.\nstructure typedef struct node { void* data; struct node *next; } node; typedef struct stack { int size; node *head; } stack; 동적으로 할당할 data와 다음 노드를 가리킬 next 포인터로 하나의 element 형태를 갖는다.\ninitialize stack init_stack() { stack st; st.","title":"C로 구현하는 자료구조 - stack"}]