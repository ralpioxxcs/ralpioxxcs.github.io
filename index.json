[{
  "name": "Getting Started Hugo [1] - Github 블로그 생성",
  "description": "Hugo란? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.Step 1 : Hugo 설치 (Windows) 1.1 다운로드 Hugo를 설치하는 방법은 간단하다. 아래의 URL을 클릭하여 다운로드 사이트로 이동한 뒤, 32bit, 64bit 를 확인하여 다운로드 한다.Hugo download link1.2 환경 설정 C드라이브에 hugo폴더를 생성한 뒤 그 안에 bin폴더를 생성,압축파일에 있던 hugo.",
  "body": " Hugo란? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.Step 1 : Hugo 설치 (Windows) 1.1 다운로드 Hugo를 설치하는 방법은 간단하다. 아래의 URL을 클릭하여 다운로드 사이트로 이동한 뒤, 32bit, 64bit 를 확인하여 다운로드 한다.Hugo download link1.2 환경 설정 C드라이브에 hugo폴더를 생성한 뒤 그 안에 bin폴더를 생성,압축파일에 있던 hugo.exe 파일을 복사하여 bin폴더에 붙여넣는다. 그리고 시스템 속성 - 환경변수의 PATH에 c://hugo/bin 경로를 추가한다. powershell 혹은 git-bash등 terminal 프로그램을 실행시키고 $ hugo -help 커맨드를 입력하여 hugo가 잘 설치되었는지 확인이 되면 hugo를 사용하기 위한 준비는 끝난다.Step 2 : 블로그 생성 2.1 폴더 생성 이제 hugo를 이용해 사이트를 생성해볼 차례다. c://hugo 의 위치에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 앞으로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (본인은 blog로 하였다.) 폴더를 만들었으면 $ cd blog &amp;amp;&amp;amp; ls 를 하여 생성된 폴더의 내부를 확인한다. 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.2.2 테스트 $ hugo server 명령어를 입력하고 localhost:1313 을 주소창에 입력해 생성된 사이트를 확인해보자. 아직은 빈 화면만 있을것이다.Step 3 : 블로그 설정 3.1 테마 고르기 hugo themes link 로 이동하여 원하는 테마를 선택한다. 각 테마 소개 화면에서 Demo를 클릭하면 각 블로그의 예시를 체험해볼 수 있다. 마음에 드는 테마를 찾았으면 Download 버튼을 클릭 후 테마의 repository 로 이동한다.3.2 테마 다운로드 아까 생성되었던 폴더들중 themes라는 폴더에 테마를 넣어주어야한다. 테마의 repository url를 복사하고 c://hugo/blog/themes 경로에서 $ git clone [repository url]를 입력하여 테마를 다운로드한다.($ git submodule 명령어를 사용하여도 된다. 사실 hugo getting started에서는 submodule 명령어로 테마를 추가하라고 명시되어있다.)3.3 테마 적용 테마 다운로드를 완료하였으면 c://hugo/blog경로안에 있는 config.toml을 살짝 수정하여 적용시켜주여야 한다. 편집기를 이용해 config.toml를 연뒤, 마지막줄에 theme = &amp;quot;다운로드받은 테마 폴더명&amp;quot;을 추가해준다.Step 4 : 컨텐츠 포스팅 4.1 테스트 파일 생성 테마가 적용되었으면 포스팅을 해볼 차례이다. c://hugo/blog의 경로로 돌아가 $ hugo new post/test.md 커맨드를 입력한다. 그러면 content 폴더안에 post 라는 폴더가 생기고 그 안에 test.md 가 생성이 된다. 기본적으로 hugo를 이용해 포스팅을 할때는 $ hugo new [폴더명]/[파일이름]의 구조로 커맨드를 입력하면 된다.4.2 확인하기 다시한번 $ hugo server -D 커맨드를 입력하고 localhost:1313으로 들어가본다. 그러면 아까 생성한 test.md 글이 올라온 것을 확인해 볼 수 있을것이다.4.3 참고 각 테마마다 폴더 구성이 조금씩 다르지만, 기본적으로 테마를 받은 폴더안에는 exampleSite라는 폴더가 있을것이다. 만약 잘 안된다면 이 폴더를 잘보고 자신의 blog 로컬경로와 비교해가며 확인해보는 것도 좋다.Step 5 : repository 연동 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.5.1 github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다. 첫번째는 blog폴더 자체를 저장할 repository, 두번째는 hugo로 빌드된 파일들을 저장할 repository이다. 두번째 repository의 이름은 [github계정명].github.io로 만들어야 한다.5.2 remote repository 연동 c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성하고 $ git remote add origin [첫번째 repository url]를 입력한다. 그 다음 $ git submodule add -b master [두번째 repository url] public을 입력하여 hugo로 빌드될 public폴더를 서브모듈로 연결한다. 마지막으로, $ hugo -t [테마폴더명]을 하면 public 폴더가 생성이 된다.Step 6 : 컨텐츠 배포 6.1 커밋 마지막단계로 c://hugo/blog/public 경로에서 git add . , $ git commit -m &amp;quot;first commit&amp;quot; , $ git push origin master 를 하고 똑같이 c://hugo/blog 경로에서 add, commit , push를 해주면 끝이다.6.2 확인하기 이제 https://github.com/계정명.github.io로 들어가 제대로 연동이 되었나 확인해본다.추가 사항 hugo 작업영역 ",
  "url": "https://ralpioxxcs.github.io/post/hugo_manual/"
},{
  "name": "About Me",
  "description": " Software DeveloperProgramming Languages  C/C++ Shell Script Python (learning..)  Skills  Qt Git Cmake OpenCV  IDE  Visual Studio  Editor  VS Code Vim  Keyboard  Massdrop Alt (high profile) Leopold FC660M ABKO K945 v2  ",
  "body": " Software DeveloperProgramming Languages  C/C++ Shell Script Python (learning..)  Skills  Qt Git Cmake OpenCV  IDE  Visual Studio  Editor  VS Code Vim  Keyboard  Massdrop Alt (high profile) Leopold FC660M ABKO K945 v2  ",
  "url": "https://ralpioxxcs.github.io/about/"
},{
  "name": "Installation",
  "description": " Step 1 : Install Step 2 : Pre-requisite ",
  "body": " Step 1 : Install Step 2 : Pre-requisite ",
  "url": "https://ralpioxxcs.github.io/study/cmake/installation/"
},{
  "name": "OpenCV 설치하기 (Visual Studio 2015)",
  "description": " Step 1 : OpenCV 다운로드 OpenCV 공식 홈페이지 으로 이동해 Release 탭에서 원하는 버전을 받는다.Step 2 : 환경 설정 다운로드가 완료되었다면, 이제 OpenCV 라이브러리를 사용할 수 있도록 몇가지 작업이 필요하다. 우선 제어판 - 시스템 - 고급 시스템 설정으로 이동, 고급 탭에서 &amp;ldquo;환경변수&amp;rdquo; 를 클릭Step 3 : 테스트 ",
  "body": " Step 1 : OpenCV 다운로드 OpenCV 공식 홈페이지 으로 이동해 Release 탭에서 원하는 버전을 받는다.Step 2 : 환경 설정 다운로드가 완료되었다면, 이제 OpenCV 라이브러리를 사용할 수 있도록 몇가지 작업이 필요하다. 우선 제어판 - 시스템 - 고급 시스템 설정으로 이동, 고급 탭에서 &amp;ldquo;환경변수&amp;rdquo; 를 클릭Step 3 : 테스트 ",
  "url": "https://ralpioxxcs.github.io/study/opencv/installation/"
},{
  "name": "Getting Started Hugo [2] - 디렉터리 구조",
  "description": "명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.",
  "body": " 명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.content 모든 게시글들 (contents)파일들은 content 디렉토리내에 쓰여지고 저장된다. 예를들면 사이트내에 3개의 주요 카테고리 (eg. blog, articles, tutorials) 가 있다고하면 content폴더내의 디렉토리 구조는 content/blog, content/articels, content/totorials의 구조를 갖게된다.data Hugo에서 site를 생성할 떄, 구성파일들을 저장하는데 사용되는 폴더이다. yaml, toml, json 형태로 쓸 수 있다.layouts static site를 구성하는 모든 ~.html 확장자를 갖는 파일들을 저장한다. list pages, homepage, single page 등 더 많은 템플릿을 포함하고, hugo theme를 이용하는 사용자의 측면에서 가장 중요한 폴더이며, 이 부분을 수정하여 입맛에 맞게 수정하여 사용할 수도 있다.static CSS, JavaScript, image등의 정적인 파일들이 저장된 폴더이다. Hugo에 의해서 site를 생성할때, static폴더내의 파일들이 사용된다.themes 이미 만들어진 hugo의 theme를 저장하는 폴더. theme를 사용하려면 이 폴더에 theme폴더를 저장하고 config를 수정하여야 한다.config config.toml, config.yaml, config.json의 형태로 작성되며, hugo site를 생성할 때 기본 설정파일의 역할을 한다. theme를 사용할 때, 이 부분을 수정하여 theme를 적용하듯이 site를 생성하는데 중요한 역할을 한다. 보통 theme마다 config를 적용하는 방법이 달라 각 theme의 config 내부를 잘 살펴보면 사용법이 적혀있다.",
  "url": "https://ralpioxxcs.github.io/post/hugo_structure/"
},{
  "name": "Stack",
  "description": "1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면Ascending Stack VS Descending Stack으로 나눌 수 있다.스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.2. 코드 구현 2-1. define structure typedef struct _stacknode Snode;struct _stacknode {DataType data;Snode *next;};typedef struct _stack {Snode *head;Snode *tail;Snode *cur;}Stack;  스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.",
  "body": " 1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면Ascending Stack VS Descending Stack으로 나눌 수 있다.스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.2. 코드 구현 2-1. define structure typedef struct _stacknode Snode;struct _stacknode {DataType data;Snode *next;};typedef struct _stack {Snode *head;Snode *tail;Snode *cur;}Stack;  스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.2-2. Init Stack void initStack(Stack *sPtr) {sPtr-&amp;gt;head = (Snode *)malloc(sizeof(Snode)); //헤드 노드 생성 assert(sPtr-&amp;gt;head!=NULL);sPtr-&amp;gt;tail = (Snode *)malloc(sizeof(Snode)); //테일 노드 생성 assert(sPtr-&amp;gt;tail!=NULL);/*헤드노드가 테일노드를, 테일노드가 헤드노드를 가리키게 함*/sPtr-&amp;gt;head-&amp;gt;next=sPtr-&amp;gt;tail;sPtr-&amp;gt;tail-&amp;gt;next=sPtr-&amp;gt;tail;sPtr-&amp;gt;cur = NULL;return ;}  헤드노드와 테일노드를 메모리 할당해주고 서로 가리키게 해준다2-3. Push /* stack에 데이터 저장하기 */int push(Stack *sPtr, DataType inData) {sPtr-&amp;gt;cur = (Snode *)malloc(sizeof(Snode)); //새로운 노드 생성 // 메모리 할당 실패하면 push실패 if(sPtr-&amp;gt;cur==NULL) {return FALSE;}//노드를 헤드노드 바로 뒤에 노드 추가 sPtr-&amp;gt;cur-&amp;gt;next=sPtr-&amp;gt;head-&amp;gt;next;sPtr-&amp;gt;head-&amp;gt;next=sPtr-&amp;gt;cur;sPtr-&amp;gt;cur-&amp;gt;data = inData; //데이터 복사 return TRUE;}  전달인자로 스택구조체의 주소와 삽입할 데이터를 받는다.새 노드를 할당하기위해 메모리를 할당하고 위로 쌓이는 것이므로 (처음 삽입하는경우) 헤드노드 바로 뒤에 노드를 추가해주는데, 두 번째 삽입부터는 노드가 이미 하나있기때문에 그 노드의 뒤로 삽입을 해야한다. 따라서, 새로 할당받은 노드의 다음주소에 그 이전 노드를 가리키게 하고 이전 노드는 새로 할당받은 노드를 가리키게 한다.2-4. Pop int pop(Stack *sPtr, DataType *popData) {// stack이 비어있으면 pop실패 if(sPtr-&amp;gt;head-&amp;gt;next == sPtr-&amp;gt;tail) {return FALSE;}*popData = sPtr-&amp;gt;head-&amp;gt;next-&amp;gt;data;sPtr-&amp;gt;cur = sPtr-&amp;gt;head-&amp;gt;next;sPtr-&amp;gt;head-&amp;gt;next = sPtr-&amp;gt;head-&amp;gt;next-&amp;gt;next;free(sPtr-&amp;gt;cur);return TRUE;}  제일 위에있는게 먼저 나가야하므로 popData에 가장 위에있는 노드의 data를 넣어주고, 제일 위에 있는 노드에 이어져 있는 선을 끊어주고 다음 노드와 이어주게 한다. 그리고 메모리를 해제",
  "url": "https://ralpioxxcs.github.io/study/datastructure/stack/"
},{
  "name": "Getting Started Hugo [3] - Front Matter",
  "description": "FrontMatter? FrontMatter is meta this is test aha",
  "body": " FrontMatter? FrontMatter is meta this is test aha",
  "url": "https://ralpioxxcs.github.io/post/hugo_frontmatter/"
},{
  "name": "LinkedList",
  "description": "1. 개요 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.단순 연결 리스트는 단 방향이기 때문에 Head 노드의 주소를 잃어버릴 경우 모든 자료들의 접근이 불가능해지므로 안정적인 자료구조는 아니다.이전, 다음 노드의 참조가 모두 가능하므로 탐색에 용이하고, 단순 연결 리스트에서 삭제를 하려면 시간이 오래 걸리는 것에 비해 이중 연결 리스트에서의 노드 삭제는 훨씬 간단하다.",
  "body": " 1. 개요 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.단순 연결 리스트는 단 방향이기 때문에 Head 노드의 주소를 잃어버릴 경우 모든 자료들의 접근이 불가능해지므로 안정적인 자료구조는 아니다.이전, 다음 노드의 참조가 모두 가능하므로 탐색에 용이하고, 단순 연결 리스트에서 삭제를 하려면 시간이 오래 걸리는 것에 비해 이중 연결 리스트에서의 노드 삭제는 훨씬 간단하다. 또한, Head 노드와 Tail 노드를 가지고 있으므로 둘 중 하나가 유일되더라도 리스트를 순회할 수 있기 때문에 손상에 강한 편이다.2. 코드 구현 2-1. define structure typedef struct _node Node; // 구조체 노드 형명재지정struct _node { // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버};typedef struct _linkedList { // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수} LinkedList;  LinkedList 구조체는 리스트 관리 구조체로서, 1) 순회를 하기 위한 Head, Tail 노드만을 가리키는 노드 포인터와 2) 현재 노드 가리킴 및 여러 용도로 쓰이는 노드 포인터, 3) 노드의 개수를 저장하는 int형 변수로 이루어져 있다.2-2. Init LinkedList void create(LinkedList * lp) {lp-&amp;gt;head = (Node *)malloc(sizeof(Node)); //헤드 노드 생성 assert(lp-&amp;gt;head!=NULL);lp-&amp;gt;tail = (Node *)malloc(sizeof(Node)); //테일 노드 생성 assert(lp-&amp;gt;tail!=NULL);/*head node와 tail node를 연결 함*/lp-&amp;gt;head-&amp;gt;prev=lp-&amp;gt;head;lp-&amp;gt;head-&amp;gt;next=lp-&amp;gt;tail;lp-&amp;gt;tail-&amp;gt;prev=lp-&amp;gt;head;lp-&amp;gt;tail-&amp;gt;next=lp-&amp;gt;tail;lp-&amp;gt;cur=NULL; //cur가 NULL pointer로 초기화 lp-&amp;gt;length=0; //데이터 노드의 개수를 0으로 초기화 return ;}  헤드 노드, 테일노드를 할당 후, 헤드 노드와 테일 노드를 서로 연결해준다.2-3. Add Node Node* makeNode(DataType* dataPtr, Node* prev, Node* next) {Node* np;np = (Node *)malloc(sizeof(Node)); //새로운 노드 생성 assert(np!=NULL);np-&amp;gt;prev = prev;np-&amp;gt;next = next;np-&amp;gt;data = *dataPtr;if(prev != NULL) prev-&amp;gt;next = np;if(next != NULL)next-&amp;gt;prev = np;return np;}======================================================================================Node* appendFromTail(LinkedList* lp, DataType* dataPtr) {lp-&amp;gt;cur = makeNode(dataPtr, lp-&amp;gt;tail-&amp;gt;prev, lp-&amp;gt;tail); //새로운 노드 생성 assert(lp-&amp;gt;cur!=NULL);lp-&amp;gt;length++; //데이터개수 1 증가 return lp-&amp;gt;cur;}  양방향 연결 리스트에서 노드를 삽입하는 방법은 두 가지가 있다, 첫 번째는 헤드 노드 앞으로 데이터를 삽입하는 법과 테일 노드 뒤쪽으로 데이터를 삽입하는 방식이다.헤드 노드 앞으로 데이터를 삽입하는 방법은 데이터를 다 넣고 출력을 하게 되면 데이터의 순서가 들어온 순서랑 역순이 되므로 여기선, 테일 노드 뒤로 삽입하는 코드를 썼다.우선, 첫째로 makeNode 함수를 이용하여 노드를 하나 할당 후, 데이터 개수를 1개 증가시켜준다. makeNode 함수는 malloc을 통해 메모리를 할당 후, 전달인자로 이전 노드, 다음 노드를 가져와 서로 선을 이어주는 함수이다.2-4. Delete Node void deleteNode (LinkedList* lp, Node* target) {if(target==NULL)return;//삭제할 데이터의 앞,뒤 노드를 연결시킴 target-&amp;gt;prev-&amp;gt;next=target-&amp;gt;next;target-&amp;gt;next-&amp;gt;prev=target-&amp;gt;prev;free(target); // target노드 삭제 lp-&amp;gt;length--; // 데이터 개수 1 감소}======================================================================================void destroy (LinkedList* lp) {// 데이터 노드가 있다면 해제 while(lp-&amp;gt;head-&amp;gt;next != lp-&amp;gt;tail) {deleteNode(lp,lp-&amp;gt;head-&amp;gt;next); // head 노드 바로 뒷 노드를 삭제 }free(lp-&amp;gt;head); // head 노드 삭제 free(lp-&amp;gt;tail); // tail 노드 삭제 lp-&amp;gt;head = lp-&amp;gt;cur = lp-&amp;gt;tail = NULL; //모든 포인터를 NULL로 초기화 lp-&amp;gt;length = 0; //데이터개수 0으로 초기화 return ;}  노드를 삭제하는 함수, 모든 노드를 삭제하는 함수이다.deleteNode함수는 전달인자로 삭제할 노드 (target)을 받아 target노드의 이전노드와 target노드의 다음노드를 서로 이어준 뒤, target노드를 free함수를 통해 메모리를 해제하는 방식으로 이루어져있다.destory함수는 우선 헤드 노드와 테일 노드를 삭제 한 후, 나머지 데이터노드들을 순차적으로 메모리 해제해주는 방식이다.2-5. Arragne Node void sortList(LinkedList *lp, int (*compare)(DataType *, DataType *)) {Node *tp;Node *target;DataType temp; // swap용 임시변수 lp-&amp;gt;cur=lp-&amp;gt;head-&amp;gt;next; // 첫 데이터 노드를 가리키게 하고 // 맨 뒷 노드까지 검색 while(lp-&amp;gt;cur!=lp-&amp;gt;tail) {target = lp-&amp;gt;cur;tp=lp-&amp;gt;cur-&amp;gt;next; // cur의 다음 노드를 가리키게 함 while(tp!=lp-&amp;gt;tail) {if(compare(&amp;amp;target-&amp;gt;data, &amp;amp;tp-&amp;gt;data) &amp;gt; 0) {target = tp;}tp=tp-&amp;gt;next;}temp = lp-&amp;gt;cur-&amp;gt;data;lp-&amp;gt;cur-&amp;gt;data = target-&amp;gt;data;target-&amp;gt;data = temp;lp-&amp;gt;cur=lp-&amp;gt;cur-&amp;gt;next;}return;}  변수로는 임시 노드 포인터 tp와 정렬할때 바뀜이 되는 대상 임시 노드 포인터 target, 그리고 Data Swap을 위해 필요한 temp변수가 있다.링크드리스트 관리 구조체의 cur포인터를 헤드노드 뒷 노드 즉, 첫번째 데이터노드를 가리키게 한 뒤, 반복문을 통해 데이터 끝까지 갈 수 있도록 해준다.여기서, target노드는 현재 cur포인터로 지정해주고 임시 tp포인터는 cur포인터의 다음 노드를 가리키게 한다.(ex) 45 - 25 - 11 - 5 - 23 의 구조로 이루어져있는 링크드 리스트일때 target을 45, tp를 25로 지정)compare함수를 통해 비교하고 그것이 참이면 서로 swap해준다.",
  "url": "https://ralpioxxcs.github.io/study/datastructure/linkedlist/"
},{
  "name": "Syntaxs",
  "description": " cmake 문법 ",
  "body": " cmake 문법 ",
  "url": "https://ralpioxxcs.github.io/study/cmake/syntaxs/"
}
]
