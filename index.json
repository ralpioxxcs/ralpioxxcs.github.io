[{
  "name": "Getting Started Hugo [1] - 설치 및 환경설정",
  "description": "Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 **Jekyll** (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.",
  "body": " Hugo? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다. 　Install (Windows OS) Hugo를 설치하는 방법은 간단하다. 아래의 URL을 클릭하여 다운로드 사이트로 이동한 뒤, 컴퓨터의 운영체제 버전(32bit, 64bit)를 확인하여 다운로드 한다.Hugo download link Configuration  C드라이브에 hugo폴더, bin 폴더 생성 (C:\\hugo\\bin) hugo.exe 파일을 복사하여 bin폴더에 붙여넣기 시스템 속성 - 환경변수의 PATH에 c:\\hugo\\bin 경로 추가. powershell 혹은 git-bash등 terminal 프로그램을 실행시키고 $ hugo -help 커맨드를 입력하여 아래의 메세지가 정삭적으로 나오는지 확인한다.hugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks config Print the site configuration convert Convert your content to different formats env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default &amp;quot;config&amp;quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don&#39;t sync permission mode of files --noTimes don&#39;t sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use &amp;quot;hugo [command] --help&amp;quot; for more information about a command.   ",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_start_1_install/"
},{
  "name": "LinkedList",
  "description": "비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.",
  "body": " 1. 개요 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.단순 연결 리스트는 단 방향이기 때문에 Head 노드의 주소를 잃어버릴 경우 모든 자료들의 접근이 불가능해지므로 안정적인 자료구조는 아니다.이전, 다음 노드의 참조가 모두 가능하므로 탐색에 용이하고, 단순 연결 리스트에서 삭제를 하려면 시간이 오래 걸리는 것에 비해 이중 연결 리스트에서의 노드 삭제는 훨씬 간단하다. 또한, Head 노드와 Tail 노드를 가지고 있으므로 둘 중 하나가 유일되더라도 리스트를 순회할 수 있기 때문에 손상에 강한 편이다.2. 코드 구현 2-1. define structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node { // 데이터를 보관할 노드(자기참조 구조체)  Node *prev; // 앞 노드를 가리키는 멤버  DataType data; // 데이터 저장 멤버  Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList { // 리스트 관리 구조체  Node *head; // 헤드포인터 (헤드노드 가리킴)  Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터  Node *tail; // 테일포인터 (테일노드 가리킴)  int length; // 실제 데이터노드의 갯수 } LinkedList;  LinkedList 구조체는 리스트 관리 구조체로서, 1) 순회를 하기 위한 Head, Tail 노드만을 가리키는 노드 포인터와 2) 현재 노드 가리킴 및 여러 용도로 쓰이는 노드 포인터, 3) 노드의 개수를 저장하는 int형 변수로 이루어져 있다.2-2. Init LinkedList void create(LinkedList * lp) { lp-&amp;gt;head = (Node *)malloc(sizeof(Node)); //헤드 노드 생성  assert(lp-&amp;gt;head!=NULL); lp-&amp;gt;tail = (Node *)malloc(sizeof(Node)); //테일 노드 생성  assert(lp-&amp;gt;tail!=NULL); /*head node와 tail node를 연결 함*/ lp-&amp;gt;head-&amp;gt;prev=lp-&amp;gt;head; lp-&amp;gt;head-&amp;gt;next=lp-&amp;gt;tail; lp-&amp;gt;tail-&amp;gt;prev=lp-&amp;gt;head; lp-&amp;gt;tail-&amp;gt;next=lp-&amp;gt;tail; lp-&amp;gt;cur=NULL; //cur가 NULL pointer로 초기화  lp-&amp;gt;length=0; //데이터 노드의 개수를 0으로 초기화  return ; }  헤드 노드, 테일노드를 할당 후, 헤드 노드와 테일 노드를 서로 연결해준다.2-3. Add Node Node* makeNode(DataType* dataPtr, Node* prev, Node* next) { Node* np; np = (Node *)malloc(sizeof(Node)); //새로운 노드 생성  assert(np!=NULL); np-&amp;gt;prev = prev; np-&amp;gt;next = next; np-&amp;gt;data = *dataPtr; if(prev != NULL) prev-&amp;gt;next = np; if(next != NULL) next-&amp;gt;prev = np; return np; } ====================================================================================== Node* appendFromTail(LinkedList* lp, DataType* dataPtr) { lp-&amp;gt;cur = makeNode(dataPtr, lp-&amp;gt;tail-&amp;gt;prev, lp-&amp;gt;tail); //새로운 노드 생성  assert(lp-&amp;gt;cur!=NULL); lp-&amp;gt;length++; //데이터개수 1 증가  return lp-&amp;gt;cur; }  양방향 연결 리스트에서 노드를 삽입하는 방법은 두 가지가 있다, 첫 번째는 헤드 노드 앞으로 데이터를 삽입하는 법과 테일 노드 뒤쪽으로 데이터를 삽입하는 방식이다.헤드 노드 앞으로 데이터를 삽입하는 방법은 데이터를 다 넣고 출력을 하게 되면 데이터의 순서가 들어온 순서랑 역순이 되므로 여기선, 테일 노드 뒤로 삽입하는 코드를 썼다.우선, 첫째로 makeNode 함수를 이용하여 노드를 하나 할당 후, 데이터 개수를 1개 증가시켜준다. makeNode 함수는 malloc을 통해 메모리를 할당 후, 전달인자로 이전 노드, 다음 노드를 가져와 서로 선을 이어주는 함수이다.2-4. Delete Node void deleteNode (LinkedList* lp, Node* target) { if(target==NULL) return; //삭제할 데이터의 앞,뒤 노드를 연결시킴  target-&amp;gt;prev-&amp;gt;next=target-&amp;gt;next; target-&amp;gt;next-&amp;gt;prev=target-&amp;gt;prev; free(target); // target노드 삭제  lp-&amp;gt;length--; // 데이터 개수 1 감소 } ====================================================================================== void destroy (LinkedList* lp) { // 데이터 노드가 있다면 해제  while(lp-&amp;gt;head-&amp;gt;next != lp-&amp;gt;tail) { deleteNode(lp,lp-&amp;gt;head-&amp;gt;next); // head 노드 바로 뒷 노드를 삭제  } free(lp-&amp;gt;head); // head 노드 삭제  free(lp-&amp;gt;tail); // tail 노드 삭제  lp-&amp;gt;head = lp-&amp;gt;cur = lp-&amp;gt;tail = NULL; //모든 포인터를 NULL로 초기화  lp-&amp;gt;length = 0; //데이터개수 0으로 초기화  return ; }  노드를 삭제하는 함수, 모든 노드를 삭제하는 함수이다.deleteNode함수는 전달인자로 삭제할 노드 (target)을 받아 target노드의 이전노드와 target노드의 다음노드를 서로 이어준 뒤, target노드를 free함수를 통해 메모리를 해제하는 방식으로 이루어져있다.destory함수는 우선 헤드 노드와 테일 노드를 삭제 한 후, 나머지 데이터노드들을 순차적으로 메모리 해제해주는 방식이다.2-5. Arragne Node void sortList(LinkedList *lp, int (*compare)(DataType *, DataType *)) { Node *tp; Node *target; DataType temp; // swap용 임시변수  lp-&amp;gt;cur=lp-&amp;gt;head-&amp;gt;next; // 첫 데이터 노드를 가리키게 하고  // 맨 뒷 노드까지 검색  while(lp-&amp;gt;cur!=lp-&amp;gt;tail) { target = lp-&amp;gt;cur; tp=lp-&amp;gt;cur-&amp;gt;next; // cur의 다음 노드를 가리키게 함  while(tp!=lp-&amp;gt;tail) { if(compare(&amp;amp;target-&amp;gt;data, &amp;amp;tp-&amp;gt;data) &amp;gt; 0) { target = tp; } tp=tp-&amp;gt;next; } temp = lp-&amp;gt;cur-&amp;gt;data; lp-&amp;gt;cur-&amp;gt;data = target-&amp;gt;data; target-&amp;gt;data = temp; lp-&amp;gt;cur=lp-&amp;gt;cur-&amp;gt;next; } return; }  변수로는 임시 노드 포인터 tp와 정렬할때 바뀜이 되는 대상 임시 노드 포인터 target, 그리고 Data Swap을 위해 필요한 temp변수가 있다.링크드리스트 관리 구조체의 cur포인터를 헤드노드 뒷 노드 즉, 첫번째 데이터노드를 가리키게 한 뒤, 반복문을 통해 데이터 끝까지 갈 수 있도록 해준다.여기서, target노드는 현재 cur포인터로 지정해주고 임시 tp포인터는 cur포인터의 다음 노드를 가리키게 한다.(ex) 45 - 25 - 11 - 5 - 23 의 구조로 이루어져있는 링크드 리스트일때 target을 45, tp를 25로 지정)compare함수를 통해 비교하고 그것이 참이면 서로 swap해준다.",
  "url": "https://ralpioxxcs.github.io/study/datastructure/linkedlist/"
},{
  "name": "About Me",
  "description": " Software DeveloperProgramming Languages  C/C++ Shell Script Python (learning..)  Skills  Qt Git Cmake OpenCV  IDE  Visual Studio  Editor  VS Code Vim  Keyboard  Massdrop Alt (high profile) HJ 75 XO V2  ",
  "body": " Software DeveloperProgramming Languages  C/C++ Shell Script Python (learning..)  Skills  Qt Git Cmake OpenCV  IDE  Visual Studio  Editor  VS Code Vim  Keyboard  Massdrop Alt (high profile) HJ 75 XO V2  ",
  "url": "https://ralpioxxcs.github.io/about/"
},{
  "name": "Getting Started Hugo [2] - 블로그 생성",
  "description": "이제 hugo를 이용해 사이트를 생성해볼 차례다.`c://hugo` 의 경로에서 `$ hugo new site [폴더이름]` 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 **blog**로 하였다.) 폴더를 만들었으면 `$ cd blog &amp;&amp; ls ` 를 입력해 생성된 폴더의 내부를 확인한다. 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다. ",
  "body": " Let&amp;rsquo;s create own blog 　Step 1. 블로그 폴더 생성  c://hugo 의 경로에서 $ hugo new site [폴더이름] 을 입력한다. 여기서 폴더이름은 말 그대로 터미널 상에서 접근할 폴더이름일 뿐, 생성하고자 하는 블로그의 이름이 되진 않는다. (예시는 blog로 하였다.) 폴더를 만들었으면 $ cd blog &amp;amp;&amp;amp; ls 를 입력해 생성된 폴더의 내부를 확인한다.-&amp;gt; 정상적으로 생성이 되었으면 archtypes, assets, config.toml 등 여러 파일과 폴더들이 생성된 것을 확인할 수 있다.테스트 $ hugo server 명령어를 입력하고 localhost:1313 을 크롬, 파이어폭스등 웹브라우저 주소창에 입력해 생성된 사이트를 확인해보자. 아직은 빈 화면만 있을것이다.  Step 2. 테마 적용하기  hugo themes link 로 이동하여 원하는 테마를 선택한다. 각 테마 소개 화면에서 Demo를 클릭하면 각 블로그의 예시를 체험해볼 수 있다. 마음에 드는 테마를 찾았으면 Download 버튼을 클릭 후 테마의 repository 로 이동한다.  테마 다운로드  테마의 repository url를 복사한다. c://hugo/blog/themes 경로에서 $ git clone [repository url]를 입력하여 테마를 다운로드한다.($ git submodule 명령어를 사용하여도 된다. 사실 hugo getting started에서는 submodule 명령어로 테마를 추가하라고 명시되어있다.)  테마 적용  편집기를 이용해 config.toml파일을 연뒤, 마지막줄에 theme = &amp;quot;다운로드받은 테마 폴더명&amp;quot;을 추가해준다.  Step 3. 컨텐츠 포스팅 테스트 파일 생성  c://hugo/blog의 경로로 돌아가 $ hugo new post/test.md 커맨드를 입력한다. 그러면 content 폴더안에 post 라는 폴더가 생기고 그 안에 test.md 파일이 생성된다.  확인하기  $ hugo server -D 커맨드를 입력하고 localhost:1313으로 들어가본다. 그러면 아까 생성한 test.md 글이 업로드 된것을 확인해 볼 수 있을것이다.   참고 각 테마마다 폴더 구성이 조금씩 다르지만, 기본적으로 테마를 받은 폴더안에는 exampleSite라는 폴더가 있을것이다. 만약 잘 안된다면 이 폴더를 잘보고 자신의 blog 로컬경로와 비교해가며 확인해보는 것도 좋다.",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_start_2_quick_start/"
},{
  "name": "Stack",
  "description": "후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면 **Ascending Stack** VS **Descending Stack**으로 나눌 수 있다.",
  "body": " 1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면Ascending Stack VS Descending Stack으로 나눌 수 있다.스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.2. 코드 구현 2-1. define structure typedef struct _stacknode Snode; struct _stacknode { DataType data; Snode *next; }; typedef struct _stack { Snode *head; Snode *tail; Snode *cur; }Stack;  스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.2-2. Init Stack void initStack(Stack *sPtr) { sPtr-&amp;gt;head = (Snode *)malloc(sizeof(Snode)); //헤드 노드 생성  assert(sPtr-&amp;gt;head!=NULL); sPtr-&amp;gt;tail = (Snode *)malloc(sizeof(Snode)); //테일 노드 생성  assert(sPtr-&amp;gt;tail!=NULL); /*헤드노드가 테일노드를, 테일노드가 헤드노드를 가리키게 함*/ sPtr-&amp;gt;head-&amp;gt;next=sPtr-&amp;gt;tail; sPtr-&amp;gt;tail-&amp;gt;next=sPtr-&amp;gt;tail; sPtr-&amp;gt;cur = NULL; return ; }  헤드노드와 테일노드를 메모리 할당해주고 서로 가리키게 해준다2-3. Push /* stack에 데이터 저장하기 */ int push(Stack *sPtr, DataType inData) { sPtr-&amp;gt;cur = (Snode *)malloc(sizeof(Snode)); //새로운 노드 생성  // 메모리 할당 실패하면 push실패  if(sPtr-&amp;gt;cur==NULL) { return FALSE; } //노드를 헤드노드 바로 뒤에 노드 추가  sPtr-&amp;gt;cur-&amp;gt;next=sPtr-&amp;gt;head-&amp;gt;next; sPtr-&amp;gt;head-&amp;gt;next=sPtr-&amp;gt;cur; sPtr-&amp;gt;cur-&amp;gt;data = inData; //데이터 복사  return TRUE; }  전달인자로 스택구조체의 주소와 삽입할 데이터를 받는다.새 노드를 할당하기위해 메모리를 할당하고 위로 쌓이는 것이므로 (처음 삽입하는경우) 헤드노드 바로 뒤에 노드를 추가해주는데, 두 번째 삽입부터는 노드가 이미 하나있기때문에 그 노드의 뒤로 삽입을 해야한다. 따라서, 새로 할당받은 노드의 다음주소에 그 이전 노드를 가리키게 하고 이전 노드는 새로 할당받은 노드를 가리키게 한다.2-4. Pop int pop(Stack *sPtr, DataType *popData) { // stack이 비어있으면 pop실패  if(sPtr-&amp;gt;head-&amp;gt;next == sPtr-&amp;gt;tail) { return FALSE; } *popData = sPtr-&amp;gt;head-&amp;gt;next-&amp;gt;data; sPtr-&amp;gt;cur = sPtr-&amp;gt;head-&amp;gt;next; sPtr-&amp;gt;head-&amp;gt;next = sPtr-&amp;gt;head-&amp;gt;next-&amp;gt;next; free(sPtr-&amp;gt;cur); return TRUE; }  제일 위에있는게 먼저 나가야하므로 popData에 가장 위에있는 노드의 data를 넣어주고, 제일 위에 있는 노드에 이어져 있는 선을 끊어주고 다음 노드와 이어주게 한다. 그리고 메모리를 해제",
  "url": "https://ralpioxxcs.github.io/study/datastructure/stack/"
},{
  "name": "Getting Started Hugo [3] - 디렉터리 구조",
  "description": "명령창에 `$ hugo new site`를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다.각각의 폴더의 역할은 다음과 같다.",
  "body": " 명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.content 모든 게시글들 (contents)파일들은 content 디렉토리내에 쓰여지고 저장된다. 예를들면 사이트내에 3개의 주요 카테고리 (eg. blog, articles, tutorials) 가 있다고하면 content폴더내의 디렉토리 구조는 content/blog, content/articels, content/tutorials의 구조를 갖게된다.data Hugo에서 site를 생성할 떄, 구성파일들을 저장하는데 사용되는 폴더이다. yaml, toml, json 형태로 쓸 수 있다.layouts static site를 구성하는 모든 ~.html 확장자를 갖는 파일들을 저장한다. list pages, homepage, single page 등 더 많은 템플릿을 포함하고, hugo theme를 이용하는 사용자의 측면에서 가장 중요한 폴더이며, 이 부분을 수정하여 입맛에 맞게 수정하여 사용할 수도 있다.static CSS, JavaScript, image등의 정적인 파일들이 저장된 폴더이다. Hugo에 의해서 site를 생성할때, static폴더내의 파일들이 사용된다.themes 이미 만들어진 hugo의 theme를 저장하는 폴더. theme를 사용하려면 이 폴더에 theme폴더를 저장하고 config파일을 수정하여야 한다.config config.toml, config.yaml, config.json의 형태로 작성되며, hugo site를 생성할 때 기본 설정파일의 역할을 한다. theme를 사용할 때, 이 부분을 수정하여 theme를 적용하듯이 site를 생성하는데 중요한 역할을 한다. 보통 theme마다 config를 적용하는 방법이 달라 각 theme의 config 내부를 잘 살펴보면 사용법이 적혀있다.",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_start_3_directory/"
},{
  "name": "CirculaQueue",
  "description": "선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다.",
  "body": " 1. 개요 선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다.큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.2. 선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.( Front == Rear )데이터를 5개 모두 넣었다면 Rear값은 5가 되어있을것이고 큐가 모두 찼으므로 이 상태는 큐가 포화상태라는 것을 뜻 한다. ( 큐 Size == Rear )이렇게만 보면 선형 큐가 문제가 없어보이지만 바로 여기서 선형 큐의 맹점이 드러난다. 현재 큐가 꽉 차있는 상태에서 데이터를 하나 삭제하게되면 Front값이 1로 증가할것이고 빈 방 1개가 나올것이다, 그런데 Front는 1 이고 Rear는 5이므로 큐의 공백조건을 만족하지 못하므로 빈 방이 있음에도 불구하고 큐의 데이터삽입이 불가능하게 된다. 이러한 맹점을 보완한것이 바로 원형 큐 (Circular Queue)이다.3. 원형 큐 (Circula Queue) 원형 큐 (Circular Queue)는 선입선출(先入先出, First In First Out; FIFO)를 그대로 유지하면서 큐의 입구와 출구를 연결하여 원형으로 만들어 사용하는 구조이다.이때, Front와 Rear사이에 완충지대를 두어 원형 큐의 비어있는 상태와 포화상태를 구분한다. 완충지대의 위치는 항상 Front의 하나 앞방이다. (유동성)완충지대 때문에 예를들어 7개의 데이터를 넣는 큐를 만드려면 큐의 사이즈를 8으로 지정하여야한다. 초기에는 Front와 Rear는 0으로 설정한다. 자동으로 완충지대는 [7]번방이 된다.원형 큐 에서는 Rear값 및 Front값을 증가시킬때 선형 큐처럼 단순히 +1을 하게되면 원형 큐가 되지 않으므로 &amp;ldquo;%&amp;rdquo; 기능을 활용하여 Rear값을 바꿔준다.Rear가 0번방에서 1번방으로 가야하므로 +1을 해준뒤 큐 사이즈만큼 나눠주고 나머지 값을 Rear값으로 하면 된다. ( Rear = (Rear+1) % QueueSize )계속 데이터를 삽입하여 7번방까지 데이터를 삽입하였다면 Rear가 완충지대를 가리키고 있을것이고 이 상태는 포화상태를 의미한다. 즉, Rear가 완충지대를 가리키고있다면 큐는 포화상태라는 뜻이다. 공백상태는 선형 큐와 같다. Rear와 Front가 같으면 공백상태를 뜻한다.그러면 여기서, 아까 선형 큐가 해결하지 못했던 문제를 해결할 수 있다. 데이터가 꽉 차있는 상태에서 Dequeue를 하여 Front값을 1로 바꿔준다 ( Front = (Front +1) % QueueSize )그러면 자동으로 완충지대는 Front가 이동하였으므로 원래위치 7번방에서 (Front의 이전 방) 0번방으로 옮겨갈 것이다.따라서, Rear는 완충지대를 가리키고 있지 않으므로 큐의 포화조건에서 탈출하게 되고 데이터의 삽입이 가능해진다. Rear가 7번방이었으므로 위와같이 ( Rear = (Rear+1) % QueueSize ) 를 이용하면 Rear는 0번방을 가리키며 0번방에 데이터를 삽입하게 된다.4. 코드 구현 4-1. define structure typedef struct _queue { DataType *queue; int qSize; int front, rear; }Queue;  큐를 관리하는 구조체데이터를 저장할 데이터필드 영역과 큐의 크기를 저장하는 변수, Front와 Rear를 지정하는 변수로 이루어져있다.4-2. Create Queue void initQueue(Queue * qPtr, int size) { qPtr-&amp;gt;qSize = size; qPtr-&amp;gt;front = 0; qPtr-&amp;gt;rear = 0; qPtr-&amp;gt;queue = (DataType *)calloc(qPtr-&amp;gt;qSize, sizeof(DataType)); }  큐를 초기화 및 생성하는 함수전달인자로 큐의 사이즈를 받아서 큐의 사이즈를 넣어주고, Front와 Rear의 값을 모두 0으로 초기화한뒤 calloc함수를 통해 size만큼 메모리를 할당받는다.4-3. Enqueue int enqueue(Queue * qPtr, DataType inData) { // rear가 완충지대에 있으면 put불가  if((qPtr-&amp;gt;rear+1)%qPtr-&amp;gt;qSize == qPtr-&amp;gt;front){ return FALSE; } qPtr-&amp;gt;queue[qPtr-&amp;gt;rear] = inData; qPtr-&amp;gt;rear++; qPtr-&amp;gt;rear = (qPtr-&amp;gt;rear)%qPtr-&amp;gt;qSize; return TRUE; }  큐에 데이터를 삽입하는 함수처음 조건문을 걸어서 큐가 비어있는지 확인한다. Rear가 완충지대에 있으면 큐가 포화상태인것이므로 True시 False를 리턴한다. False일시, 아래 코드로 내려와서 현재 Rear값에 데이터를 넣어주고, Rear값 증가한다.( Rear = (Rear+1) % QueueSize )4-4. Dequeue int dequeue(Queue * qPtr, DataType * getData) { // 큐가 비어있으면 dequeue 불가  if( isQueueEmpty(qPtr) ) { return FALSE; } *getData = qPtr-&amp;gt;queue[qPtr-&amp;gt;front]; qPtr-&amp;gt;front++; qPtr-&amp;gt;front = (qPtr-&amp;gt;front)%qPtr-&amp;gt;qSize; return TRUE; }  큐에서 데이터를 빼와 출력하는 함수전달인자로 출력할 데이터의 주소값을 받아오고 초기 조건문으로 큐가 비어있는지 함수를 통해 확인, 비어있지않을시, Front방의 값을 불러오고 front를 하나 증가시킨다.( Front = (Front +1) % QueueSize )4-5. Check int isQueueEmpty(const Queue *qPtr) { if(qPtr-&amp;gt; front == qPtr-&amp;gt;rear) return TRUE; else return FALSE; }  큐가 비었는지 확인하는 함수로 Front와 Rear가 같을때 큐가 빈것으로 판별",
  "url": "https://ralpioxxcs.github.io/study/datastructure/circulaqueue/"
},{
  "name": "Getting Started Hugo [4] - 레포지토리 연동 및 웹 호스팅",
  "description": "나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자. ",
  "body": "  나만의 블로그를 구축하는데 성공하였다. 이제 로컬에 저장돼있는 hugo 사이트를 github repository와 연동하여 실제로 주소를 갖는 블로그를 만들어보자.Step 1. github repository 생성 github에 로그인하여 총 2개의 repository를 생성한다. blog 폴더 자체를 저장할 repository hugo로 빌드된 결과파일들을 저장할 repository두번째 repository의 이름은 [github계정명].github.io의 형식으로 만들어야 한다.  remote repository 연동  c://hugo/blog 경로에서 $ git init .으로 로컬 repository를 생성한다. $ git remote add origin [첫번째 repository url]를 입력한다. $ git submodule add -b master [두번째 repository url] public을 입력하여 hugo로 빌드될 public폴더를 서브모듈로 연결한다. $ hugo -t [테마 폴더명]를 입력하면 hugo가 빌드를 시작하고 public 폴더가 생성이 된다.  Step 2. 컨텐츠 배포 Commit  c://hugo/blog/public 경로에서 git add . $ git commit -m &amp;quot;first commit&amp;quot; $ git push origin master c://hugo/blog 경로에서 위의 3과정 반복  Check 이제 https://github.com/계정명.github.io로 접속하여 블로그의 컨텐츠들이 업로드 되었는지 확인한다.",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_start_4_remote_repo_link/"
},{
  "name": "CMake 정리 Part1 - Overview",
  "description": " ",
  "body": " CMake? cmake란 cross platform 기반의 프로젝트 전체 빌드 프로세스를 관리해주는 유용한 툴이다. 직접 빌드를 수행하지는 않지만 지정된 OS에 맞는 Make파일 혹은 솔루션(sln)파일의 생성을 도와주어 소스코드 빌드를 편리하게 해준다.Cmake의 장점 (root) |- foo.cpp |- CMakeLists.txt  foo.cpp 라는 소스코드가 하나 있다고 가정하자. 이 소스코드를 각각의 다른 OS에서 빌드할 때, 윈도우즈라면 Visual Studio를, OSX라면 Xcode, Linux라면 Makefile을 이용할것이다. Cmake는 이런 귀찮은 과정을 CMakeLists.txt라는 프로젝트를 정의하는 파일을 하나 만듦으로써, 각 OS에 맞는 Build tool을 파악해 build command만 입력하면 될수 있도록 해준다.Install $ sudo apt install cmake 의 명령어를 입력해 간단하게 설치할 수 있다.$ cmake --version 명령어를 입력해 cmake가 제대로 install 되었는지 확인한다.Example 1. Configure main.cpp 라는 파일이 있다고 하면, 같은 폴더 내 &amp;lsquo;CMakeLists.txt&amp;rsquo; 라는 파일을 새로 생성 후 아래와 같이 작성한다. # CMakeListst.txt  cmake minimum required( VERSION 3.3 ) project ( test ) add_executable( test main.cpp ) 2. Generate 이제 작성된 CMakeLists.txt를 기반으로 CMake가 native build tool을 생성할 것이다.커맨드창에 $ cmake .를 입력하면 마지막 줄에 아래처럼 나오며 Makefile이 생성된다.-- Configure done -- Generating done -- Build files have been written to: ...  3. Build $ make 커맨드를 입력하면 작성된 Makefile에 의하여 foo.cpp -&amp;gt; foo.cpp.o -&amp;gt; foo 의 과정을 통해 executable 파일이 생성된다.",
  "url": "https://ralpioxxcs.github.io/post/cmake_1/"
},{
  "name": "Study: Qt",
  "description": "",
  "body": "",
  "url": "https://ralpioxxcs.github.io/study/qt/"
},{
  "name": "Hugo Content Management [1] - Contents Path",
  "description": "Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.  ",
  "body": " Hugo가 어떻게 각각에 컨텐츠에 접근하고, 폴더를 조직화하여 블로그를 구성하는지 알아보자.컨텐츠 구성 (root) └── content └── project | └── index.md // &amp;lt;- https://example.com/project/ ├── posts | ├── firstpost.md // &amp;lt;- https://example.com/posts/firstpost/ | └── secondpost.md // &amp;lt;- https://example.com/posts/secondpost/ └── study ├── first.md // &amp;lt;- https://example.com/study/first/ └── second.md // &amp;lt;- https://example.com/study/second/  위 처럼 각각 project, posts, study 총 3개의 카테고리가 있다고 가정할 때, Hugo는 section, slug, path, url의 변수들을 이용해 컨텐츠를 관리한다. section : default 컨텐츠 타입, content폴더의 어느위치에 있느냐에 따라 달라진다. slug : slug 변수는 각 컨텐츠 파일의 이름 (e.g., firstpost.md) 가 될수 있고, frontmatter에 의해 설정될 수 있다. path : section에서 slug 직전 까지의 경로 url : 컨텐츠의 상대적인 url, section부터 slug가 포함된 경로와 같다.. url . ⊢--^-⊣ . path slug . ⊢--^-⊣⊢---^---⊣ . filepath . ⊢------^------⊣ content/posts/firstpost.md   컨텐츠 경로 재정의 Hugo가 생성한 defualt 컨텐츠 경로를 frontmatter를 이용해 재정의(override)할 수 있다. slugslug를 재정의 하는 방법은 frontmatter에 slug를 추가한다.(e.g., content/posts/old-post.md) 1+++ 2title =&amp;#34;New Post&amp;#34; 3slug =&amp;#34;new-post&amp;#34; 4+++ 결과 : example.com/posts/new-post/ urlURL또한 재정의(override)될 수 있다. url은 baseURL 다음으로 올 경로를 넣으면 된다. (참고로 --uglyURLs 옵션을 무시한다) (e.g., content/posts/old-url.md) 1+++ 2title =&amp;#34;old url&amp;#34; 3slug =&amp;#34;/blog/new-url&amp;#34; 4+++  baseURL이 ttps://example.com로 설정된 경우, 기존 url인 posts/old-url.md를 다음처럼 바꾼다.* 결과 : https://example.com/blog/new-url/",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_content_management_1_contents_path/"
},{
  "name": "CMake 정리 Part2 - Commands & Vars",
  "description": " ",
  "body": " Overview cmake를 사용하는데 자주 사용되는 cmake명령어 및 변수들을 정리1. project 초기 설정 CMAKE_MINIMUM_REQUIRED [용법]cmake_minimum_required(VERSION major.minor[.patch[.tweak]][FATAL_ERROR])  만약 어떤 오픈소스 라이브러리가 cmake 3.0 버전 이상으로 작성 되었고, 현재 나의 빌드환경은 cmake 2.8버전 미만이라면 빌드 시, 다음의 에러가 출력된다 -&amp;gt; CMake 3.0 or higher is required. You are running version 2.8.12.2이 커맨드는 반드시 CMakeListst.txt 작성시 맨 처음에 선언해놓아야 정상적인 버전 호환 에러를 출력할 수 있다.# Bad example project(foo) cmake_minimum_required(VERSION 3.0) message(&amp;#34;Using CMake version ${CMAKE_VERSION}&amp;#34;)PROJECT [용법]project(&amp;lt;PROJECT-NAME&amp;gt; [LANGUAGES] [&amp;lt;language-name&amp;gt;...]) project(&amp;lt;PROJECT-NAME&amp;gt; [VERSION &amp;lt;major&amp;gt;[.&amp;lt;minor&amp;gt;[.&amp;lt;patch&amp;gt;[.&amp;lt;tweak&amp;gt;]]]] [LANGUAGES &amp;lt;language-name&amp;gt;...])  이름 및 버전, 언어등 전체 프로젝트에 대한 정의를 한다.아래와 같이 1.0 버전의 c/c++로 작성된 foo라는 프로젝트를 명시할 수 있다. Visual Studio로 예를 들자면 솔루션 탐색기의 최상단에 위치하는 프로젝트의 이름이 된다.# EXAMPLE project( foo C CXX VERSION 1.0 )SET [용법]# Normal Variable set(&amp;lt;variable&amp;gt; &amp;lt;value&amp;gt;... [PARENT_SCOPE]) # Cache Entry set(&amp;lt;variable&amp;gt; &amp;lt;value&amp;gt;... CACHE &amp;lt;type&amp;gt; &amp;lt;docstring&amp;gt; [FORCE])  각종 변수를 정의하는데 사용되는 명령어이다.set( var1 10 )일때 var1은 10의 값을 가지고 현재 디렉토리내에서만 유효하다. 하지만 만약 마지막에 PARENT_SCOPE 옵션을 사용한다면 var1의 scope는 부모 디렉터리까지 유효하게 된다. 또한, ENV옵션을 사용해 다음처럼 환경변수를 정의할 수도 있다.# EXAMPLE set(ENV{LOG_LEVEL} TRACE)INCLUDE  [용법]include(&amp;lt;file|module&amp;gt; [OPTIONAL] [RESULT_VARIABLE &amp;lt;VAR&amp;gt;] [NO_POLICY_SCOPE])  .cmake 로 작성된 파일들을 사용할수 있도록 프로젝트에 포함시킨다. CMAKE_MODULE_PATH라는 예약변수에 의해 경로가 설정되며, 해당 경로를 통해 .cmake 파일을 탐색한다.# EXAMPLE list( APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ) # cmake폴더 path 추가 include( options ) # options.cmake 파일 LoadINCLUDE_DIRECTORIES [용법]include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])  컴파일러에게 각 소스파일에 있는 #include로 포함된 헤더파일들을 포함시킬 수 있도록 하는 명령이다. 아래 예시를 들면 include폴더에 있는 모든 헤더파일을 찾을 수 있도록 한다.# EXAMPLE # 현재 CMakeLists.txt가 실행되는 파일 위치의 경로에서 include라는 폴더를 포함함 include_directories( ${CMAKE_CURRENT_LIST_DIR}/include )ADD_SUBDIRECTORY [용법]add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])  cmake 빌드에 필요한 디렉토리를 추가하는 명령이다. 만약 모듈별, 폴더별로 CMakeLists.txt가 나누어져 있다고 하면, 이 명령어를 통해서 CMakeListst.txt가 있는 폴더의 위치를 명시해줌으로써, 하위 모듈의 CMakeLists.txt파일들을 source_dir에 추가시킬 수 있도록 한다. # EXAMPLE # src 폴더내의 CMakeLists.txt를 포함해 실행될수 있도록 함 add_subdirectory( ${CMAKE_CURRENT_LIST_DIR}/src )2. compile 설정 관련 ADD_COMPILE_OPTIONS [용법]add_compile_options(&amp;lt;option&amp;gt; ...)  소스를 컴파일해 오브젝트 파일(.obj)을 만들때, 컴파일러에게 옵션(flag)를 지정해주는 명령어.add_compile_options(-Wall) 은 gcc -Wall과 대치된다.ADD_DEFINITIONS [용법]add_definitions(-DFOO -DBAR ...)  preprocesor에서 처리할 변수를 선언한다. gcc flag중 -D option에 대치된다. add_definitions( -D__linux__ )는 #define __linux와 같다.CMAKE_BUILD_TYPE project의 build type을 결정한다.- Debug : 디버깅 정보를 포함하는 빌드- Relase : 릴리즈 전용 빌드- RelWithDebInfo : 디버깅 정보를 포함하는 릴리즈 빌드- MinSizeRel : 최소크기를 가지는 릴리즈 빌드# EXAMPLE # 릴리즈로 빌드 set ( CMAKE_BUILD_TYPE Release )CMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다. # EXAMPLE set ( CMAKE_VERBOSE_MAKEFILE true ) true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.CMAKE_VERBOSE_MAKEFILE Makefile output의 verbose정보를 포함여부를 설정하는 변수이다. 초기설정값은 FALSE로 설정돼있다. set ( CMAKE_VERBOSE_MAKEFILE true ) true로 설정시, 빌드 중 Makefile의 빌드 과정을 출력한다.3. build 설정 관련 ADD_EXECUTABLE [용법]add_executable(&amp;lt;name&amp;gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])  &amp;lt;name&amp;gt;으로 설정된 project 타겟에 대하여 source list로부터 실행가능한 executable 파일을 생성한다. 기본적으로 생성된 파일의 위치는 명령어가 발생한 곳의 위치에 생성되며, RUNTIME_OUTPUT_DIRECTORY 변수를 통해 위치를 변경할 수 있다.# EXAMPLE set ( src main.cpp foo.cpp boo.cpp) # test.out의 실행파일을 생성 add_executable( test.out ${src} )LINK_LIBRARIES [용법]link_libraries([item1 [item2 [...]]] [[debug|optimized|general] &amp;lt;item&amp;gt;] ...)  모든 타겟에 대해 사용될 라이브러리를 링크하는 명령. gcc 옵션중 -l에 대치되는 명령이며 링크옵션 또한 사용가능하다.# EXAMPLE  # libbluetooth 라이브러리를 링크 link_libraries( bluetooth )INSTALL [용법]install(TARGETS targets... [EXPORT &amp;lt;export-name&amp;gt;] [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE| PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE] [DESTINATION &amp;lt;dir&amp;gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &amp;lt;component&amp;gt;] [OPTIONAL] [EXCLUDE_FROM_ALL] [NAMELINK_ONLY|NAMELINK_SKIP] ] [...] [INCLUDES DESTINATION [&amp;lt;dir&amp;gt; ...]] )  make install 명령어 입력시 진행되는 과정을 정의하는 명령. 주로 cmake 빌드 과정을 통해 나오는 결과물 ( 실행파일, 라이브러리, 리소스) 등을 특정한 위치로 복사하는 동작을 한다.# EXAMPLE # output.out 바이너리 파일을 /usr/local/bin의 위치로 설치함 install( TARGETS output.out DESTINATION usr/local/bin )4. 기타 FIND_FILE [용법]find_file ( &amp;lt;VAR&amp;gt; name | NAMES name1 [name2 ...] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC &amp;quot;cache documentation string&amp;quot;] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] )  찾을 파일의 이름의 전체경로를 찾아주는 명령. &amp;lt;VAR&amp;gt;변수에 결과가 저장되도록 한다. 만약 경로를 찾지 못하였을경우 &amp;lt;VAR&amp;gt;-NOTFOUND로 최종적으로 저장이된다. # EXAMPLE # test.cpp 파일의 전체 경로를 ${CPP_FILE_PATH}변수에 저장 find_file( CPP_FILE_PATH test.cpp PATHS /home/test )FIND_PACKAGE [용법]find_package(&amp;lt;package&amp;gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE])  시스템에 설치된 Package들을 찾는 명령. Package를 찾았을 경우 &amp;lt;package&amp;gt;_FOUND 변수에 결과가 저장된다.- version : package의 버전을 요청- EXACT : 버전이 정확히 일치하도록 요청- QUIET : package를 찾을 수 없는경우 메시지 비활성화- MODULE : 모듈모드로 package 찾음결론적으로, target link libraries 명령을 사용할 때 사용되는 정보들을 받아 linking하는데 관련된 정보를 사용할 수 있도록 하는 명령어이다. 기타 세부설명은 다음 링크에서 확인한다. click # EXAMPLE find_package( pak 1.0 ) if(pak_FOUND) # ... endif() # pak 이라는 패키지를 찾았으면 if실행  ------------------------------------------ find_package( pak 1.0 REQUIRED ) # pak 이라는 패키지를 찾지 못할경우 오류 메시지 출력 (&amp;#39;REQUIRED&amp;#39;에 의해)  FIND_LIBRARY [용법]find_library ( &amp;lt;VAR&amp;gt; name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC &amp;quot;cache documentation string&amp;quot;] [NO_DEFAULT_PATH] [NO_PACKAGE_ROOT_PATH] [NO_CMAKE_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] )  shared library(.so) , static library(.a) 파일등을 찾는 cmake 명령어이다. 찾고자하는 파일을 발견하면, &amp;lt;VAR&amp;gt;변수에 결과가 저장되며, 라이브러리 파일을 찾지 못하였을 경우 &amp;lt;VAR&amp;gt;-NOTFOUND를 저장한다.# EXAMPLE find_library ( FOO_LIBS NAMES foo PATHS /usr/lib ) # /usr/lib의 경로에서 libfoo.so 라이브러리를 찾았으면 if실행 if( FOO_LIBS ) set( FOO_LIBS_FOUND true ) include_directories(...) message( STATUS &amp;#34;success to find library&amp;#34;) else() message( STATUS &amp;#34;failed to find libarary&amp;#34;) endif()",
  "url": "https://ralpioxxcs.github.io/post/cmake_2/"
},{
  "name": "Hugo Content Management [2] - Page Bundle",
  "description": "Hugo에서는 [Page Bundles](https://gohugo.io/content-management/page-bundles/)이라는 개념을 사용해 컨텐츠를 관리한다.Page Bundles에는 2가지 종류가 있다.",
  "body": " Hugo에서는 Page Bundles이라는 개념을 사용해 컨텐츠를 관리한다. Page Bundles에는 2가지 종류가 있다. Leaf Bundle Branch Bundle  Left Bundle left bundle은 단독 페이지를 구성하는데 사용되고, index.md 파일을 포함하는 폴더로 구성된다.3 of Leaf Bundle Example content/ ├── project │ ├── index.md ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md │ └── study │ ├── first.md │ └── second.md │ └── index.md  project 1개의 index.md파일만을 갖는 leaf bundle pagemy-post 2개의 Markdown 컨텐츠와 index.md파일을 갖는 leaf bundle pagestudy 2개의 Markdown 컨텐츠를 갖는 leaf bundle page* Headless Bundle headless bundle은 다음의 특징을 갖는다.* Permalink를 갖지 않음* .Site.RegularPage의 부분에 속하지 않음다시말해, headless bundle은 어디에도 게시되지않는 무형의 페이지이다. 오직 leaf bundle만이 headless bundle로 만들어 질 수 있다. (추가예정)Branch Bundle branch bundle은 여러 페이지들을 구성하는데 사용되고, leaf bundle과는 다르게 _index.md 파일을 포함하는 폴더로 구성된다.content/ 디렉터리 안에 _index.md파일을 작성할 수도 있다.2 of Leaf Bundle Example content/ ├── branch_bundle_1 │ ├── branch_contents1.md │ ├── branch_contents2.md │ ├── branch_image1.png │ ├── branch_image2.png │ ├── _index_.md │ ├── my-post │ │ ├── content1.md │ │ ├── content2.md │ | ├── image1.png │ | └── index.md ├── branch_bundle_2 │ ├── branch2_contents1.md │ ├── branch2_contents2.md │ ├── _index.md  branch_bundle_1 2개의 Markdown 콘텐츠, 2개의 image, 1개의 leaf bundle, _index.md를 포함하는 branch bundle pagemy-branch_bundle_2 2개의 Markdown 컨텐츠와 index.md파일을 갖는 branch bundle pageindex.md와 _index.md의 차이점     Left Bundle Branch Bundle     파일이름 index.md _index.md   사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing   사용되는 형태 하나의 컨텐츠를 구성 여러 컨텐츠를 listing    ",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_content_management_2_page/"
},{
  "name": "CMake 정리 Part3 - Project configure #1",
  "description": " ",
  "body": "어떤 프로젝트를 cmake를 이용하여 관리 및 빌드하고자 할때, CMakeLists.txt를작성 시 자주 사용되는 cmake 기본 명령어들이 있다.(Root) |- CMakeLists.txt |- README.md |- [src] | |- CMakeListst.txt | |- foo.cpp | |- poo.cpp | |- main.cpp |- [include] | |- foo.h | |- poo.h |- [cmake] | |- options.cmake  이런 구조를 가지는 프로젝트 폴더가 있다고 할 때, CMakeLists.txt는 아래와 같다. 1# [/CMakeListst.txt] 2cmake_minimum_required( VERSION 3.3 ) 3project( foo CXX ) 4# -&amp;gt; &amp;#39;foo&amp;#39;라는 project를 정의한다. 5 6# cmake files 7list( APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ) 8include( options ) 9# -&amp;gt; project 설정관련 전반 .cmake 파일들을 include한다 10 11# build configure 12set( CMAKE_BUILD_TYPE Debug ) 13set( CMAKE_VERBOSE_MAKEFILE true ) 14# -&amp;gt; build 타입및 compile 관련 설정 15 16# -&amp;gt; header파일들을 include paht에 포함시키고 src 폴더내의 CMakeLists.txt를 수행 17include_directories( ${CMAKE_CURRENT_LIST_DIR}/include) 18add_subdirectory(src)src폴더 내, CMakeLists.txt파일은1# [src/CMakeListst.txt] 2 3# src files.. 4set ( SRC_PATH 5 ${CMAKE_CURRENT_LIST_DIR}/main.cpp 6 ${CMAKE_CURRENT_LIST_DIR}/foo.cpp 7 ${CMAKE_CURRENT_LIST_DIR}/poo.cpp 8 ) 9set ( OUTPUT_EFL test.out ) 10# -&amp;gt; build할 파일들을 SRC_PATH 변수에 담는다 11 12# generate executable file 13add_executable( ${OUTPUT_ELF} ${SRC_PATH} ) # -&amp;gt; executable 파일을 생성 14taget_link_libraries( ${OUTPUT_ELF} libs ) # -&amp;gt; 라이브러리 링크 15file( MAKE_DIRECTORY ${CMAKE_SOURCE_DIR}/install ) # -&amp;gt; install 폴더 생성 16 17# install 명령 수행 18install( TARGETS ${OUTPUT_ELF} DESTINATION ${CMAKE_SOURCE_DIR}/install ) ",
  "url": "https://ralpioxxcs.github.io/post/cmake_3/"
},{
  "name": "Hugo Content Management [3] - Front Matter",
  "description": "Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. Formats Hugo는 다음 3가지의 마크업 언어를 지원한다. TOML : +++ YAML : --- JSON : {, }을 이용해 front matter의 시작과 끝을 지정한다.  예를들어, a.md라는 새로운 파일을 만들었다면 --- title: &amp;#34;this is title!&amp;#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,",
  "body": " Front Matter? front matter란 작성하고자 하는 컨텐츠(파일)의 제목, 날짜, 작성자 등의 기본적인 속성들을 나타내는 meta-data 형식이다. Formats Hugo는 다음 3가지의 마크업 언어를 지원한다. TOML : +++ YAML : --- JSON : {, }을 이용해 front matter의 시작과 끝을 지정한다.  예를들어, a.md라는 새로운 파일을 만들었다면 --- title: &amp;#34;this is title!&amp;#34; date: 2019-12-27T13:39:03+09:00 draft: true --- this is the markdown file 이렇게 파일의 시작 부분에 front matter를 설정해주면,위처럼 front matter에 설정한대로, title과 date가 입력이된것을 볼수있다.Variables Hugo에서 미리 정의되고 바로 사용할수 있는 front matter 변수들은 다음과 같다.title content의 제목을 결정한다.description content의 설명draft draft를 true를 설정하면, --buildDrafts 혹은 -D 플래그를 설정하지 않는 이상 이 파일은 hugo로 빌드?되어지지 않는다.weight content의 순서를 결정한다, 숫자가 낮을수록 상단에 위치하게 된다.Accss to front matter ",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_content_management_3_frontmatter/"
},{
  "name": "CMake 정리 Part4 - 색상 지정하기",
  "description": " ",
  "body": " set 변수를 사용해 Shell에 출력되는 문자들의 색상을 지정할 수 있다.1if(NOT WIN32) 2 string(ASCII 27 Esc) 3 set(ColourReset &amp;#34;${Esc}[m&amp;#34;) 4 set(ColourBold &amp;#34;${Esc}[1m&amp;#34;) 5 set(Red &amp;#34;${Esc}[31m&amp;#34;) 6 set(Green &amp;#34;${Esc}[32m&amp;#34;) 7 set(Yellow &amp;#34;${Esc}]33m&amp;#34;) 8 set(Blue &amp;#34;${Esc}]34&amp;#34;) 9 set(Magenta &amp;#34;${Esc}]35m&amp;#34;) 10 set(Cyan &amp;#34;${Esc}]36m&amp;#34;) 11 set(White &amp;#34;${Esc}[37m&amp;#34;) 12 set(BoldRed &amp;#34;${Esc}[1;31m&amp;#34;) 13 set(BoldGreen &amp;#34;${Esc}[1;32m&amp;#34;) 14 set(BoldYellow &amp;#34;${Esc}[1;33m&amp;#34;) 15 set(BoldBlue &amp;#34;${Esc}[1;34m&amp;#34;) 16 set(BoldMagenta &amp;#34;${Esc}[1;35m&amp;#34;) 17 set(BoldCyan &amp;#34;${Esc}[1;36m&amp;#34;) 18 set(BoldWhite &amp;#34;${Esc}[1;37m&amp;#34;) 19endif() 위의 내용을 .cmkae파일로 만들어 include하거나 CmakeLists.txt 의 상단에 삽입한다.Example 1message(&amp;#34; &amp;#34;) 2message( &amp;#34;${BoldGreen}\\t\\t\\t[ BUILD SUMMARY ] ${White}&amp;#34; ) 3message( &amp;#34;${BoldWhite}------------------------------------------------------------------------${ColourReset}&amp;#34;  ",
  "url": "https://ralpioxxcs.github.io/post/cmake_4/"
},{
  "name": "Hugo Content Management [4] - Shortcodes",
  "description": "Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.　Shotcode 사용하기 shortcode는 { {&amp;lt; shortcodename parameters &amp;gt;} } 의 용법으로 간단하게 사용할 수 있다.* shortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..)* parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐 Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다.",
  "body": " Shortcode Hugo는 다양한 shortcode 플러그인들을 제공하고 있다. markdown이 제공하는 편리한 문법들로도 충분하지만, code snippet이나 유튜브 영상등을 추가할 때 유용하게 사용할 수 있다.　Shotcode 사용하기 shortcode는 { {&amp;lt; shortcodename parameters &amp;gt;} } 의 용법으로 간단하게 사용할 수 있다.* shortcodename : 사용할 shortcode의 이름 (ex. highlight, figure..)* parameter : 사용할 shortcode가 어떻게 정의되었느냐에 따라 달라짐 Built-in Shortcodes figure figure는 마크다운이 제공하는 이미지관련 문법보다 더 다양한 기능을 제공한다. parameter를 통해 첨부할 이미지의 title, caption, link등을 지정할 수 있다. code example{ {&amp;lt; figure src=&amp;quot;/images/ar87.jpg&amp;quot; title=&amp;quot;GMK Oblivion&amp;quot; caption=&amp;quot;caption&amp;quot;&amp;gt;} }  use example   GMK Oblivioncaption    highlight 주로 code들을 highlight를 지원하는 언어들은 여기에서 확인할수 있다. 대부분의 언어를 지원한다. code example{ {&amp;lt; highlight cpp &amp;gt;} } #include&amp;lt;stdio.h&amp;gt; printf(&amp;quot;hello world!\\n&amp;quot;) { {&amp;lt; /highlight &amp;gt;} }  use example #include&amp;lt;stdio.h&amp;gt;printf(&amp;#34;hello world!\\n&amp;#34;)   　이외에도 instagram, gist, tweet등 다양한 shortcode를 제공한다.",
  "url": "https://ralpioxxcs.github.io/post/hugo/hugo_content_management_4_shortcodes/"
},{
  "name": "OpenCV 자료형",
  "description": "OpenCV를 사용할 때 자주 사용되는 자료형들을 정리해보았다. 주로 `Point`, `Mat` 등이 있다.",
  "body": " OpenCV를 사용할 때 자주 사용되는 자료형들을 정리해보았다.주로 Point, Mat 등이 있다.Point point 클래스는 점의 좌표를 표현할 때 자주 사용된다.[ 멤버 변수 ]* x, ytemplate&amp;lt;typename _Tp&amp;gt; class Point_ { public: Point_(); Point_(_Tp _x, _Tp _y); Point_(const Point_&amp;amp; pt); Point&amp;amp; operator= (const Point_&amp;amp; pt); .... _Tp x, y; }; typedef Point_&amp;lt;int&amp;gt; Point2i; typedef Point_&amp;lt;int64&amp;gt; Point2l; typedef Point_&amp;lt;float&amp;gt; Point2f; typedef Point_&amp;lt;double&amp;gt; Point2d; typedef Point2i Point  point 클래스를 초기화하는 방법은 2가지가 있다.cv::Point pt(10,20); // 선언과 동시에 초기화 cv::Point pt2 = pt; // 대입 연산자를 이용한 초기화  Size size 클래스는 주로 사각형의 크기를 나타낼 때 쓰인다.[ 멤버 변수 ]* width, heighttemplate&amp;lt;typename _Tp&amp;gt; class Size_ { public: Size(); Size(_Tp _width, _Tp _height); Point_(const Size_&amp;amp; sz); Point&amp;amp; operator= (const Size&amp;amp; sz); .... _Tp width, height; }; typedef Size_&amp;lt;int&amp;gt; Size2i; typedef Size_&amp;lt;int64&amp;gt; Size2l; typedef Size_&amp;lt;float&amp;gt; Size2f; typedef Size_&amp;lt;double&amp;gt; Size2d; typedef Size2i Size  size 클래스 또한 선언과 동시에 초기화 및 대입을 통해 초기화가 가능하다.cv::Size sz(100,200); // 선언과 동시에 초기화  // width : 100, height : 200 cv::Size sz2 = sz; // 대입 연산자를 이용한 초기화  Rect Rect 클래스는 사각형의 속성을 나타낼 때 주로쓰인다.[ 멤버 변수 ]* x, y* width, height template&amp;lt;typename _Tp&amp;gt; class Rect_ { public: Rect_(); Rect_(_Tp _width, _Tp _height); Point_(const Size_&amp;amp; sz); Point&amp;amp; operator= (const Size&amp;amp; sz); .... _Tp width, height; _Tp x, y }; typedef Size_&amp;lt;int&amp;gt; Size2i; typedef Size_&amp;lt;int64&amp;gt; Size2l; typedef Size_&amp;lt;float&amp;gt; Size2f; typedef Size_&amp;lt;double&amp;gt; Size2d; typedef Size2i Size  size 클래스 또한 선언과 동시에 초기화 및 대입을 통해 초기화가 가능하다.cv::Size sz(100,200); // 선언과 동시에 초기화  // width : 100, height : 200 cv::Size sz2 = sz; // 대입 연산자를 이용한 초기화  ",
  "url": "https://ralpioxxcs.github.io/study/opencv/opencv1/"
},{
  "name": "Keyboard_xo_v2",
  "description": "",
  "body": "",
  "url": "https://ralpioxxcs.github.io/life/keyboard_xo_v2/"
},{
  "name": "Basic_1",
  "description": "",
  "body": "",
  "url": "https://ralpioxxcs.github.io/study/linux/basic_1/"
},{
  "name": "Bash Shell 색상 지정하기",
  "description": " ",
  "body": "",
  "url": "https://ralpioxxcs.github.io/study/linux/shell_color/"
}
]
