<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Dev Blog</title>
    <link>https://ralpioxxcs.github.io/</link>
    <description>Recent content on My Dev Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Oct 2019 22:40:55 +0900</lastBuildDate>
    <atom:link href="https://ralpioxxcs.github.io/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bash Shell 색상 지정하기</title>
      <link>https://ralpioxxcs.github.io/study/linux/shell_color/</link>
      <pubDate>Wed, 09 Oct 2019 22:40:55 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/linux/shell_color/</guid>
      <description>shell script에 색상을 사용하는 방법이 있다.</description>
    </item>
    
    
    
    <item>
      <title>CirculaQueue</title>
      <link>https://ralpioxxcs.github.io/study/datastructure/circulaqueue/</link>
      <pubDate>Wed, 18 Sep 2019 21:59:22 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/datastructure/circulaqueue/</guid>
      <description>1. 개요 선입선출(先入先出, First In First Out; FIFO)의 자료구조로써, 데이터가 나가는 위치, 큐의 첫번째 위치를 Front 라고 하고 데이터가 삽입되는 지점, 큐의 마지막 데이터의 한 칸 다음 위치를 Rear 혹은 Back이라고 한다.
큐에 데이터를 삽입하는 과정을 Enqueue, 빼는 과정을 Dequeue라고 한다. 선입선출 형태이므로 주로 대기열, 줄서기 같은곳에 쓰이는 구조이다.
2. 선형 큐 (Linear Queue) 예를들어 사이즈가 5인 큐가 있다고 하자. 초기에는 Front와 Rear 둘다 0을 가리키고 있는상태이다. 데이터를 하나 삽입하면 Front값을 그대로 Rear값은 하나 증가한다 (1번방 가리키고있는상태) 그 다음 방금 넣었던 데이터를 삭제하면 Front값이 하나 증가하여 1번방을 가리키고, 이 상태는 큐가 비었다는것을 뜻 한다.</description>
    </item>
    
    
    
    <item>
      <title>LinkedList</title>
      <link>https://ralpioxxcs.github.io/study/datastructure/linkedlist/</link>
      <pubDate>Sat, 14 Sep 2019 13:54:02 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/datastructure/linkedlist/</guid>
      <description>1. 개요 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
단순 연결 리스트는 단 방향이기 때문에 Head 노드의 주소를 잃어버릴 경우 모든 자료들의 접근이 불가능해지므로 안정적인 자료구조는 아니다.
이전, 다음 노드의 참조가 모두 가능하므로 탐색에 용이하고, 단순 연결 리스트에서 삭제를 하려면 시간이 오래 걸리는 것에 비해 이중 연결 리스트에서의 노드 삭제는 훨씬 간단하다.</description>
    </item>
    
    
    
    <item>
      <title>Getting Started Hugo [2] - 디렉터리 구조</title>
      <link>https://ralpioxxcs.github.io/post/hugo_structure/</link>
      <pubDate>Fri, 13 Sep 2019 20:15:50 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/hugo_structure/</guid>
      <description>명령창에 $ hugo new site를 입력하면 아래의 구조를 가진 폴더가 하나 생성되는것을 보았을것이다. 각각의 폴더의 역할은 다음과 같다.
( root ) ├─ archetypes ├─ content ├─ data ├─ layouts ├─ static ├─ themes ├─ config.toml  archetypes $ hugo new 커맨드를 이용해 새로운 contents 파일을 만들때, 이 폴더내의 default.md 의 front matter 형태를 갖는 content를 자동으로 초기화 하여 만들어준다. 많은양의 content를 만들 때 유용하게 사용될수 있고, front matter field를 직접 수정하여 하나의 archtypes로 만들 수 있다.</description>
    </item>
    
    
    
    <item>
      <title>Stack</title>
      <link>https://ralpioxxcs.github.io/study/datastructure/stack/</link>
      <pubDate>Fri, 13 Sep 2019 13:54:02 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/datastructure/stack/</guid>
      <description>1. 개요 후입선출(後入先出, Last In First Out; LIFO) 의 자료구조로, 상자의 형태를 한 자료구조이다. 데이터의 삽입을 Push, 데이터의 출력을 Pop이라고 하며, 스택을 크게 두 가지로 나누면
Ascending Stack VS Descending Stack으로 나눌 수 있다.
스택은 배열과 링크드 리스트로 구현할 수 있는데, 여기서는 링크드리스트를 이용한 스택을 구현해 보겠다.
2. 코드 구현 2-1. define structure typedef struct _stacknode Snode;struct _stacknode {DataType data;Snode *next;};typedef struct _stack {Snode *head;Snode *tail;Snode *cur;}Stack;  스택관리구조체 Stack은 링크드리스트 구조체처럼 head와 tail을 고정적으로 가리키는 노드포인터와 현재 노드를 가리키는 cur 포인터로 이루어져있다.</description>
    </item>
    
    
    
    <item>
      <title>Getting Started Hugo [3] - Front Matter</title>
      <link>https://ralpioxxcs.github.io/post/hugo_frontmatter/</link>
      <pubDate>Sun, 11 Aug 2019 10:36:14 +0200</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/hugo_frontmatter/</guid>
      <description>FrontMatter? FrontMatter is meta this is test aha</description>
    </item>
    
    
    
    <item>
      <title>Getting Started Hugo [1] - Github 블로그 생성</title>
      <link>https://ralpioxxcs.github.io/post/hugo_manual/</link>
      <pubDate>Sat, 10 Aug 2019 13:36:24 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/hugo_manual/</guid>
      <description>Hugo란? Hugo는 웹사이트를 간편하게 만들어주는 정적 사이트 생성기 (static site generator)중 하나이며, 비슷한 생성기들 중 대표적인 예로는 Jekyll (지킬이라고 부른다)이 있다. 처음에는 지킬을 사용하여 블로그를 만들려했다가 단순하게 뭔가 Jekyll보다는 Hugo의 네이밍이 마음에 들어서 Hugo를 선택하여 블로그를 개설하게 되었다.
Step 1 : Hugo 설치 (Windows) 1.1 다운로드 Hugo를 설치하는 방법은 간단하다. 아래의 URL을 클릭하여 다운로드 사이트로 이동한 뒤, 32bit, 64bit 를 확인하여 다운로드 한다.
Hugo download link
1.2 환경 설정 C드라이브에 hugo폴더를 생성한 뒤 그 안에 bin폴더를 생성,압축파일에 있던 hugo.</description>
    </item>
    
    
    
    
    
    
    
    
  </channel>
</rss>
