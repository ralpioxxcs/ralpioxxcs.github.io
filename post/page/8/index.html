<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Post | Devlog</title><meta name=keywords content><meta name=description content="Post - Devlog"><meta name=author content="ralpioxxcs"><link rel=canonical href=https://ralpioxxcs.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.08a5f35ab5268c046cc88caf6d08ea3d46d4e46a847fb4bd272b6b5e063803a7.css integrity="sha256-CKXzWrUmjARsyIyvbQjqPUbU5GqEf7S9JytrXgY4A6c=" rel="preload stylesheet" as=style><link rel=icon href=https://ralpioxxcs.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ralpioxxcs.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ralpioxxcs.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ralpioxxcs.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ralpioxxcs.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ralpioxxcs.github.io/post/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-189380926-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="Post"><meta property="og:description" content="Archiving develop logs"><meta property="og:type" content="website"><meta property="og:url" content="https://ralpioxxcs.github.io/post/"><meta property="og:site_name" content="Devlog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Post"><meta name=twitter:description content="Archiving develop logs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://ralpioxxcs.github.io/post/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ralpioxxcs.github.io/ accesskey=h title="Devlog (Alt + H)"><img src=https://ralpioxxcs.github.io/apple-touch-icon.png alt=logo aria-label=logo height=22>Devlog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ralpioxxcs.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ralpioxxcs.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ralpioxxcs.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ralpioxxcs.github.io/>Home</a></div><h1>Post
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>C로 구현하는 자료구조 - Binary Tree</h2></header><div class=entry-content><p>“트리 (Tree)” 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 “루트노드 (Root Node)” 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 “서브 트리 (Sub Tree)“라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 “부모 노드 (Parent Node)” 라고 하고 그 바로 아래 노드들을 “자식 노드 (Children Node)“라 한다.
이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다....</p></div><footer class=entry-footer><span title='2019-09-18 13:54:02 +0900 KST'>September 18, 2019</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1740 words&nbsp;·&nbsp;ralpioxxcs</footer><a class=entry-link aria-label="post link to C로 구현하는 자료구조 - Binary Tree" href=https://ralpioxxcs.github.io/post/cs/binary_tree/></a></article><article class=post-entry><header class=entry-header><h2>C로 구현하는 자료구조 - Graph</h2></header><div class=entry-content><p>Graph 그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.
(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)
Implementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다....</p></div><footer class=entry-footer><span title='2019-09-13 13:54:02 +0900 KST'>September 13, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1305 words&nbsp;·&nbsp;ralpioxxcs</footer><a class=entry-link aria-label="post link to C로 구현하는 자료구조 - Graph" href=https://ralpioxxcs.github.io/post/cs/graph_matrix/></a></article><article class=post-entry><header class=entry-header><h2>C로 구현하는 자료구조 - Linked List</h2></header><div class=entry-content><p>자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
Implementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,...</p></div><footer class=entry-footer><span title='2019-09-13 13:54:02 +0900 KST'>September 13, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;646 words&nbsp;·&nbsp;ralpioxxcs</footer><a class=entry-link aria-label="post link to C로 구현하는 자료구조 - Linked List" href=https://ralpioxxcs.github.io/post/cs/linked_list/></a></article><article class=post-entry><header class=entry-header><h2>C로 구현하는 자료구조 - stack</h2></header><div class=entry-content><p>후입선출(Last In First Out; LIFO)의 특성을 갖는 자료구조로, 데이터를 쌓아올리는(stack)의 형태를 갖는다.
push: 데이터를 넣는 작업 pop: 데이터를 꺼내는 작업 Implementation 스택은 배열(array)와 연결리스트(linked list)로 구현할 수 있는데, 여기서는 연결리스트를 이용해서 스택을 구현할 것이다.
structure typedef struct node { void* data; struct node *next; } node; typedef struct stack { int size; node *head; } stack; 동적으로 할당할 data와 다음 노드를 가리킬 next 포인터로 하나의 element 형태를 갖는다.
initialize stack init_stack() { stack st; st....</p></div><footer class=entry-footer><span title='2019-09-13 13:54:02 +0900 KST'>September 13, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;190 words&nbsp;·&nbsp;ralpioxxcs</footer><a class=entry-link aria-label="post link to C로 구현하는 자료구조 - stack" href=https://ralpioxxcs.github.io/post/cs/stack/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ralpioxxcs.github.io/post/page/7/>« Prev</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://ralpioxxcs.github.io/>Devlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>