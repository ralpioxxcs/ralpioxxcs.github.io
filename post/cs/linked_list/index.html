<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C로 구현하는 자료구조 - Linked List | Devlog</title><meta name=keywords content="cs,data structure"><meta name=description content="자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
Implementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,"><meta name=author content="ralpioxxcs"><link rel=canonical href=https://ralpioxxcs.github.io/post/cs/linked_list/><link crossorigin=anonymous href=/assets/css/stylesheet.3b9f476f1ea36ffba82578fc22bf4f0d29acf30b8cecc3387b6496b49caf0aac.css integrity="sha256-O59Hbx6jb/uoJXj8Ir9PDSms8wuM7MM4e2SWtJyvCqw=" rel="preload stylesheet" as=style><link rel=icon href=https://ralpioxxcs.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ralpioxxcs.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ralpioxxcs.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ralpioxxcs.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ralpioxxcs.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/prism-themes/prism.css><link rel=stylesheet href=/prism-themes/prism-nord.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-189380926-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="C로 구현하는 자료구조 - Linked List"><meta property="og:description" content="자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
Implementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,"><meta property="og:type" content="article"><meta property="og:url" content="https://ralpioxxcs.github.io/post/cs/linked_list/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-09-13T13:54:02+09:00"><meta property="article:modified_time" content="2019-09-13T13:54:02+09:00"><meta property="og:site_name" content="Devlog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C로 구현하는 자료구조 - Linked List"><meta name=twitter:description content="자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
Implementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://ralpioxxcs.github.io/post/"},{"@type":"ListItem","position":2,"name":"C로 구현하는 자료구조 - Linked List","item":"https://ralpioxxcs.github.io/post/cs/linked_list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C로 구현하는 자료구조 - Linked List","name":"C로 구현하는 자료구조 - Linked List","description":"자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.\nImplementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,","keywords":["cs","data structure"],"articleBody":"자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다. 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.\nImplementation structure typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList; LinkedList 구조체는 리스트 관리 구조체로서,\n순회를 하기 위한 Head, Tail 노드만을 가리키는 노드 포인터와 현재 노드 가리킴 및 여러 용도로 쓰이는 노드 포인터, 노드의 개수를 저장하는 int형 변수로 이루어져 있다. initalization void create(LinkedList * lp) { lp-\u003ehead = (Node *)malloc(sizeof(Node)); //헤드 노드 생성 assert(lp-\u003ehead!=NULL); lp-\u003etail = (Node *)malloc(sizeof(Node)); //테일 노드 생성 assert(lp-\u003etail!=NULL); /*head node와 tail node를 연결 함*/ lp-\u003ehead-\u003eprev=lp-\u003ehead; lp-\u003ehead-\u003enext=lp-\u003etail; lp-\u003etail-\u003eprev=lp-\u003ehead; lp-\u003etail-\u003enext=lp-\u003etail; lp-\u003ecur=NULL; //cur가 NULL pointer로 초기화 lp-\u003elength=0; //데이터 노드의 개수를 0으로 초기화 return ; } 헤드 노드, 테일 노드를 할당 후, 헤드 노드와 테일 노드를 서로 연결해준다.\npush node Node * makeNode(DataType *dataPtr, Node *prev, Node *next) { Node *np; np = (Node *)malloc(sizeof(Node)); //새로운 노드 생성 assert(np!=NULL); np-\u003eprev = prev; np-\u003enext = next; np-\u003edata = *dataPtr; if(prev != NULL) { prev-\u003enext = np; } if(next != NULL) { next-\u003eprev = np; } return np; } Node * appendFromTail(LinkedList *lp, DataType *dataPtr) { lp-\u003ecur = makeNode(dataPtr, lp-\u003etail-\u003eprev, lp-\u003etail); //새로운 노드 생성 assert(lp-\u003ecur!=NULL); lp-\u003elength++; //데이터개수 1 증가 return lp-\u003ecur; } 양방향 연결 리스트에서 노드를 삽입하는 방법은 두 가지가 있다, 첫 번째는 헤드 노드 앞으로 데이터를 삽입하는 법과 테일 노 드 뒤쪽으로 데이터를 삽입하는 방식이다. 헤드 노드 앞으로 데이터를 삽입하는 방법은 데이터를 다 넣고 출력을 하게 되면 데이터의 순서가 들어온 순서랑 역순이 되므로 여기선, 테일 노 드 뒤로 삽입하는 코드를 썼다. 우선, 첫째로 makeNode 함수를 이용하여 노드를 하나 할당 후, 데이터 개수를 1개 증가시켜준다. makeNode 함수는 malloc을 통해 메모리를 할당 후, 전달인자로 이전 노드, 다음 노드를 가져와 서로 선을 이어주는 함수이다.\nremove node void deleteNode (LinkedList *lp, Node *target) { if(target==NULL) { return; } //삭제할 데이터의 앞,뒤 노드를 연결시킴 target-\u003eprev-\u003enext=target-\u003enext; target-\u003enext-\u003eprev=target-\u003eprev; free(target); // target노드 삭제 lp-\u003elength--; // 데이터 개수 1 감소 } void destroy (LinkedList *lp) { while(lp-\u003ehead-\u003enext != lp-\u003etail) { // 데이터 노드가 있다면 해제 deleteNode(lp,lp-\u003ehead-\u003enext); // head 노드 바로 뒷 노드를 삭제 } free(lp-\u003ehead); // head 노드 삭제 free(lp-\u003etail); // tail 노드 삭제 lp-\u003ehead = lp-\u003ecur = lp-\u003etail = NULL; //모든 포인터를 NULL로 초기화 lp-\u003elength = 0; //데이터개수 0으로 초기화 return ; } 노드를 삭제하는 함수, 모든 노드를 삭제하는 함수이다. deleteNode함수는 전달인자로 삭제할 노드 (target)을 받아 target노드의 이전노드와 target노드의 다음노드를 서로 이어준 뒤, target노드를 free함수를 통해 메모리를 해제하는 방식으로 이루어져있다. destory함수는 우선 헤드 노드와 테일 노드를 삭제 한 후, 나머지 데이터노드들을 순차적으로 메모리 해제해주는 방식이다.\nsort void deleteNode (LinkedList *lp, Node *target) void sortList(LinkedList *lp, int (*compare)(DataType *, DataType *)) { Node *tp; Node *target; DataType temp; // swap용 임시변수 lp-\u003ecur=lp-\u003ehead-\u003enext; // 첫 데이터 노드를 가리키게 하고 while(lp-\u003ecur!=lp-\u003etail) {// 맨 뒷 노드까지 검색 target = lp-\u003ecur; tp=lp-\u003ecur-\u003enext; // cur의 다음 노드를 가리키게 함 while(tp!=lp-\u003etail) { if(compare(\u0026target-\u003edata, \u0026tp-\u003edata) \u003e 0) { target = tp; } tp=tp-\u003enext; } temp = lp-\u003ecur-\u003edata; lp-\u003ecur-\u003edata = target-\u003edata; target-\u003edata = temp; lp-\u003ecur=lp-\u003ecur-\u003enext; } return; } 변수로는 임시 노드 포인터 tp와 정렬할때 바뀜이 되는 대상 임시 노드 포인터 target, 그리고 Data Swap을 위해 필요한 temp변수가 있다. 링크드리스트 관리 구조체의 cur포인터를 헤드노드 뒷 노드 즉, 첫번째 데이터노드를 가리키게 한 뒤, 반복문을 통해 데이터 끝까지 갈 수 있도록 해준다. 여기서, target노드는 현재 cur포인터로 지정해주고 임시 tp포인터는 cur포인터의 다음 노드를 가리키게 한다. (ex) 45 - 25 - 11 - 5 - 23 의 구조로 이루어져있는 링크드 리스트일때 target을 45, tp를 25로 지정) compare함수를 통해 비교하고 그것이 참이면 서로 swap해준다.\n","wordCount":"646","inLanguage":"en","datePublished":"2019-09-13T13:54:02+09:00","dateModified":"2019-09-13T13:54:02+09:00","author":{"@type":"Person","name":"ralpioxxcs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ralpioxxcs.github.io/post/cs/linked_list/"},"publisher":{"@type":"Organization","name":"Devlog","logo":{"@type":"ImageObject","url":"https://ralpioxxcs.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ralpioxxcs.github.io/ accesskey=h title="Devlog (Alt + H)"><img src=https://ralpioxxcs.github.io/apple-touch-icon.png alt=logo aria-label=logo height=20>Devlog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ralpioxxcs.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ralpioxxcs.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ralpioxxcs.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ralpioxxcs.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ralpioxxcs.github.io/post/>Post</a></div><h1 class=post-title>C로 구현하는 자료구조 - Linked List</h1><div class=post-meta><span title='2019-09-13 13:54:02 +0900 KST'>September 13, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;646 words&nbsp;·&nbsp;ralpioxxcs&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/cs/linked_list.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>자료구조의 일종인 링크드리스트는 각 노드당 데이터를 저장하는 데이터필드 영역과 다음 노드를 가리키는 노드 포인터 영역으로 구성된 자료구조이다.
비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다.
반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><h3 id=structure>structure<a hidden class=anchor aria-hidden=true href=#structure>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_node</span> <span class=n>Node</span><span class=p>;</span>    <span class=c1>// 구조체 노드 형명재지정
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>_node</span><span class=p>{</span>         <span class=c1>// 데이터를 보관할 노드(자기참조 구조체)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>               <span class=c1>// 앞 노드를 가리키는 멤버
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DataType</span> <span class=n>data</span><span class=p>;</span>            <span class=c1>// 데이터 저장 멤버
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>               <span class=c1>// 뒷 노드를 가리키는 멤버
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_linkedList</span><span class=p>{</span>   <span class=c1>// 리스트 관리 구조체
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>               <span class=c1>// 헤드포인터 (헤드노드 가리킴)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>cur</span><span class=p>;</span>                <span class=c1>// 특정 작업 시 노드를 가리키기 위한 포인터
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>               <span class=c1>// 테일포인터 (테일노드 가리킴)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>length</span><span class=p>;</span>               <span class=c1>// 실제 데이터노드의 갯수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>LinkedList</span><span class=p>;</span>
</span></span></code></pre></div><p>LinkedList 구조체는 리스트 관리 구조체로서,</p><ul><li>순회를 하기 위한 Head, Tail 노드만을 가리키는 노드 포인터와</li><li>현재 노드 가리킴 및 여러 용도로 쓰이는 노드 포인터,</li><li>노드의 개수를 저장하는 int형 변수로 이루어져 있다.</li></ul><h3 id=initalization>initalization<a hidden class=anchor aria-hidden=true href=#initalization>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>create</span><span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span> <span class=n>lp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span> <span class=o>=</span> <span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span> <span class=c1>//헤드 노드 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span> <span class=c1>//테일 노드 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*head node와 tail node를 연결 함*/</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span> <span class=c1>//cur가 NULL pointer로 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>length</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=c1>//데이터 노드의 개수를 0으로 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>헤드 노드, 테일 노드를 할당 후, 헤드 노드와 테일 노드를 서로 연결해준다.</p><h3 id=push-node>push node<a hidden class=anchor aria-hidden=true href=#push-node>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span> <span class=nf>makeNode</span><span class=p>(</span><span class=n>DataType</span> <span class=o>*</span><span class=n>dataPtr</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>prev</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span> <span class=o>=</span> <span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span> <span class=c1>//새로운 노드 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>np</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=o>*</span><span class=n>dataPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>prev</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>next</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span> <span class=nf>appendFromTail</span><span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=n>DataType</span> <span class=o>*</span><span class=n>dataPtr</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span> <span class=o>=</span> <span class=n>makeNode</span><span class=p>(</span><span class=n>dataPtr</span><span class=p>,</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>,</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>);</span>  <span class=c1>//새로운 노드 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>length</span><span class=o>++</span><span class=p>;</span> <span class=c1>//데이터개수 1 증가
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>양방향 연결 리스트에서 노드를 삽입하는 방법은 두 가지가 있다, 첫 번째는 헤드 노드 앞으로 데이터를 삽입하는 법과 테일 노 드 뒤쪽으로 데이터를 삽입하는 방식이다.
헤드 노드 앞으로 데이터를 삽입하는 방법은 데이터를 다 넣고 출력을 하게 되면 데이터의 순서가 들어온 순서랑 역순이 되므로 여기선, 테일 노 드 뒤로 삽입하는 코드를 썼다. 우선, 첫째로 <code>makeNode</code> 함수를 이용하여 노드를 하나 할당 후, 데이터 개수를 1개 증가시켜준다.
<code>makeNode</code> 함수는 malloc을 통해 메모리를 할당 후, 전달인자로 이전 노드, 다음 노드를 가져와 서로 선을 이어주는 함수이다.</p><h3 id=remove-node>remove node<a hidden class=anchor aria-hidden=true href=#remove-node>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deleteNode</span> <span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>target</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//삭제할 데이터의 앞,뒤 노드를 연결시킴
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>target</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>=</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>target</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>=</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>target</span><span class=p>);</span>       <span class=c1>// target노드 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>length</span><span class=o>--</span><span class=p>;</span>       <span class=c1>// 데이터 개수 1 감소
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>destroy</span> <span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span><span class=n>lp</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>!=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 데이터 노드가 있다면 해제
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>deleteNode</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span> <span class=c1>// head 노드 바로 뒷 노드를 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>);</span> <span class=c1>// head 노드 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>free</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>);</span> <span class=c1>// tail 노드 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>//모든 포인터를 NULL로 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>//데이터개수 0으로 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>노드를 삭제하는 함수, 모든 노드를 삭제하는 함수이다.
<code>deleteNode</code>함수는 전달인자로 삭제할 노드 (target)을 받아 target노드의 이전노드와 target노드의 다음노드를 서로 이어준 뒤, target노드를 free함수를 통해 메모리를 해제하는 방식으로 이루어져있다. <code>destory</code>함수는 우선 헤드 노드와 테일 노드를 삭제 한 후, 나머지 데이터노드들을 순차적으로 메모리 해제해주는 방식이다.</p><h3 id=sort>sort<a hidden class=anchor aria-hidden=true href=#sort>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deleteNode</span> <span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>sortList</span><span class=p>(</span><span class=n>LinkedList</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>compare</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>,</span> <span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>tp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DataType</span> <span class=n>temp</span><span class=p>;</span>  <span class=c1>// swap용 임시변수 
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl>    <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>  <span class=c1>// 첫 데이터 노드를 가리키게 하고
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>!=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 맨 뒷 노드까지 검색
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>target</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tp</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span> <span class=c1>// cur의 다음 노드를 가리키게 함
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span><span class=p>(</span><span class=n>tp</span><span class=o>!=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>tail</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>target</span> <span class=o>=</span> <span class=n>tp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>tp</span><span class=o>=</span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>target</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>target</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>=</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>변수로는 임시 노드 포인터 tp와 정렬할때 바뀜이 되는 대상 임시 노드 포인터 target, 그리고 Data Swap을 위해 필요한 temp변수가 있다.
링크드리스트 관리 구조체의 cur포인터를 헤드노드 뒷 노드 즉, 첫번째 데이터노드를 가리키게 한 뒤, 반복문을 통해 데이터 끝까지 갈 수 있도록 해준다.
여기서, target노드는 현재 cur포인터로 지정해주고 임시 tp포인터는 cur포인터의 다음 노드를 가리키게 한다.
(ex) 45 - 25 - 11 - 5 - 23 의 구조로 이루어져있는 링크드 리스트일때 target을 45, tp를 25로 지정)
compare함수를 통해 비교하고 그것이 참이면 서로 swap해준다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ralpioxxcs.github.io/tags/cs/>cs</a></li><li><a href=https://ralpioxxcs.github.io/tags/data-structure/>data structure</a></li></ul><nav class=paginav><a class=prev href=https://ralpioxxcs.github.io/post/cs/graph_matrix/><span class=title>« Prev</span><br><span>C로 구현하는 자료구조 - Graph</span></a>
<a class=next href=https://ralpioxxcs.github.io/post/cs/stack/><span class=title>Next »</span><br><span>C로 구현하는 자료구조 - stack</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on twitter" href="https://twitter.com/intent/tweet/?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f&hashtags=cs%2cdatastructure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f&title=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List&summary=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List&source=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f&title=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on whatsapp" href="https://api.whatsapp.com/send?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List%20-%20https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Linked List on telegram" href="https://telegram.me/share/url?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Linked%20List&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2flinked_list%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ralpioxxcs.github.io/>Devlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=/js/prism.js></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>