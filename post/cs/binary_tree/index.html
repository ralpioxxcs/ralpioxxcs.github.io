<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C로 구현하는 자료구조 - Binary Tree | Devlog</title><meta name=keywords content="cs,data structure"><meta name=description content="&ldquo;트리 (Tree)&rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 &ldquo;루트노드 (Root Node)&rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 &ldquo;서브 트리 (Sub Tree)&ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 &ldquo;부모 노드 (Parent Node)&rdquo; 라고 하고 그 바로 아래 노드들을 &ldquo;자식 노드 (Children Node)&ldquo;라 한다.
이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다."><meta name=author content="ralpioxxcs"><link rel=canonical href=https://ralpioxxcs.github.io/post/cs/binary_tree/><link crossorigin=anonymous href=/assets/css/stylesheet.3b9f476f1ea36ffba82578fc22bf4f0d29acf30b8cecc3387b6496b49caf0aac.css integrity="sha256-O59Hbx6jb/uoJXj8Ir9PDSms8wuM7MM4e2SWtJyvCqw=" rel="preload stylesheet" as=style><link rel=icon href=https://ralpioxxcs.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ralpioxxcs.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ralpioxxcs.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ralpioxxcs.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ralpioxxcs.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/prism-themes/prism.css><link rel=stylesheet href=/prism-themes/prism-nord.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-189380926-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="C로 구현하는 자료구조 - Binary Tree"><meta property="og:description" content="&ldquo;트리 (Tree)&rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 &ldquo;루트노드 (Root Node)&rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 &ldquo;서브 트리 (Sub Tree)&ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 &ldquo;부모 노드 (Parent Node)&rdquo; 라고 하고 그 바로 아래 노드들을 &ldquo;자식 노드 (Children Node)&ldquo;라 한다.
이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다."><meta property="og:type" content="article"><meta property="og:url" content="https://ralpioxxcs.github.io/post/cs/binary_tree/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-09-18T13:54:02+09:00"><meta property="article:modified_time" content="2019-09-18T13:54:02+09:00"><meta property="og:site_name" content="Devlog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C로 구현하는 자료구조 - Binary Tree"><meta name=twitter:description content="&ldquo;트리 (Tree)&rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 &ldquo;루트노드 (Root Node)&rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 &ldquo;서브 트리 (Sub Tree)&ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 &ldquo;부모 노드 (Parent Node)&rdquo; 라고 하고 그 바로 아래 노드들을 &ldquo;자식 노드 (Children Node)&ldquo;라 한다.
이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://ralpioxxcs.github.io/post/"},{"@type":"ListItem","position":2,"name":"C로 구현하는 자료구조 - Binary Tree","item":"https://ralpioxxcs.github.io/post/cs/binary_tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C로 구현하는 자료구조 - Binary Tree","name":"C로 구현하는 자료구조 - Binary Tree","description":"\u0026ldquo;트리 (Tree)\u0026rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 \u0026ldquo;루트노드 (Root Node)\u0026rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 \u0026ldquo;서브 트리 (Sub Tree)\u0026ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 \u0026ldquo;부모 노드 (Parent Node)\u0026rdquo; 라고 하고 그 바로 아래 노드들을 \u0026ldquo;자식 노드 (Children Node)\u0026ldquo;라 한다.\n이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다.","keywords":["cs","data structure"],"articleBody":" “트리 (Tree)” 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 “루트노드 (Root Node)” 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 “서브 트리 (Sub Tree)“라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 “부모 노드 (Parent Node)” 라고 하고 그 바로 아래 노드들을 “자식 노드 (Children Node)“라 한다.\n이런 트리구조에서 파생된 자료구조를 이진트리 (Binary Tree) 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다. 이런 이진트리에서는 서브트리가 2개 이하기 때문에 서브트리는 왼쪽과 오른쪽으로 구분된다.\n이진트리를 구현하는 방법으로 배열과 링크드리스트 2가지가 있다.\n배열 배열로 구현하게 될 경우, 연결리스트로 구현하는것보다 더 복잡하고 생각해야할것이 많다. 하지만 그렇다고해서 아예 안쓰이지는 않고, 힙 트리의 경우 배열로 구현하게 되는 경우가 많다. 배열로 구현하는 방법은 다음과 같다.\n우선, 0번방은 비워놓고 루트노드를 1번방으로 시작하여 내려간다. 임의의 노드를 탐색하고 싶은 경우 해당 배열 방 번호를 입력하면 된다. [그림 2]처럼 데이터 4의 노드에서 오른쪽 자식노드(5)를 가고자 하면 =\u003e (2 x i ) + 1 을 해주면 데이터 5의 방 번호가 나온다.\n정리하면,\n노드 i의 부모 노드 = i/2 노드 i의 왼쪽 자식 노드 = 2 x i 노드 i의 오른쪽 자식 노드 = ( 2 x i ) + 1 루트 노드 = 1 배열로 구현하는 방법의 장점은 시간복잡도를 줄일수 있다는 점이 있지만, 편향 진트리의 경우 사용하지 않는 배열 원소에 대한 메모리 낭비가 발생하고, 삽입/삭제에 대한 배열의 크기 변경이 어렵다는 점이 있다.\n링크드리스트 링크드 리스트로 구현하는 방법은 배열로 구현하는것보다 더 쉽고 접근에 있어서 더 직관적이다. 하지만, 배열 구조에서만 가능한 임의 노드로의 접근이 불편(?)하다. 데이터가 커질수록 전위,후위 순회 하는 속도가 더 느려지므로 탐색시간에 있어서 링크드 리스트가 배열 구조보다 시간이 더 오래걸린다는 점이 있다.\n구조체 정의 typedef struct _node Node; typedef struct _node { DataType data; Node *left; Node *right; }Node; typedef struct _tree { Node *root; int nodeCnt; }Tree; 그림3 처럼 노드의 구조체를 코드처럼 데이터방, 노드포인터 왼쪽,오른쪽 변수를 가지는 구조체를 선언하고, 트리관리 구조체를 하나 선언한다. 트리관리 구조체를 선언하는 이유는 노드의 삽입 및 삭제 시 노드의 갯수를 저장해주는 공간의 필요와 삭제 시에 루트노드가 바뀌는 경우가 있으므로 루트노드를 지정해주기 위해 선언한다.\n트리 초기화 void initTree(Tree *tr) { tr-\u003eroot = NULL; tr-\u003enodeCnt = 0; } 루트노드를 NULL 값으로 초기화하고, 노드의갯수를 0으로 초기화 한다.\n노드 생성 Node *makeNode(DataType *data, Node *left, Node *right) { Node *node = (Node*)calloc(1,sizeof(Node)); if (node != NULL) { node-\u003edata = *data; node-\u003eleft = left; node-\u003eright = right; } return node; } 전달인자로 왼쪽노드와 오른쪽노드의 주소를 받아 해당 데이터를 메모리할당한 공간에 삽입해주고 왼쪽과 오른쪽의 주소값을 연결해준다.\n이진 탐색 트리 [그림 4]의 트리구조를 보면 조건이 하나 있다. 부모노드를 기준으로 왼쪽자식은 부모노드의 값보다 더 작은 값, 오른쪽 자식은 부모노드의 값보다 더 큰 값을 가지고 있다. 그 아래 서브트리도 마찬가지로 왼쪽이 작은 값 오른쪽이 큰 값을 가지는 형태로 이루어져있다.\n예를 들어, [그림 4]의 “21” 데이터를 찾는다고 하면, 루트노드 10을 기준으로 하여 대/소 비교를 하며 트리 아래로 내려간다. 첫번째로 현재 노드가 찾을 값과 같은지 비교하고 같지 않으면 10과 21을 비교한다. 21이 더 크므로 오른쪽 자식으로 내려가고 그 다음 18과 비교하여 21이 더 크므로 오른쪽으로 간다. 이런 조건을 가지는 트리를 “이진 탐색 트리 (Binary Search Tree)” 라고 부른다.\n다음은 그 과정을 코드로 구현한 것이다.\n노드 탐색 Node *searchNode(Tree *tr, DataType *data, int(*compare)(DataType*, DataType*)) { Node *temp = tr-\u003eroot; while (temp != NULL) { if (*data == temp-\u003edata) { return temp; } if (compare(data, \u0026temp-\u003edata) \u003e 0) { temp = temp-\u003eright; } else { temp = temp-\u003eleft; } } return NULL; } 배열처럼 임의의 노드를 찾기위해 방 번호를 입력하는게 아닌 임시노드를 하나 선언하여 루트노드로 지정해준 뒤 모든 노드를 이진 트리 조건에 맞춰서 순회하여 값을 찾는 방식이다.\n노드 삽입 Node *addNode(Tree *tr, DataType *data, int(*compare)(DataType *, DataType*)) { Node *newNode; Node *parent = tr-\u003eroot; Node *son = tr-\u003eroot; newNode = makeNode(data, NULL, NULL); // 새로운노드 할당 if (newNode == NULL) // 메모리할당 실패시 리턴 return NULL; // 루트노드에 add할지 아닐지 검사 if (tr-\u003eroot != NULL) {// 루트노드 아닌경우 // parent,son포인터 이용하여 값 대입할 곳 위치찾기 while (son != NULL) { // son이 null이 될때까지 반복 if (compare(data,\u0026son-\u003edata)\u003e0) {// 대입할 값이 더 큰경우 -\u003e 오른쪽 parent = son; son = son-\u003eright; } else if(compare(data, \u0026son-\u003edata)\u003c0) { // 대입할 값이 더 작은경우 -\u003e 왼쪽 parent = son; son = son-\u003eleft; } } // 대소비교하여 노드삽입 if (compare(data, \u0026parent-\u003edata)\u003e0) {// 오른쪽으로 parent-\u003eright = newNode; } else if (compare(data, \u0026parent-\u003edata)\u003c0) { // 왼쪽으로 parent-\u003eleft = newNode; } tr-\u003enodeCnt++; // 노드카운트 ++ } else { // 루트노드인 경우 tr-\u003eroot = newNode; tr-\u003enodeCnt++; } return newNode; } 노드 삽입은 이진탐색트리 조건에 맞춰 노드를 삽입한다. 우선 변수로 \u003c 1) 삽입할 새로운 노드 2) 임시로 부모노드 역할 해줄 노드 3) 임시로 자식노드 역할 해줄 노드 \u003e 를 선언한다. 임시로 부모노드와 자식노드를 지정하는 이유는 이진탐색트리 조건에 맞춰서 대소비교를 하며 노드 아래로 내려가야 하기 때문에 노드의 주소가 바뀌지 않도록 임시변수를 지정해 주는 것이다. 부모노드, 자식노드 둘다 초기값으로 루트노드를 지정해준다.\n새로운노드 메모리를 할당해준뒤, 맨 첫번째로 할 것은 삽입할 곳이 루트노드인지 루트노드가 아닌지 검사하는것이다. 이 과정은 처음만 일어나는 경우지만 이 조건이 없다면 루트노드가 수시로 바뀌어 트리의 구조가 엉망이 될 것이다.\n다음으로, 부모와 자식 포인터노드를 이용하여 대입할 곳의 위치를 찾는 작업이다. 대/소 조건에 맞춰 부모노드와 자식노드를 같게 해준뒤 대입할 값보다 자식노드가 클 경우 자식노드는 자기사진의 왼쪽노드 …작을경우 오른쪽노드로 옮긴다. 이 과정을 반복하다보면 자식노드가 null이 되는데 이때 반복문이 종료되고 현재 임시부모노드의 위치는 삽입할 곳의 부모노드 위치가 된다.\n그 상태에서 마지막으로, 대소비교를하여 데이터가 부모노드 ( 현 임시부모노드위치 ) 보다 크면 오른쪽에 , 작으면 왼쪽에 삽입하는 식으로 부모노드의 오른쪽,왼쪽에 새로운노드 주소를 연결해줌으로 끝이난다.\n그리고 마지막으로 노드 카운트 (갯수) 를 증가시켜준다.\n노드 삭제 Node *deleteNode(Tree *tr, DataType *data, int(*compare)(DataType*, DataType*)) { Node *temp = tr-\u003eroot; // 삭제할 노드 임시 저장 포인터 Node *parent = tr-\u003eroot; Node *child; // 삭제할 노드 위치 검색 while ((temp!=NULL)\u0026\u0026 (temp-\u003edata != *data)) {// 찾을때까지 반복 parent = temp; if (compare(data, \u0026temp-\u003edata) \u003e 0) // 대입할 값이 더 큰경우 -\u003e 오른쪽 temp = temp-\u003eright; else if (compare(data, \u0026temp-\u003edata) \u003c 0) // 대입할 값이 더 작은경우 -\u003e 왼쪽 temp = temp-\u003eleft; } if (temp == NULL) { return temp; } // 유형 1 (삭제할 노드의 오른쪽 자식이 없는 경우) if (temp-\u003eright == NULL) { child = temp-\u003eleft; // 삭제할 노드의 왼쪽자식을 임시포인터 child에게 준다 if (compare(data, \u0026parent-\u003edata) \u003e 0) {// 삭제할 노드가 삭제할노드의부모보다 컸다면 parent-\u003eright = child; // 삭제할노드부모노드 오른쪽에 child 붙인다 } else { // 삭제할 노드가 삭제할노드의부모보다 작았다면 parent-\u003eleft = child; // 삭제할노드부모노드 왼쪽에 child 붙인다 } } // 유형 2 (삭제할 노드의 오른쪽 자식의 왼쪽자식이 없는 경우) else if (temp-\u003eright-\u003eleft == NULL) { child = temp-\u003eright; // 삭제할 노드의 오른쪽자식을 임시포인터 child에게 준다 if (compare(data, \u0026parent-\u003edata) \u003e 0) { // 삭제할 노드가 삭제할노드의부모보다 컸다면 parent-\u003eright = child; // 삭제할노드부모노드 오른쪽에 child 붙인다 child-\u003eleft = temp-\u003eleft; } else { // 삭제할 노드가 삭제할노드의부모보다 작았다면 parent-\u003eleft = child; // 삭제할노드부모노드 왼쪽에 child 붙인다 child-\u003eleft = temp-\u003eleft; } } // 유형 3 (그 외 모든 경우) else { Node *tempp; tempp = temp; child = temp-\u003eright; while (child-\u003eleft != NULL) { // child노드의 왼쪽이 없을때까지 탐색 tempp = child; child = child-\u003eleft; } tempp-\u003eleft = child-\u003eright; if (temp == tr-\u003eroot) {// 삭제하려는 노드가 루트노드랑 같은경우 tr-\u003eroot = child; tr-\u003eroot-\u003eright = temp-\u003eright; tr-\u003eroot-\u003eleft = temp-\u003eleft; } else {// 루트노드가 아닌경우 temp = child; // 삭제한 자리에 child값 주고 child-\u003eright = temp-\u003eright; // 노드 이어줌 child-\u003eleft = temp-\u003eleft; } } free(temp); return parent; } 노드를 삭제하는 과정은 꽤나 까다롭다. 링크드 리스트나 스택, 큐 자료구조와 달리 계층구조로 이루어져 있기 때문에 임의의 한 노드를 삭제한다고 하면 그 임의의노드의 부모노드, 자식노드, 경우에 따라 루트노드까지 바꿔주어야하기 때문에 고려할것이 많다. 그 수많은 케이스를 3분류로 나눌 수 있는데 그것은 아래와 같다.\nCase 1 : 삭제할 노드의 오른쪽 자식이 없는 경우 Case 2 : 삭제할 노드의 오른쪽 자식의 왼쪽 자식이 없는 경우 Case 3 : 그 외의 모든 경우 우선 삭제하기 전 노드삽입때와 마찬가지로 몇 가지 변수를 선언해주어야 한다. \u003c 1) 삭제할 노드의 부모노드 2) 삭제할 노드대신 자식역할을 할 노드 3) 삭제할 노드 \u003e 이다. 1)과 3)의 변수를 루트노드의 주소로 초기화 시켜준다. 처음으로 삭제 할 노드를 찾기 위해 반복문을 설정해준다. 과정은 노드탐색 함수와 비슷하게 대소비교를 하며 탐색한다. 탐색이 완료되면 3) 삭제할 노드 변수에는 삭제할 노드의 주소가 지정돼있을것이고 1) 부모노드 에는 삭제할 노드의 부모노드의 주소가 지정이 됐을것이다.\n다음은 Case를 분류한다. 유형 1의 경우 간단하므로 2) 자식노드 변수에 삭제할 노드의 왼쪽주소를 넣어준다.\n유형 2의 경우 삭제할 노드의 오른쪽 자식이 자식노드 역할을 한다. 자식노드에 삭제할 노드 (del)의 오른쪽 주소를 넣어주고 삭제할 노드의 왼쪽노드랑 연결해 주어야하므로 자식노드의 왼쪽에 삭제할 노드 (del)의 왼쪽주소를 넣어준다.\n유형 3의 경우는 1,2의 경우를 제외한 모든 경우를 뜻하는데, 이 케이스가 가장 많고 생각해내기가 좀 까다롭다. 간단히 말하면 삭제를 하고하 하는 노드가 자식을 모두 가지고 있는 경우이다. [그림4] 를 예시로 들어 설명하겠다.\n예를들어, 10값을 가진 노드를 삭제한다고 가정하자. 10노드를 삭제하게 되면 10의 자리에는 어떤 값이 들어가야 할까? 이진탐색트리의 조건에 맞춰서 6보다는 크고 18보다는 작아야 한다. 그 값은 두 가지로 구할수 있다. 하나는 삭제하고자 하는 노드의 왼쪽노드 부분에서 최대값을 찾는 것이고 하나는 삭제하고자 하는 노드의 오른쪽노드 부분에서 최솟값을 찾는것이다. 전자는 “8” 이 될 것이고 후자의 경우 “15” 가 될 것이다.\n여기서는 후자의 경우 ( 최소값찾기 ) 로 설명하겠다. 임시노드 temp를 하나 선언해준다. temp값에는 삭제할 노드 (del)의 오른쪽 주소로 초기화해준다. 그리고 오른쪽노드 부분에서 최소값을 찾기위해 반복문을 설정하는데 최소값은 왼쪽 노드로 계속 이동해야하므로 왼쪽노드가 null 이 될 때까지 반복문을 설정한다. 모두 끝나면 temp는 최솟값을 담고있는 노드의 부모노드 주소를 가지고 있게된다. 2) 자식노드 (son) 에도 temp의 왼쪽주소값을 지정해준다. ( 최소값 노드 ) 이제 “10\"의 위치에 2) 자식노드 (son)을 넣어주어야 하므로 son의 왼쪽에 “10\"의 왼쪽노드주소, son의 오른쪽에 “10\"의 오른쪽노드주소를 주며 인수인계 작업을 해준다.\n마지막으로 free함수를 이용하여 del 노드를 메모리 해제하며 끝낸다.\n노드 붕괴 void destroyTree(Tree *tr, void(*print)(DataType *)) { postorderDelete(tr-\u003eroot, print); tr-\u003enodeCnt = 0; tr-\u003eroot = NULL; } 이 함수는 트리의 모든 노드를 소멸시키는 함수로 후위순회를 해주며 각 노드마다 free() 메모리 해제를 해주며 순차적으로 없애나간다.\n노드 붕괴 (후위 순회식) void postorderDelete(Node *np, void(*print)(DataType *)) { if (np != NULL) { postorderTraverse(np-\u003eleft, print); postorderTraverse(np-\u003eright, print); print(\u0026np-\u003edata); free(np); // 노드 삭제 } printf(\"\\n\\n\"); } 노드붕괴함수에 연계되는 함수로 후위순회의 방식을 따르면서 추가로 free() 메모리해제를 해준다.\n노드 순회 “순회 (Traversal)” 란 이진트리의 모든 노드를 특정한 순서대로 한 번씩 방문하는 것이다. 순회방법으로는\n전위순회 (Pre Order) 중위순회 (In Order) 후위순회 (Post Order) 방식이 있다. 전위 순회 void preorderTraverse(Node *np, void(*print)(DataType *)) { if (np != NULL) { print(\u0026np-\u003edata); preorderTraverse(np-\u003eleft, print); preorderTraverse(np-\u003eright, print); } } 전위순회는 루트노드를 먼저 방문하고 왼쪽 서브트리, 오른쪽 서브트리 순으로 방문하는 방법이다. 왼쪽서브트리를 모두 방문하고 왼쪽방이 더 이상 없으면 그 이전 노드로 돌아가 오른쪽 노드를 탐색하고 왼쪽,,,또 오른쪽..이런 순으로 방문한다.\n중위 순회 void inorderTraverse(Node *np, void(*print)(DataType *)) { if (np == NULL) { return; } inorderTraverse(np-\u003eleft, print); print(\u0026np-\u003edata); inorderTraverse(np-\u003eright, print); } 중위순회는 먼저 왼쪽부터 방문한 뒤 루트노드를 탐색하고 오른쪽 서브트리를 방문한다.\n후위 순회 void postorderTraverse(Node *np, void(*print)(DataType *)) { if (np == NULL) { return; } postorderTraverse(np-\u003eleft, print); postorderTraverse(np-\u003eright, print); print(\u0026np-\u003edata); } 후위순회는 왼쪽 서브트리, 오른쪽 서브트리, 그리고 마지막에 루트노드를 방문한다.\n","wordCount":"1740","inLanguage":"en","datePublished":"2019-09-18T13:54:02+09:00","dateModified":"2019-09-18T13:54:02+09:00","author":{"@type":"Person","name":"ralpioxxcs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ralpioxxcs.github.io/post/cs/binary_tree/"},"publisher":{"@type":"Organization","name":"Devlog","logo":{"@type":"ImageObject","url":"https://ralpioxxcs.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ralpioxxcs.github.io/ accesskey=h title="Devlog (Alt + H)"><img src=https://ralpioxxcs.github.io/apple-touch-icon.png alt=logo aria-label=logo height=20>Devlog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ralpioxxcs.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ralpioxxcs.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ralpioxxcs.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ralpioxxcs.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ralpioxxcs.github.io/post/>Post</a></div><h1 class=post-title>C로 구현하는 자료구조 - Binary Tree</h1><div class=post-meta><span title='2019-09-18 13:54:02 +0900 KST'>September 18, 2019</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1740 words&nbsp;·&nbsp;ralpioxxcs&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/cs/binary_tree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><figure class=align-center><img loading=lazy src=/images/cs/bt_1.jpg#center width=400px></figure><br>&ldquo;트리 (Tree)&rdquo; 자료구조란 나무를 뒤집은 모습으로 계층구조를 표현하기에 적합한 자료구조이다. 맨 위의 노드가 &ldquo;루트노드 (Root Node)&rdquo; 라고 하며 이 노드 아래에 있는 노드들은 다시 트리 구조가 된다. 이런 구조를 &ldquo;서브 트리 (Sub Tree)&ldquo;라고 한다. 또한, 임의의 노드의 조상과 자손을 지칭 할 수 있는데, 임의의 노드 바로 위에 있는 노드를 &ldquo;부모 노드 (Parent Node)&rdquo; 라고 하고 그 바로 아래 노드들을 &ldquo;자식 노드 (Children Node)&ldquo;라 한다.<br><figure class=align-center><img loading=lazy src=/images/cs/bt_2.jpg#center width=400px></figure><br>이런 트리구조에서 파생된 자료구조를 <strong>이진트리 (Binary Tree)</strong> 라고 부르는데, 이진트리는 모든 노드들의 자식 노드가 두 개 이하인 트리를 의미한다. 이런 이진트리에서는 서브트리가 2개 이하기 때문에 서브트리는 왼쪽과 오른쪽으로 구분된다.<br>이진트리를 구현하는 방법으로 <strong>배열</strong>과 <strong>링크드리스트</strong> 2가지가 있다.</p><hr><h2 id=배열>배열<a hidden class=anchor aria-hidden=true href=#배열>#</a></h2><p>배열로 구현하게 될 경우, 연결리스트로 구현하는것보다 더 복잡하고 생각해야할것이 많다. 하지만 그렇다고해서 아예 안쓰이지는 않고, 힙 트리의 경우 배열로 구현하게 되는 경우가 많다. 배열로 구현하는 방법은 다음과 같다.<br>우선, 0번방은 비워놓고 루트노드를 1번방으로 시작하여 내려간다. 임의의 노드를 탐색하고 싶은 경우 해당 배열 방 번호를 입력하면 된다. [그림 2]처럼 데이터 4의 노드에서 오른쪽 자식노드(5)를 가고자 하면 => (2 x i ) + 1 을 해주면 데이터 5의 방 번호가 나온다.</p><p>정리하면,</p><ul><li>노드 i의 부모 노드 = i/2</li><li>노드 i의 왼쪽 자식 노드 = 2 x i</li><li>노드 i의 오른쪽 자식 노드 = ( 2 x i ) + 1</li><li>루트 노드 = 1</li></ul><p>배열로 구현하는 방법의 장점은 시간복잡도를 줄일수 있다는 점이 있지만, 편향 진트리의 경우 사용하지 않는 배열 원소에 대한 메모리 낭비가 발생하고, 삽입/삭제에 대한 배열의 크기 변경이 어렵다는 점이 있다.</p><h2 id=링크드리스트>링크드리스트<a hidden class=anchor aria-hidden=true href=#링크드리스트>#</a></h2><p><figure class=align-center><img loading=lazy src=/images/cs/bt_3.jpg#center width=400px></figure><br>링크드 리스트로 구현하는 방법은 배열로 구현하는것보다 더 쉽고 접근에 있어서 더 직관적이다. 하지만, 배열 구조에서만 가능한 임의 노드로의 접근이 불편(?)하다. 데이터가 커질수록 전위,후위 순회 하는 속도가 더 느려지므로 탐색시간에 있어서 링크드 리스트가 배열 구조보다 시간이 더 오래걸린다는 점이 있다.</p><h3 id=구조체-정의>구조체 정의<a hidden class=anchor aria-hidden=true href=#구조체-정의>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_node</span> <span class=n>Node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DataType</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>Node</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_tree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nodeCnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>Tree</span><span class=p>;</span>
</span></span></code></pre></div><p>그림3 처럼 노드의 구조체를 코드처럼 데이터방, 노드포인터 왼쪽,오른쪽 변수를 가지는 구조체를 선언하고, 트리관리 구조체를 하나 선언한다. 트리관리 구조체를 선언하는 이유는 노드의 삽입 및 삭제 시 노드의 갯수를 저장해주는 공간의 필요와 삭제 시에 루트노드가 바뀌는 경우가 있으므로 루트노드를 지정해주기 위해 선언한다.</p><h3 id=트리-초기화>트리 초기화<a hidden class=anchor aria-hidden=true href=#트리-초기화>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>initTree</span><span class=p>(</span><span class=n>Tree</span> <span class=o>*</span><span class=n>tr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tr</span><span class=o>-&gt;</span><span class=n>nodeCnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>루트노드를 NULL 값으로 초기화하고, 노드의갯수를 0으로 초기화 한다.</p><h3 id=노드-생성>노드 생성<a hidden class=anchor aria-hidden=true href=#노드-생성>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=nf>makeNode</span><span class=p>(</span><span class=n>DataType</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>node</span> <span class=o>=</span> <span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>)</span><span class=n>calloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>전달인자로 왼쪽노드와 오른쪽노드의 주소를 받아
해당 데이터를 메모리할당한 공간에 삽입해주고 왼쪽과 오른쪽의 주소값을 연결해준다.</p><hr><h2 id=이진-탐색-트리>이진 탐색 트리<a hidden class=anchor aria-hidden=true href=#이진-탐색-트리>#</a></h2><p><figure class=align-center><img loading=lazy src=/images/cs/bt_4.jpg#center width=400px></figure><br>[그림 4]의 트리구조를 보면 조건이 하나 있다. 부모노드를 기준으로 왼쪽자식은 부모노드의 값보다 더 작은 값, 오른쪽 자식은 부모노드의 값보다 더 큰 값을 가지고 있다. 그 아래 서브트리도 마찬가지로 왼쪽이 작은 값 오른쪽이 큰 값을 가지는 형태로 이루어져있다.</p><p>예를 들어, [그림 4]의 &ldquo;21&rdquo; 데이터를 찾는다고 하면, 루트노드 10을 기준으로 하여 대/소 비교를 하며 트리 아래로 내려간다. 첫번째로 현재 노드가 찾을 값과 같은지 비교하고 같지 않으면 10과 21을 비교한다. 21이 더 크므로 오른쪽 자식으로 내려가고 그 다음 18과 비교하여 21이 더 크므로 오른쪽으로 간다. 이런 조건을 가지는 트리를 &ldquo;이진 탐색 트리 (Binary Search Tree)&rdquo; 라고 부른다.</p><p>다음은 그 과정을 코드로 구현한 것이다.</p><h3 id=노드-탐색>노드 탐색<a hidden class=anchor aria-hidden=true href=#노드-탐색>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=nf>searchNode</span><span class=p>(</span><span class=n>Tree</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=n>DataType</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>compare</span><span class=p>)(</span><span class=n>DataType</span><span class=o>*</span><span class=p>,</span> <span class=n>DataType</span><span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>temp</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>temp</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>data</span> <span class=o>==</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>배열처럼 임의의 노드를 찾기위해 방 번호를 입력하는게 아닌 임시노드를 하나 선언하여 루트노드로 지정해준 뒤 모든 노드를 이진 트리 조건에 맞춰서 순회하여 값을 찾는 방식이다.</p><h3 id=노드-삽입>노드 삽입<a hidden class=anchor aria-hidden=true href=#노드-삽입>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=nf>addNode</span><span class=p>(</span><span class=n>Tree</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=n>DataType</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>compare</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>,</span> <span class=n>DataType</span><span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>parent</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>son</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>newNode</span> <span class=o>=</span> <span class=n>makeNode</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 새로운노드 할당
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>newNode</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>// 메모리할당 실패시 리턴
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 루트노드에 add할지 아닐지 검사
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 루트노드 아닌경우
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// parent,son포인터 이용하여 값 대입할 곳 위치찾기
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>son</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// son이 null이 될때까지 반복
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span><span class=o>&amp;</span><span class=n>son</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 대입할 값이 더 큰경우 -&gt; 오른쪽
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>parent</span> <span class=o>=</span> <span class=n>son</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>son</span> <span class=o>=</span> <span class=n>son</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>                                 
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>son</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 대입할 값이 더 작은경우 -&gt; 왼쪽
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>parent</span> <span class=o>=</span> <span class=n>son</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>son</span> <span class=o>=</span> <span class=n>son</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=c1>// 대소비교하여 노드삽입
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 오른쪽으로
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 왼쪽으로
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>nodeCnt</span><span class=o>++</span><span class=p>;</span> <span class=c1>// 노드카운트 ++
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=c1>// 루트노드인 경우
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>nodeCnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>노드 삽입은 이진탐색트리 조건에 맞춰 노드를 삽입한다.
우선 변수로 &lt; 1) 삽입할 새로운 노드 2) 임시로 부모노드 역할 해줄 노드 3) 임시로 자식노드 역할 해줄 노드 > 를 선언한다. 임시로 부모노드와 자식노드를 지정하는 이유는 이진탐색트리 조건에 맞춰서 대소비교를 하며 노드 아래로 내려가야 하기 때문에 노드의 주소가 바뀌지 않도록 임시변수를 지정해 주는 것이다.
부모노드, 자식노드 둘다 초기값으로 루트노드를 지정해준다.</p><p>새로운노드 메모리를 할당해준뒤, 맨 첫번째로 할 것은 삽입할 곳이 루트노드인지 루트노드가 아닌지 검사하는것이다. 이 과정은 처음만 일어나는 경우지만 이 조건이 없다면 루트노드가 수시로 바뀌어 트리의 구조가 엉망이 될 것이다.</p><p>다음으로, 부모와 자식 포인터노드를 이용하여 대입할 곳의 위치를 찾는 작업이다. 대/소 조건에 맞춰 부모노드와 자식노드를 같게 해준뒤 대입할 값보다 자식노드가 클 경우 자식노드는 자기사진의 왼쪽노드 &mldr;작을경우 오른쪽노드로 옮긴다.
이 과정을 반복하다보면 자식노드가 null이 되는데 이때 반복문이 종료되고 현재 임시부모노드의 위치는 삽입할 곳의 부모노드 위치가 된다.</p><p>그 상태에서 마지막으로, 대소비교를하여 데이터가 부모노드 ( 현 임시부모노드위치 ) 보다 크면 오른쪽에 , 작으면 왼쪽에 삽입하는 식으로 부모노드의 오른쪽,왼쪽에 새로운노드 주소를 연결해줌으로 끝이난다.</p><p>그리고 마지막으로 노드 카운트 (갯수) 를 증가시켜준다.</p><h3 id=노드-삭제>노드 삭제<a hidden class=anchor aria-hidden=true href=#노드-삭제>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Node</span> <span class=o>*</span><span class=nf>deleteNode</span><span class=p>(</span><span class=n>Tree</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=n>DataType</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>compare</span><span class=p>)(</span><span class=n>DataType</span><span class=o>*</span><span class=p>,</span> <span class=n>DataType</span><span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>temp</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>;</span> <span class=c1>// 삭제할 노드 임시 저장 포인터
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span><span class=n>parent</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 삭제할 노드 위치 검색
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>((</span><span class=n>temp</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>)</span><span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>!=</span> <span class=o>*</span><span class=n>data</span><span class=p>))</span> <span class=p>{</span><span class=c1>// 찾을때까지 반복
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>parent</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 대입할 값이 더 큰경우 -&gt; 오른쪽
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// 대입할 값이 더 작은경우 -&gt; 왼쪽
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>temp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 유형 1  (삭제할 노드의 오른쪽 자식이 없는 경우)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span> <span class=c1>// 삭제할 노드의 왼쪽자식을 임시포인터 child에게 준다
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 삭제할 노드가 삭제할노드의부모보다 컸다면
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span> <span class=c1>// 삭제할노드부모노드 오른쪽에 child 붙인다
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>       <span class=c1>// 삭제할 노드가 삭제할노드의부모보다 작았다면                         
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>  <span class=c1>// 삭제할노드부모노드 왼쪽에 child 붙인다
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 유형 2 (삭제할 노드의 오른쪽 자식의 왼쪽자식이 없는 경우)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span> <span class=c1>// 삭제할 노드의 오른쪽자식을 임시포인터 child에게 준다
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>compare</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 삭제할 노드가 삭제할노드의부모보다 컸다면
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span> <span class=c1>// 삭제할노드부모노드 오른쪽에 child 붙인다
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>child</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>       <span class=c1>// 삭제할 노드가 삭제할노드의부모보다 작았다면                         
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>  <span class=c1>// 삭제할노드부모노드 왼쪽에 child 붙인다
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>child</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 유형 3  (그 외 모든 경우)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=o>*</span><span class=n>tempp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tempp</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>child</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// child노드의 왼쪽이 없을때까지 탐색
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tempp</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span> <span class=o>=</span> <span class=n>child</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>tempp</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>child</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>temp</span> <span class=o>==</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>)</span> <span class=p>{</span><span class=c1>// 삭제하려는 노드가 루트노드랑 같은경우
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span><span class=c1>// 루트노드가 아닌경우
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>temp</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span> <span class=c1>// 삭제한 자리에 child값 주고
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>child</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span> <span class=c1>// 노드 이어줌
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>child</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>노드를 삭제하는 과정은 꽤나 까다롭다. 링크드 리스트나 스택, 큐 자료구조와 달리 계층구조로 이루어져 있기 때문에 임의의 한 노드를 삭제한다고 하면 그 임의의노드의 부모노드, 자식노드, 경우에 따라 루트노드까지 바꿔주어야하기 때문에 고려할것이 많다.
그 수많은 케이스를 3분류로 나눌 수 있는데 그것은 아래와 같다.</p><ul><li>Case 1 : 삭제할 노드의 오른쪽 자식이 없는 경우</li><li>Case 2 : 삭제할 노드의 오른쪽 자식의 왼쪽 자식이 없는 경우</li><li>Case 3 : 그 외의 모든 경우</li></ul><p>우선 삭제하기 전 노드삽입때와 마찬가지로 몇 가지 변수를 선언해주어야 한다.
&lt; 1) 삭제할 노드의 부모노드 2) 삭제할 노드대신 자식역할을 할 노드 3) 삭제할 노드 > 이다. 1)과 3)의 변수를 루트노드의 주소로 초기화 시켜준다.
처음으로 삭제 할 노드를 찾기 위해 반복문을 설정해준다. 과정은 노드탐색 함수와 비슷하게 대소비교를 하며 탐색한다. 탐색이 완료되면 3) 삭제할 노드 변수에는 삭제할 노드의 주소가 지정돼있을것이고 1) 부모노드 에는 삭제할 노드의 부모노드의 주소가 지정이 됐을것이다.</p><p>다음은 Case를 분류한다.
유형 1의 경우 간단하므로 2) 자식노드 변수에 삭제할 노드의 왼쪽주소를 넣어준다.</p><p>유형 2의 경우 삭제할 노드의 오른쪽 자식이 자식노드 역할을 한다. 자식노드에 삭제할 노드 (del)의 오른쪽 주소를 넣어주고 삭제할 노드의 왼쪽노드랑 연결해 주어야하므로 자식노드의 왼쪽에 삭제할 노드 (del)의 왼쪽주소를 넣어준다.</p><p>유형 3의 경우는 1,2의 경우를 제외한 모든 경우를 뜻하는데, 이 케이스가 가장 많고 생각해내기가 좀 까다롭다. 간단히 말하면 삭제를 하고하 하는 노드가 자식을 모두 가지고 있는 경우이다.
[그림4] 를 예시로 들어 설명하겠다.</p><p><figure class=align-center><img loading=lazy src=/images/cs/bt_5.jpg#center width=400px></figure><br>예를들어, 10값을 가진 노드를 삭제한다고 가정하자. 10노드를 삭제하게 되면 10의 자리에는 어떤 값이 들어가야 할까? 이진탐색트리의 조건에 맞춰서 6보다는 크고 18보다는 작아야 한다. 그 값은 두 가지로 구할수 있다. 하나는 삭제하고자 하는 노드의 왼쪽노드 부분에서 최대값을 찾는 것이고 하나는 삭제하고자 하는 노드의 오른쪽노드 부분에서 최솟값을 찾는것이다. 전자는 &ldquo;8&rdquo; 이 될 것이고 후자의 경우 &ldquo;15&rdquo; 가 될 것이다.</p><p>여기서는 후자의 경우 ( 최소값찾기 ) 로 설명하겠다.
임시노드 temp를 하나 선언해준다. temp값에는 삭제할 노드 (del)의 오른쪽 주소로 초기화해준다. 그리고 오른쪽노드 부분에서 최소값을 찾기위해 반복문을 설정하는데 최소값은 왼쪽 노드로 계속 이동해야하므로 왼쪽노드가 null 이 될 때까지 반복문을 설정한다. 모두 끝나면 temp는 최솟값을 담고있는 노드의 부모노드 주소를 가지고 있게된다. 2) 자식노드 (son) 에도 temp의 왼쪽주소값을 지정해준다. ( 최소값 노드 )
이제 &ldquo;10"의 위치에 2) 자식노드 (son)을 넣어주어야 하므로 son의 왼쪽에 &ldquo;10"의 왼쪽노드주소, son의 오른쪽에 &ldquo;10"의 오른쪽노드주소를 주며 인수인계 작업을 해준다.</p><p>마지막으로 free함수를 이용하여 del 노드를 메모리 해제하며 끝낸다.</p><h3 id=노드-붕괴>노드 붕괴<a hidden class=anchor aria-hidden=true href=#노드-붕괴>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>destroyTree</span><span class=p>(</span><span class=n>Tree</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>print</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>postorderDelete</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>tr</span><span class=o>-&gt;</span><span class=n>nodeCnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tr</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>이 함수는 트리의 모든 노드를 소멸시키는 함수로 후위순회를 해주며 각 노드마다 free() 메모리 해제를 해주며 순차적으로 없애나간다.</p><h3 id=노드-붕괴-후위-순회식>노드 붕괴 (후위 순회식)<a hidden class=anchor aria-hidden=true href=#노드-붕괴-후위-순회식>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>postorderDelete</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>np</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>print</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>np</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>postorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>postorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>np</span><span class=p>);</span>  <span class=c1>// 노드 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>노드붕괴함수에 연계되는 함수로 후위순회의 방식을 따르면서 추가로 free() 메모리해제를 해준다.</p><hr><h2 id=노드-순회>노드 순회<a hidden class=anchor aria-hidden=true href=#노드-순회>#</a></h2><p><figure class=align-center><img loading=lazy src=/images/cs/bt_6.jpg#center width=400px></figure><br>&ldquo;순회 (Traversal)&rdquo; 란 이진트리의 모든 노드를 특정한 순서대로 한 번씩 방문하는 것이다. 순회방법으로는</p><ul><li>전위순회 (Pre Order)</li><li>중위순회 (In Order)</li><li>후위순회 (Post Order)
방식이 있다.</li></ul><h3 id=전위-순회>전위 순회<a hidden class=anchor aria-hidden=true href=#전위-순회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>preorderTraverse</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>np</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>print</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>np</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>preorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>preorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>전위순회는 루트노드를 먼저 방문하고 왼쪽 서브트리, 오른쪽 서브트리 순으로 방문하는 방법이다. 왼쪽서브트리를 모두 방문하고 왼쪽방이 더 이상 없으면 그 이전 노드로 돌아가 오른쪽 노드를 탐색하고 왼쪽,,,또 오른쪽..이런 순으로 방문한다.</p><h3 id=중위-순회>중위 순회<a hidden class=anchor aria-hidden=true href=#중위-순회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>inorderTraverse</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>np</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>print</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>np</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>inorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>inorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>중위순회는 먼저 왼쪽부터 방문한 뒤 루트노드를 탐색하고 오른쪽 서브트리를 방문한다.</p><h3 id=후위-순회>후위 순회<a hidden class=anchor aria-hidden=true href=#후위-순회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>postorderTraverse</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>np</span><span class=p>,</span> <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>print</span><span class=p>)(</span><span class=n>DataType</span> <span class=o>*</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>np</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>postorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>postorderTraverse</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>print</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>후위순회는 왼쪽 서브트리, 오른쪽 서브트리, 그리고 마지막에 루트노드를 방문한다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ralpioxxcs.github.io/tags/cs/>cs</a></li><li><a href=https://ralpioxxcs.github.io/tags/data-structure/>data structure</a></li></ul><nav class=paginav><a class=prev href=https://ralpioxxcs.github.io/post/cs/queue/><span class=title>« Prev</span><br><span>C로 구현하는 자료구조 - Queue</span></a>
<a class=next href=https://ralpioxxcs.github.io/post/cs/graph_matrix/><span class=title>Next »</span><br><span>C로 구현하는 자료구조 - Graph</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on twitter" href="https://twitter.com/intent/tweet/?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f&hashtags=cs%2cdatastructure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f&title=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree&summary=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree&source=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f&title=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on whatsapp" href="https://api.whatsapp.com/send?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree%20-%20https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C로 구현하는 자료구조 - Binary Tree on telegram" href="https://telegram.me/share/url?text=C%eb%a1%9c%20%ea%b5%ac%ed%98%84%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20-%20Binary%20Tree&url=https%3a%2f%2fralpioxxcs.github.io%2fpost%2fcs%2fbinary_tree%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ralpioxxcs.github.io/>Devlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=/js/prism.js></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>