<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Graph (matrix) | Devlog</title>
<meta name=keywords content="Data Structure">
<meta name=description content="그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.">
<meta name=author content="ralpioxxcs">
<link rel=canonical href=https://ralpioxxcs.github.io/cs/graph_matrix/>
<link crossorigin=anonymous href=/assets/css/stylesheet.0d41883a16bc74b0e0b783e6e4a639ca1ddb8af4148ffe844f94a45cfbe71934.css integrity="sha256-DUGIOha8dLDgt4Pm5KY5yh3bivQUj/6ET5SkXPvnGTQ=" rel="preload stylesheet" as=style>
<link rel=icon href=https://ralpioxxcs.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://ralpioxxcs.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://ralpioxxcs.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://ralpioxxcs.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://ralpioxxcs.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<link rel=stylesheet href=/prism-themes/prism.css>
<link rel=stylesheet href=/prism-themes/prism-nord.css>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-189380926-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="Graph (matrix)">
<meta property="og:description" content="그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ralpioxxcs.github.io/cs/graph_matrix/"><meta property="article:section" content="cs">
<meta property="article:published_time" content="2020-10-04T15:04:49+09:00">
<meta property="article:modified_time" content="2020-10-04T15:04:49+09:00"><meta property="og:site_name" content="Devlog">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Graph (matrix)">
<meta name=twitter:description content="그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cs","item":"https://ralpioxxcs.github.io/cs/"},{"@type":"ListItem","position":2,"name":"Graph (matrix)","item":"https://ralpioxxcs.github.io/cs/graph_matrix/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Graph (matrix)","name":"Graph (matrix)","description":"그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.","keywords":["Data Structure"],"articleBody":"Graph   그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.\n(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)\nImplementaion Define extern int check[]; /*---------------------------------------------- GraphMatrix 처리 구조체 및 활용 함수 -----------------------------------------------*/ typedef struct { int graph[MAX_VERTEX][MAX_VERTEX]; /* 인접 행렬법 표기 배열 - 2차원 배열 */ int vertexCnt; /* 정점 개수 */ int edgeCnt; /* 간선 개수 */ }GraphMatrix; void initGraph(GraphMatrix *gm, char *fileName); /*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */ void outputGraph(GraphMatrix *gm); /* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */ void DFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */ void DFS_recursive(GraphMatrix *gm, int vNum); /* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */ void visit(int vNum); /* 방문한 정점의 처리 */ void nrDFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */ void BFS_Matrix(GraphMatrix *gm); /* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */ int countGraphComponents(GraphMatrix *gm); /* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */ extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다. ( 0번방 - A , 1번방 - B… 이런 식) 구조체에는 인접행렬을 표기할 배열 graph 2차원 배열, 정점의 갯수와 간선의 갯수를 저장해줄 int형 변수들을 선언해준다.\nInit graph void initGraph(GraphMatrix *gm, char *fileName) { FILE *pFile = fopen(fileName, \"r\"); char str[3]; if (pFile == NULL) printf(\"불러오기 실패\\n\"); else { fscanf(pFile, \"%d\", \u0026gm-vertexcnt); // 정점갯수 가져옴  fscanf(pFile, \"%d\", \u0026gm-edgeCnt); // 간선갯수 가져옴  for (int i = 0; i  gm-vertexcnt; i++) // 배열 방 '0' 으로 초기화  for (int j = 0; j  gm-vertexcnt; j++) gm-graph[i][j] = 0; for (int k = 0; k  gm-edgeCnt; k++) { fscanf(pFile, \"%s\", str); str[0] = str[0] - 65; str[1] = str[1] - 65; // ex) str[3] = { 0 , 1 }  gm-graph[str[0]][str[1]] = 1; gm-graph[str[1]][str[0]] = 1; } } } 이 글에서는 행렬 텍스트 파일을 파일입출력을 통해 불러와 반복문을 통해 배열에 입력하는 방식으로 구현했다. FILE 함수를 통해 파일을 읽어들인 후, 간선, 정점의 갯수를 모두 읽는다.\n우선, 인접행렬영역을 0 (방문X)로 초기화를 해주고, 무방향 그래프에서의 대칭성을 고려하여 간선의 갯수만큼 반복문을 이용해 행렬에 입력한다.\nPrint graph void outputGraph(GraphMatrix *gm) { printf(\" \"); for (int k = 0; k  gm-vertexcnt; k++) printf(\" [%c]\", 65 + k); NEWL; for (int i = 0; i  gm-vertexcnt; i++) { printf(\"[%c]\", 65 + i); for (int j = 0; j  gm-vertexcnt; j++) printf(\"%5d\", gm-graph[i][j]); NEWL; } }    DFS   그래프내의 각 정점들을 간선을 타고 중복없이 한 번씩 방문하는 방법으로 깊이 우선 탐색 ( Depth First Search ) 법과 너비 우선 탐색 ( Breadth First Search)법이 있다. 무방향 그래프는 특성상 방향이 없기때문에 순회 순서가 유일하지 않다는 특징이 있다. 2가지 중 하나인 “깊이 우선 탐색(DFS)” 는 탐색을 시작할 정점에 연결된 정점 중 하나를 선택하여 들어가고 그 하나와 연결된 정점들 중 또 하나를 선택해서 들어가고 깊이 들어가는 방식으로 탐색하는 기법이다. DFS의 과정은 스택을 사용하므로 재귀와 비재귀로 구현 할 수 있다\nRecursive dfs void DFS_recursive(GraphMatrix *gm, int vNum) { int i; check[vNum] = 1; /* 방문한 정점 표시를 위해 1 저장 */ visit(vNum); /* 방문에 따른 처리 */ for(i=0; igm-vertexCnt; ++i) { if(gm-graph[vNum][i] != 0) /* 연결된 정점이 있으면 */ if(check[i] == 0) /* 또한 방문한 적이 없는 정점이면 */ DFS_recursive(gm, i); /* 재귀 호출을 통해 정점 방문을 한다 */ } } 전달인자로 받은 정점번호를 방문처리 해준 뒤, ( 1로 바꿈 ) 그 정점을 visit함수 ( 출력 ) 한다. 다음으로, 정점갯수만큼 반복문을 설정.. 해당 정점에 연결된 정점이 있고 그 정점이 방문배열에서 방문한 적이 없는 정점 이라면 재귀호출을 통해 정점 방문 처리를 해준다.\nNon-Recursive dfs void nrDFS_Matrix(GraphMatrix *gm) { int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; igm-vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; igm-vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { push(\u0026stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026stack) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { pop(\u0026stack, \u0026popData); visit(popData); /* 정점 방문 */ for(j=0; jgm-vertexCnt; ++j) if(gm-graph[popData][j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { push(\u0026stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyStack(\u0026stack); return; } 재귀기법을 사용하지 않으면 스택자료구조를 이용해야한다. 스택 초기화 및 생성을 하고 재귀방법과 똑같이 체크배열은 0으로 시켜준다. 순차적으로 정점을 방문한다. 그 정점이 방문한경우가 아니라면 스택에 그 정점을 푸쉬하고 방문상태를 바꿔준다 ( 1로 ) 그리고 스택이 모두 비면 한 연결 요소에 대해 순회가 끝난것을 의미하므로 스택이 빌 때까지 반복문을 걸어준다. pop을 하여 정점을 꺼내고 해당 정점에 연결된 정점이 있고 방문처리 되지 않은 경우 그 인접정점을 스택에 넣고 방문처리를 해준다. 이런 과정을 모두 하고나면 모든 정점에 대해 순회가 완료된다.\nBFS   너비우선탐색 (BFS) 는 시작한 정점과 연결된 모든 정점을 탐색하고 다시 시작 정점의 다른 연결된 정점을 찾는 순으로, 깊이 들어가기전에 옆으로 넓게 퍼지며 탐색하는 기법이다. DFS와 달리 너비우선탐색 (BFS) 는 스택을 사용하지않고 큐 자료구조를 이용해야 한다. 따라서 재귀호출기법으로는 구현할 수 없다.\nvoid BFS_Matrix(GraphMatrix *gm) { int i, j; int getData; /* dequeue(get)한 데이터 저장 */ Queue queue; initQueue(\u0026queue, MAX_VERTEX); /* 큐 초기화 */ for(i=0; igm-vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; igm-vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { enqueue(\u0026queue, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isQueueEmpty(\u0026queue) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { dequeue(\u0026queue, \u0026getData); visit(getData); /* 정점 방문 */ for(j=0; jgm-vertexCnt; ++j) if(gm-graph[getData]j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { enqueue(\u0026queue, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyQueue(\u0026queue); return; } 과정은 DFS랑 매우 비슷하다. 자료구조만 스택에서 큐로 바꾸면 바로 너비우선탐색법이 된다.\n큐를 선언 및 초기화 후 체크배열을 초기화한다. 그리고 시작 정점을 기준으로 하여 큐에 넣고 큐가 빌때까지 반복문, 인접정점, 방문 유무를 판단한다. [그림 3] 을 예로들어서 설명하면 “1\"을 시작으로 Enqueue한뒤, “1\"의 인접정점 8 , 5, 2 를 순서대로 모두 Enqueue한다. 그리고 Dequeue를 하면 큐 특성상 첫번째로 넣은 값이 나오게 되므로 8을 방문처리하고 8의 인접정점 6 ,4 ,3 을 모두 Enqueue 그 다음 5를 Dequeue… 5는 인접정점이 없으므로 다음 Dequeue 2를 방문…이런 식으로 옆으로 넓게 퍼지며 탐색을 한다.\nprint graph int countGraphComponents(GraphMatrix *gm) { int componetsCount=0; /* 그래프 내의 연결 요소 카운트 변수 */ int i, j; int popData; /* pop한 데이터 저장 */ Stack stack; initStack(\u0026stack); /* 비재귀 처리를 위해 사용될 스택 초기화 */ for(i=0; igm-vertexCnt; ++i) /* 정점의 방문상태 정보를 저장할 check배열 초기화 */ check[i] = 0; for(i=0; igm-vertexCnt; ++i) /* 순차적으로 정점을 방문함 */ { if(check[i] == 0) /* 방문하지 않은 정점을 발견 하면 */ { ++componetsCount; /* 방문하지 않은 정점을 발견되면 연결 요소 카운트를 증가 시킴 */ printf(\"\\n연결 요소 %d : \", componetsCount); push(\u0026stack, i); check[i] = 1; /* 방문상태를 1로 변경 */ while( !isStackEmpty(\u0026stack) ) /* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */ { pop(\u0026stack, \u0026popData); visit(popData); /* 정점 방문 */ for(j=0; jgm-vertexCnt; ++j) if(gm-graph[popData][j] != 0) /* (!!)pop한 정점과 연결된 j정점이 있고 */ if(check[j] == 0) /* j정점이 스택에 들어있지 않으면 */ { push(\u0026stack, j); /* j정점을 스택에 저장하고 */ check[j] = 1; /* 방문상태를 1로 변경 */ } } } } destroyStack(\u0026stack); return componetsCount; } print graph ","wordCount":"1283","inLanguage":"en","datePublished":"2020-10-04T15:04:49+09:00","dateModified":"2020-10-04T15:04:49+09:00","author":{"@type":"Person","name":"ralpioxxcs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ralpioxxcs.github.io/cs/graph_matrix/"},"publisher":{"@type":"Organization","name":"Devlog","logo":{"@type":"ImageObject","url":"https://ralpioxxcs.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://ralpioxxcs.github.io/ accesskey=h title="Devlog (Alt + H)">
<img src=https://ralpioxxcs.github.io/apple-touch-icon.png alt=logo aria-label=logo height=20>Devlog</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://ralpioxxcs.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://ralpioxxcs.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://ralpioxxcs.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://ralpioxxcs.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ralpioxxcs.github.io/cs/>Cs</a></div>
<h1 class=post-title>
Graph (matrix)
</h1>
<div class=post-description>
그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다. 인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.
</div>
<div class=post-meta><span title="2020-10-04 15:04:49 +0900 KST">October 4, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1283 words&nbsp;·&nbsp;ralpioxxcs&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/cs/graph_matrix.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><h1 id=graph>Graph<a hidden class=anchor aria-hidden=true href=#graph>#</a></h1>
<figure>
<img loading=lazy src=/images/cs/graph_1.jpeg>
</figure>
<p>그래프 자료구조를 나타내는 방법으로 두 가지가 있다. 하나는 인접 행렬 (adjacent Matrix) 이고 하나는 인접 리스트 (adjacent List)법이있다. 이번 글에서는 인접행렬로 그래프를 나타내는 방법을 알아보겠다.
인접행렬법은 배열로 그래프를 나타내는 것이므로 밀집그래프 (완전그래프)를 표현하는데 적절하다. 2차원 배열 특성상 한번에 메모리를 잡아햐 하기때문에 빈 공간이 생기면 메모리 낭비가 생기므로 밀집그래프를 표현하는데 있어 좋은 방법이다.</p>
<p>(※무방향 그래프를 표현 시 대칭성을 고려해야 한다.)</p>
<h1 id=implementaion>Implementaion<a hidden class=anchor aria-hidden=true href=#implementaion>#</a></h1>
<h2 id=define>Define<a hidden class=anchor aria-hidden=true href=#define>#</a></h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>extern</span> <span class=kt>int</span> <span class=n>check</span><span class=p>[];</span>
<span class=cm>/*----------------------------------------------
</span><span class=cm>       GraphMatrix 처리 구조체 및 활용 함수
</span><span class=cm>-----------------------------------------------*/</span>
<span class=k>typedef</span> <span class=k>struct</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>graph</span><span class=p>[</span><span class=n>MAX_VERTEX</span><span class=p>][</span><span class=n>MAX_VERTEX</span><span class=p>];</span> <span class=cm>/* 인접 행렬법 표기 배열 - 2차원 배열 */</span>
    <span class=kt>int</span> <span class=n>vertexCnt</span><span class=p>;</span>    <span class=cm>/* 정점 개수 */</span>
    <span class=kt>int</span> <span class=n>edgeCnt</span><span class=p>;</span>      <span class=cm>/* 간선 개수 */</span>
<span class=p>}</span><span class=n>GraphMatrix</span><span class=p>;</span>
 
<span class=kt>void</span> <span class=nf>initGraph</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fileName</span><span class=p>);</span> <span class=cm>/*데이터파일에서 그래프의 정점과 간선 정보를 입력 받아 그래프를 초기화하는 함수 */</span>
<span class=kt>void</span> <span class=nf>outputGraph</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>);</span> <span class=cm>/* 그래프내의 정점과 간선의 관계를 인접 행렬 형태로 출력 함 */</span>
<span class=kt>void</span> <span class=nf>DFS_Matrix</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>);</span> <span class=cm>/* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(재귀판) - DFS_recursive()함수를 호출하여 처리(이 함수 자체는 재귀하지 않음) */</span>
<span class=kt>void</span> <span class=nf>DFS_recursive</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vNum</span><span class=p>);</span> <span class=cm>/* 연결되어있는 하나의 그래트내의 모든 정점을 재귀호출기법으로 방문하는 함수 */</span>
<span class=kt>void</span> <span class=nf>visit</span><span class=p>(</span><span class=kt>int</span> <span class=n>vNum</span><span class=p>);</span>   <span class=cm>/* 방문한 정점의 처리 */</span>
<span class=kt>void</span> <span class=nf>nrDFS_Matrix</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>);</span> <span class=cm>/* 여러 개의 연결 요소로 구성된 그래프를 깊이 우선 탐색하기 위한 함수(비 재귀판) */</span>
<span class=kt>void</span> <span class=nf>BFS_Matrix</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>);</span> <span class=cm>/* 여러 개의 연결 요소로 구성된 그래프를 너비 우선 탐색하기 위한 함수(비 재귀판) */</span>
<span class=kt>int</span> <span class=nf>countGraphComponents</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>);</span> <span class=cm>/* 인접 행렬법으로 표기되 그래프 내의 연결 요소별로 정점들을 출력하고 연결 요소의 개수를 리턴하는 함수 */</span>
</code></pre></div><p>extern 전역 변수로 방문처리를 확인 할 1차원 배열을 하나 선언해준다. ( 0번방 -> A , 1번방 -> B&mldr; 이런 식)
구조체에는 인접행렬을 표기할 배열 graph 2차원 배열, 정점의 갯수와 간선의 갯수를 저장해줄 int형 변수들을 선언해준다.</p>
<h2 id=init-graph>Init graph<a hidden class=anchor aria-hidden=true href=#init-graph>#</a></h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>initGraph</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fileName</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>FILE</span> <span class=o>*</span><span class=n>pFile</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=n>fileName</span><span class=p>,</span> <span class=s>&#34;r&#34;</span><span class=p>);</span>
    <span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
 
    <span class=k>if</span> <span class=p>(</span><span class=n>pFile</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;불러오기 실패</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=k>else</span>
    <span class=p>{</span>
        <span class=n>fscanf</span><span class=p>(</span><span class=n>pFile</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>);</span>     <span class=c1>// 정점갯수 가져옴
</span><span class=c1></span>        <span class=n>fscanf</span><span class=p>(</span><span class=n>pFile</span><span class=p>,</span> <span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>edgeCnt</span><span class=p>);</span>       <span class=c1>// 간선갯수 가져옴
</span><span class=c1></span> 
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>// 배열 방 &#39;0&#39; 으로 초기화
</span><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
                <span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>edgeCnt</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>fscanf</span><span class=p>(</span><span class=n>pFile</span><span class=p>,</span> <span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
            <span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=mi>65</span><span class=p>;</span> <span class=n>str</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>str</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=mi>65</span><span class=p>;</span> <span class=c1>// ex) str[3] = { 0 , 1 }
</span><span class=c1></span>            <span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]][</span><span class=n>str</span><span class=p>[</span><span class=mi>1</span><span class=p>]]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
            <span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>str</span><span class=p>[</span><span class=mi>1</span><span class=p>]][</span><span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>이 글에서는 행렬 텍스트 파일을 파일입출력을 통해 불러와 반복문을 통해 배열에 입력하는 방식으로 구현했다.
FILE 함수를 통해 파일을 읽어들인 후, 간선, 정점의 갯수를 모두 읽는다.</p>
<p>우선, 인접행렬영역을 0 (방문X)로 초기화를 해주고, 무방향 그래프에서의 대칭성을 고려하여 간선의 갯수만큼 반복문을 이용해 행렬에 입력한다.</p>
<h2 id=print-graph>Print graph<a hidden class=anchor aria-hidden=true href=#print-graph>#</a></h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>outputGraph</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;   &#34;</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;  [%c]&#34;</span><span class=p>,</span> <span class=mi>65</span> <span class=o>+</span> <span class=n>k</span><span class=p>);</span>
    <span class=n>NEWL</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;[%c]&#34;</span><span class=p>,</span> <span class=mi>65</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexcnt</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%5d&#34;</span><span class=p>,</span> <span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]);</span>
        <span class=n>NEWL</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p> </p>
<hr>
<p> </p>
<h2 id=dfs>DFS<a hidden class=anchor aria-hidden=true href=#dfs>#</a></h2>
<p><figure>
<img loading=lazy src=/images/cs/graph_2.jpeg>
</figure>
<br>
그래프내의 각 정점들을 간선을 타고 중복없이 한 번씩 방문하는 방법으로 깊이 우선 탐색 ( Depth First Search ) 법과 너비 우선 탐색 ( Breadth First Search)법이 있다. 무방향 그래프는 특성상 방향이 없기때문에 순회 순서가 유일하지 않다는 특징이 있다.
2가지 중 하나인 &ldquo;깊이 우선 탐색(DFS)&rdquo; 는 탐색을 시작할 정점에 연결된 정점 중 하나를 선택하여 들어가고 그 하나와 연결된 정점들 중 또 하나를 선택해서 들어가고 깊이 들어가는 방식으로 탐색하는 기법이다.
DFS의 과정은 스택을 사용하므로 재귀와 비재귀로 구현 할 수 있다</p>
<h3 id=recursive-dfs>Recursive dfs<a hidden class=anchor aria-hidden=true href=#recursive-dfs>#</a></h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>DFS_recursive</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vNum</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=n>check</span><span class=p>[</span><span class=n>vNum</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=cm>/* 방문한 정점 표시를 위해 1 저장 */</span>
    <span class=n>visit</span><span class=p>(</span><span class=n>vNum</span><span class=p>);</span>   <span class=cm>/* 방문에 따른 처리 */</span>
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span><span class=p>(</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>vNum</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* 연결된 정점이 있으면 */</span>
            <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>   <span class=cm>/* 또한 방문한 적이 없는 정점이면 */</span>
                <span class=n>DFS_recursive</span><span class=p>(</span><span class=n>gm</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span> <span class=cm>/* 재귀 호출을 통해 정점 방문을 한다 */</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>전달인자로 받은 정점번호를 방문처리 해준 뒤, ( 1로 바꿈 ) 그 정점을 visit함수 ( 출력 ) 한다.
다음으로, 정점갯수만큼 반복문을 설정.. 해당 정점에 연결된 정점이 있고 그 정점이 방문배열에서 방문한 적이 없는 정점 이라면 재귀호출을 통해 정점 방문 처리를 해준다.</p>
<h3 id=non-recursive-dfs>Non-Recursive dfs<a hidden class=anchor aria-hidden=true href=#non-recursive-dfs>#</a></h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>nrDFS_Matrix</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>popData</span><span class=p>;</span>  <span class=cm>/* pop한 데이터 저장 */</span>
    <span class=n>Stack</span> <span class=n>stack</span><span class=p>;</span>
    <span class=n>initStack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>);</span>  <span class=cm>/* 비재귀 처리를 위해 사용될 스택 초기화 */</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 정점의 방문상태 정보를 저장할 check배열 초기화 */</span>
        <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 순차적으로 정점을 방문함 */</span>
    <span class=p>{</span>
        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>           <span class=cm>/* 방문하지 않은 정점을 발견 하면 */</span>
        <span class=p>{</span>  
            <span class=n>push</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
            <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
            <span class=k>while</span><span class=p>(</span> <span class=o>!</span><span class=n>isStackEmpty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>)</span> <span class=p>)</span>  <span class=cm>/* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */</span>
            <span class=p>{</span>
                <span class=n>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>popData</span><span class=p>);</span>
                <span class=n>visit</span><span class=p>(</span><span class=n>popData</span><span class=p>);</span>   <span class=cm>/* 정점 방문 */</span>
                 
                <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
                    <span class=k>if</span><span class=p>(</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>popData</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* (!!)pop한 정점과 연결된 j정점이 있고 */</span>
                        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* j정점이 스택에 들어있지 않으면 */</span>
                        <span class=p>{</span>
                            <span class=n>push</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>  <span class=cm>/* j정점을 스택에 저장하고 */</span>
                            <span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
                        <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>destroyStack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>재귀기법을 사용하지 않으면 스택자료구조를 이용해야한다. 스택 초기화 및 생성을 하고 재귀방법과 똑같이 체크배열은 0으로 시켜준다.
순차적으로 정점을 방문한다. 그 정점이 방문한경우가 아니라면 스택에 그 정점을 푸쉬하고 방문상태를 바꿔준다 ( 1로 ) 그리고 스택이 모두 비면 한 연결 요소에 대해 순회가 끝난것을 의미하므로 스택이 빌 때까지 반복문을 걸어준다.
pop을 하여 정점을 꺼내고 해당 정점에 연결된 정점이 있고 방문처리 되지 않은 경우 그 인접정점을 스택에 넣고 방문처리를 해준다.
이런 과정을 모두 하고나면 모든 정점에 대해 순회가 완료된다.</p>
<h2 id=bfs>BFS<a hidden class=anchor aria-hidden=true href=#bfs>#</a></h2>
<p><figure>
<img loading=lazy src=/images/cs/graph_3.jpeg>
</figure>
<br>
너비우선탐색 (BFS) 는 시작한 정점과 연결된 모든 정점을 탐색하고 다시 시작 정점의 다른 연결된 정점을 찾는 순으로, 깊이 들어가기전에 옆으로 넓게 퍼지며 탐색하는 기법이다. DFS와 달리 너비우선탐색 (BFS) 는 스택을 사용하지않고 큐 자료구조를 이용해야 한다. 따라서 재귀호출기법으로는 구현할 수 없다.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>BFS_Matrix</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>getData</span><span class=p>;</span>  <span class=cm>/* dequeue(get)한 데이터 저장 */</span>
    <span class=n>Queue</span> <span class=n>queue</span><span class=p>;</span>
    <span class=n>initQueue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>,</span> <span class=n>MAX_VERTEX</span><span class=p>);</span>  <span class=cm>/* 큐 초기화 */</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 정점의 방문상태 정보를 저장할 check배열 초기화 */</span>
        <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 순차적으로 정점을 방문함 */</span>
    <span class=p>{</span>
        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>           <span class=cm>/* 방문하지 않은 정점을 발견 하면 */</span>
        <span class=p>{</span>  
            <span class=n>enqueue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
            <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
            <span class=k>while</span><span class=p>(</span> <span class=o>!</span><span class=n>isQueueEmpty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>)</span> <span class=p>)</span>  <span class=cm>/* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */</span>
            <span class=p>{</span>
                <span class=n>dequeue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getData</span><span class=p>);</span>
                <span class=n>visit</span><span class=p>(</span><span class=n>getData</span><span class=p>);</span>   <span class=cm>/* 정점 방문 */</span>
                 
                <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
                    <span class=k>if</span><span class=p>(</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>getData</span><span class=p>]</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* (!!)pop한 정점과 연결된 j정점이 있고 */</span>
                        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* j정점이 스택에 들어있지 않으면 */</span>
                        <span class=p>{</span>
                            <span class=n>enqueue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>  <span class=cm>/* j정점을 스택에 저장하고 */</span>
                            <span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
                        <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>destroyQueue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>과정은 DFS랑 매우 비슷하다. 자료구조만 스택에서 큐로 바꾸면 바로 너비우선탐색법이 된다.</p>
<p>큐를 선언 및 초기화 후 체크배열을 초기화한다. 그리고 시작 정점을 기준으로 하여 큐에 넣고 큐가 빌때까지 반복문, 인접정점, 방문 유무를 판단한다.
[그림 3] 을 예로들어서 설명하면 &ldquo;1"을 시작으로 Enqueue한뒤, &ldquo;1"의 인접정점 8 , 5, 2 를 순서대로 모두 Enqueue한다. 그리고 Dequeue를 하면 큐 특성상 첫번째로 넣은 값이 나오게 되므로 8을 방문처리하고 8의 인접정점 6 ,4 ,3 을 모두 Enqueue 그 다음 5를 Dequeue&mldr; 5는 인접정점이 없으므로 다음 Dequeue 2를 방문&mldr;이런 식으로 옆으로 넓게 퍼지며 탐색을 한다.</p>
<h3 id=print-graph-1>print graph<a hidden class=anchor aria-hidden=true href=#print-graph-1>#</a></h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=nf>countGraphComponents</span><span class=p>(</span><span class=n>GraphMatrix</span> <span class=o>*</span><span class=n>gm</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>componetsCount</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>  <span class=cm>/* 그래프 내의 연결 요소 카운트 변수 */</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>popData</span><span class=p>;</span>  <span class=cm>/* pop한 데이터 저장 */</span>
    <span class=n>Stack</span> <span class=n>stack</span><span class=p>;</span>
    <span class=n>initStack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>);</span>  <span class=cm>/* 비재귀 처리를 위해 사용될 스택 초기화 */</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 정점의 방문상태 정보를 저장할 check배열 초기화 */</span>
        <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
 
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=cm>/* 순차적으로 정점을 방문함 */</span>
    <span class=p>{</span>
        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>           <span class=cm>/* 방문하지 않은 정점을 발견 하면 */</span>
        <span class=p>{</span>  
            <span class=o>++</span><span class=n>componetsCount</span><span class=p>;</span>  <span class=cm>/* 방문하지 않은 정점을 발견되면 연결 요소 카운트를 증가 시킴 */</span>
            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>연결 요소 %d : &#34;</span><span class=p>,</span> <span class=n>componetsCount</span><span class=p>);</span>
            <span class=n>push</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
            <span class=n>check</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
            <span class=k>while</span><span class=p>(</span> <span class=o>!</span><span class=n>isStackEmpty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>)</span> <span class=p>)</span>  <span class=cm>/* 스택이 비면 한 연결 요소에 대한 순회가 끝난것을 의미함 */</span>
            <span class=p>{</span>
                <span class=n>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>popData</span><span class=p>);</span>
                <span class=n>visit</span><span class=p>(</span><span class=n>popData</span><span class=p>);</span>   <span class=cm>/* 정점 방문 */</span>
                 
                <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>vertexCnt</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
                    <span class=k>if</span><span class=p>(</span><span class=n>gm</span><span class=o>-&gt;</span><span class=n>graph</span><span class=p>[</span><span class=n>popData</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* (!!)pop한 정점과 연결된 j정점이 있고 */</span>
                        <span class=k>if</span><span class=p>(</span><span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* j정점이 스택에 들어있지 않으면 */</span>
                        <span class=p>{</span>
                            <span class=n>push</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>  <span class=cm>/* j정점을 스택에 저장하고 */</span>
                            <span class=n>check</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>     <span class=cm>/* 방문상태를 1로 변경 */</span>
                        <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>destroyStack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>stack</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>componetsCount</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=print-graph-2>print graph<a hidden class=anchor aria-hidden=true href=#print-graph-2>#</a></h3>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://ralpioxxcs.github.io/tags/data-structure/>Data Structure</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on twitter" href="https://twitter.com/intent/tweet/?text=Graph%20%28matrix%29&url=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f&hashtags=DataStructure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f&title=Graph%20%28matrix%29&summary=Graph%20%28matrix%29&source=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f&title=Graph%20%28matrix%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on whatsapp" href="https://api.whatsapp.com/send?text=Graph%20%28matrix%29%20-%20https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Graph (matrix) on telegram" href="https://telegram.me/share/url?text=Graph%20%28matrix%29&url=https%3a%2f%2fralpioxxcs.github.io%2fcs%2fgraph_matrix%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://ralpioxxcs.github.io/>Devlog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script src=/js/prism.js></script>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>