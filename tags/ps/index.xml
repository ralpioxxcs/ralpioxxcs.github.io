<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ps on Devlog</title>
    <link>https://ralpioxxcs.github.io/tags/ps/</link>
    <description>Recent content in ps on Devlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Feb 2023 16:16:42 +0900</lastBuildDate><atom:link href="https://ralpioxxcs.github.io/tags/ps/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>백준 1038 감소하는 수</title>
      <link>https://ralpioxxcs.github.io/post/ps/boj_1038/</link>
      <pubDate>Sun, 05 Feb 2023 16:16:42 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/ps/boj_1038/</guid>
      <description>문제 링크 문제 해결 N번째 감소하는 수가 몇인지 출력하는 문제, N은 최대 100만까지 입력된다.
간단하게 0부터 987654321까지 감소하는 수인지 판별하는것은 시간초과가 나오므로, 감소하는 수의 특성을 이용하여 풀어야한다.
감소하는 수는 955같이 중복이 나오면 안되고 맨 앞자리의 수에 의해 나머지가 결정된다. 예를들어 특정 감소하는 수가 5로 시작된다면 나머지는 반드시 {1,2,3,4}의 조합으로 이루어져야 한다. 이런 성질을 이용해서 1부터 10까지 대표 앞자리를 설정한 후 각 앞자리마다 파생되는 나머지 숫자들을 조합하면 된다.
1 10 21 -&amp;gt; 210 -&amp;gt; 20 -&amp;gt; 20 32 -&amp;gt; 321 -&amp;gt; 3210 -&amp;gt; 320 31 -&amp;gt; 310 30 43 -&amp;gt; 432 -&amp;gt; 4321 -&amp;gt; 43210 -&amp;gt; 431 -&amp;gt; 430 .</description>
    </item>
    
    <item>
      <title>백준 9328 열쇠</title>
      <link>https://ralpioxxcs.github.io/post/ps/boj_9328/</link>
      <pubDate>Sun, 05 Feb 2023 14:35:42 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/ps/boj_9328/</guid>
      <description>문제 링크 문제 해결 맵에 있는 탐색 가능한 모든 문서의 갯수를 찾는 문제로, BFS를 이용하여 풀었다. 특이한 점은 주어진 열쇠로 맵에 있는 문을 열어서 이동할 수 가 있다는것인데, 열쇠를 맵을 탐색하면서 추가적으로 획득할 수 있기 때문에 이 부분을 유의하여 풀어야 한다.
입력 for _ in range(int(input())): height, width = map(int, input().split()) floor = [list(input()) for _ in range(height)] keys = set(input()) visited = [[0 for _ in row] for row in floor] documents = 0 doors = {} # 열리지 않은 문 리스트 for door in &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;: doors.</description>
    </item>
    
    <item>
      <title>백준 1026 보물</title>
      <link>https://ralpioxxcs.github.io/post/ps/boj_1026/</link>
      <pubDate>Sun, 04 Oct 2020 15:49:50 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/ps/boj_1026/</guid>
      <description>문제 링크 문제 해결 단순 정렬 문제, 각 배열 원소들의 곱 S가 최솟값이 나와야하므로, 큰 수와 작은 수 끼리 곱해주면 된다.
A는 오름차순 정렬, B는 내림차순 정렬을 한 뒤, 반복문을 이용하여 해결
Code a = [] b = [] n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) a = sorted(a, reverse=True) b = sorted(b) sum = 0 for i in range(n): sum += a[i] * b[i] print(sum) </description>
    </item>
    
    <item>
      <title>백준 10815 숫자카드</title>
      <link>https://ralpioxxcs.github.io/post/ps/boj_10815/</link>
      <pubDate>Sun, 04 Oct 2020 15:49:50 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/ps/boj_10815/</guid>
      <description>문제 링크 문제 해결 정수 M개의 입력이 50만개이기때문에 단순 순차 탐색으로는 시간초과가 나온다. 숫자 카드 배열을 먼저 정렬한 후 binary search를 이용하여 해결하였다.
Code # binary search def search(key, left, right): mid = (left + right) // 2 # 종료 조건 if cards[mid] == key: return True if left &amp;gt; right: return False if key &amp;gt; cards[mid]: return search(key, mid+1, right) elif key &amp;lt; cards[mid]: return search(key, left, mid-1) n = int(input()) cards = sorted(list(map(int, input().</description>
    </item>
    
    <item>
      <title>백준 7576 토마토</title>
      <link>https://ralpioxxcs.github.io/post/ps/boj_7576/</link>
      <pubDate>Sun, 04 Oct 2020 15:49:50 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/post/ps/boj_7576/</guid>
      <description>입력 : 세로 크기 N, 가로 크기 M ( 2 &amp;lt;= M,N &amp;lt;= 1,000 )
1 = 익은 토마토 0 = 익지 않은 토마토 -1 = 토마토가 들어있지 않은 칸 출력 : 토마토가 모두 익을 때까지의 최소 날짜 출력
저장될 때부터 모든 토마토가 익었다면 0 모두 익지 못하는 상황이면 -1 문제 해결 입력을 받으면서 익은토마토의 위치를 큐에 PUSH하고 (BFS를사용), 안 익은 토마토의 갯수를 저장한다.
안익은 토마토가 없다면 모두 익은것이므로 0을 출력하고 끝낸다.</description>
    </item>
    
  </channel>
</rss>
