<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>datastructure on My Dev Blog</title>
    <link>https://ralpioxxcs.github.io/tags/datastructure/</link>
    <description>Recent content in datastructure on My Dev Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Sep 2019 13:54:02 +0900</lastBuildDate>
    
	<atom:link href="https://ralpioxxcs.github.io/tags/datastructure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Stack</title>
      <link>https://ralpioxxcs.github.io/study/datastructure/stack/</link>
      <pubDate>Fri, 13 Sep 2019 13:54:02 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/datastructure/stack/</guid>
      <description> Overview </description>
    </item>
    
    <item>
      <title>LinkedList</title>
      <link>https://ralpioxxcs.github.io/study/datastructure/linkedlist/</link>
      <pubDate>Sat, 14 Sep 2019 13:54:02 +0900</pubDate>
      
      <guid>https://ralpioxxcs.github.io/study/datastructure/linkedlist/</guid>
      <description> 개요 비슷한 방식으로 배열이 있지만 배열은 처음부터 메모리를 할당하고 시작하기 때문에, 링크드리스트에 비해 데이터의 삽입이나 삭제가 어렵다. 반면, 링크드리스트는 노드를 데이터를 삽입할 때마다 메모리를 할당하고 데이터를 이어주는 형식이라 배열에 비해 메모리 낭비가 덜 하다는 장점이 있다.
코드 구현 typedef struct _node Node; // 구조체 노드 형명재지정 struct _node{ // 데이터를 보관할 노드(자기참조 구조체) Node *prev; // 앞 노드를 가리키는 멤버 DataType data; // 데이터 저장 멤버 Node *next; // 뒷 노드를 가리키는 멤버 }; typedef struct _linkedList{ // 리스트 관리 구조체 Node *head; // 헤드포인터 (헤드노드 가리킴) Node *cur; // 특정 작업 시 노드를 가리키기 위한 포인터 Node *tail; // 테일포인터 (테일노드 가리킴) int length; // 실제 데이터노드의 갯수 }LinkedList;  </description>
    </item>
    
  </channel>
</rss>